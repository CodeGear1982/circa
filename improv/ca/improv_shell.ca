require_local improv
require stack_trace
require input

def find_module_main(module) -> Func
  method_capture(module :main).or(module.to_func)

def actor(Func func)
  cached(-> make_vm(func))

def main()

  args = env(:args)

  scriptFilename = args[0]

  module = require_file(scriptFilename)
  render_list = require gl/render_list

  state userInput = input.new

  @userInput.handleEvents(env(:inputEvents))

  rect = method_opt(module :window_rect [] [0 0 1000 500])
  Rect.cast(@rect)

  time = env(:time)
  timeDelta = delta(time)

  def actor_setup(actor)
    actor.set_env(:window_rect rect)
    actor.set_env(:time time)
    actor.set_env(:timeDelta timeDelta)
    actor.set_env(:inputEvents [])
    actor.set_env(:userInput userInput)

  window = improv.window(:main rect)
  userActor = actor(find_module_main(module))
  userActor.expect_messages(:render_commands)

  actor_setup(userActor)

  userActor.call

  if userActor.has_error
    stack_trace.dump(userActor)

  for submit in method_capture(render_list :submit)
    renderActor = actor(submit)
    actor_setup(renderActor)
    renderActor.call(userActor.consume_messages(:render_commands))

    if renderActor.has_error
      stack_trace.dump(renderActor)

  window.swap()

{-
asteroids = require_local ../demos/asteroids

main(asteroids)

struct Main {
}

def Main.window_rect(self) [0 0 1000 500]
def Main.main(self)


def realmain()
  main(Main.make)

vm = make_vm(realmain)
vm.call
stack_trace.dump(vm)

main(Main.make)
-}
