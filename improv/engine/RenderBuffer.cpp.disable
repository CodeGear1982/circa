// Copyright (c) Andrew Fischer. See LICENSE file for license terms.

#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include "Font.h"
#include "RenderBuffer.h"

#define BUFFER_OFFSET(i) ((char *)NULL + (i))

const int MAX_ELEMENT_COUNT = 512;

const bool CHECK_GL_ERROR = false;

struct TextContainer
{
    GLuint texid;
    int sizeX;
    int sizeY;
};

struct TextInstance
{
    EntityId container;
    GLuint arrayBuffer;
};

enum EntityType { NONE=0,
    TEXT_CONTAINER,
    TEXT_INSTANCE,
    TEXTURE_ENTITY,
};

typedef struct Entity
{
    EntityType type;
    int step;
    
    union {
        TextContainer textContainer;
        TextInstance textInstance;
    };
} Entity;

struct RenderBuffer
{
    Entity entities[MAX_ELEMENT_COUNT];
    int numEntities;
    
    int firstUnusedEntity;
    
    float viewSizeX, viewSizeY;
    
    // Primary shader
    Program primaryShader;
    
    // Text shader
    Program textShader;
    
    GLKMatrix4 modelViewProjectionMatrix;
    GLKMatrix3 normalMatrix;
    
    // Scratch buffer for temporary results, used for text rendering.
    char* scratch;
};

void check_gl_error()
{
    if (!CHECK_GL_ERROR)
        return;

    GLenum err = glGetError();
    if (err == GL_NO_ERROR)
        return;

    while (err != GL_NO_ERROR) {
        const char* str;
        switch (err) {
            case GL_INVALID_ENUM: str = "GL_INVALID_ENUM"; break;
            case GL_INVALID_VALUE: str = "GL_INVALID_VALUE"; break;
            case GL_INVALID_OPERATION: str = "GL_INVALID_OPERATION"; break;
            case GL_STACK_OVERFLOW: str = "GL_STACK_OVERFLOW"; break;
            case GL_STACK_UNDERFLOW: str = "GL_STACK_UNDERFLOW"; break;
            case GL_OUT_OF_MEMORY: str = "GL_OUT_OF_MEMORY"; break;
            default: str = "(enum not found)";
        }
        printf("OpenGL error: %s\n", str);
        err = glGetError();
    }
    assert(false);
}


RenderBuffer* rb_create()
{
    RenderBuffer* buffer = (RenderBuffer*) malloc(sizeof(RenderBuffer));
    memset(buffer, 0, sizeof(RenderBuffer));
    
    // Set up shaders
    load_shaders(&buffer->primaryShader, "Shader");
    load_shaders(&buffer->textShader, "Text");

    check_gl_error();
    
    return buffer;
}

void rb_set_view_size(RenderBuffer* buffer, float w, float h)
{
    buffer->viewSizeX = w;
    buffer->viewSizeY = h;
}

static EntityId rb_add_entity(RenderBuffer* buffer, EntityType type)
{
    assert(buffer->numEntities < MAX_ELEMENT_COUNT);
    EntityId id = buffer->numEntities++;
    Entity* entity = &buffer->entities[id];
    buffer->entities[id].type = type;

    switch (type)
    {
    case TEXT_CONTAINER:
        glGenTextures(1, &entity->textContainer.texid);
        break;
    case TEXT_INSTANCE:
        glGenBuffers(1, &buffer->entities[id].textInstance.arrayBuffer);

        // Start off with an invalid containerId so that we don't try to
        // render before the arrays are populated.
        entity->textInstance.container = -1;
        break;
    case NONE:;
    }

    check_gl_error();

    return id;
}

void rb_remove_entity(RenderBuffer* buffer, EntityId id)
{
    Entity* entity = &buffer->entities[id];
    switch (entity->type) {
    case TEXT_CONTAINER:
        glDeleteTextures(1, &entity->textContainer.texid);
        break;
    case TEXT_INSTANCE:
        glDeleteBuffers(1, &buffer->entities[id].textInstance.arrayBuffer);
        break;
    case NONE:;
    }

    check_gl_error();
}

EntityId rb_add_texture(RenderBuffer* buffer)
{
    return rb_add_entity(buffer, TEXTURE_ENTITY);
}

GLuint rb_texture_get_glid(RenderBuffer* buffer, EntityId id)
{
}

EntityId rb_add_text_container(RenderBuffer* buffer)
{
    return rb_add_entity(buffer, TEXT_CONTAINER);
}

void rb_set_text_contents(RenderBuffer* buffer, EntityId id, int face, int width, const char* text)
{
    Entity* entity = &buffer->entities[id];
    assert(entity->type == TEXT_CONTAINER);
    TextContainer* textContainer = &entity->textContainer;
    
    // Prepare scratch memory
    int height = font_get_face_height(face);
    
    // Add some extra pixels to width/height and go to next power of 2.
    int sizeX = NextPowerOfTwo(width * 1.1 + 2);
    int sizeY = NextPowerOfTwo(height * 1.1 + 2);

    // Render text with Freetype
    size_t scratchSize = sizeX*sizeY;
    
    buffer->scratch = (char*) realloc(buffer->scratch, scratchSize);
    memset(buffer->scratch, 0, scratchSize);

    RenderFontOperation op;
    op.targetSizeX = sizeX;
    op.targetSizeY = sizeY;
    op.target = buffer->scratch;
    op.face = face;
    op.str = text;
    font_render(&op);

    // Load the result into the GL texture
    glBindTexture(GL_TEXTURE_2D, textContainer->texid);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    
    glTexImage2D(GL_TEXTURE_2D,
                 0,            // level
                 GL_ALPHA,     // internal format
                 sizeX, sizeY, // width/height
                 0,            // border
                 GL_ALPHA,     // format
                 GL_UNSIGNED_BYTE, // type
                 buffer->scratch);
    

    textContainer->sizeX = sizeX;
    textContainer->sizeY = sizeY;

    check_gl_error();
}

EntityId rb_add_text_instance(RenderBuffer* buffer)
{
    return rb_add_entity(buffer, TEXT_INSTANCE);
}

void rb_position_text(RenderBuffer* buffer, EntityId id, EntityId containerId,
                          float posX, float posY)
{
    Entity* entity = &buffer->entities[id];
    assert(entity->type == TEXT_INSTANCE);

    TextInstance* instance = &entity->textInstance;
    
    assert(buffer->entities[containerId].type == TEXT_CONTAINER);
    TextContainer* container = &buffer->entities[containerId].textContainer;
    
    instance->container = containerId;
    entity->step = 1;

    // Upload vertices for polygons
    //
    //       Top
    // Left  [0]  [1]
    //       [2]  [3]

    // vec_mult(

    GLfloat vertices[] = {
        // 3 floats for position, 2 for tex coord
        posX, posY, 0.0,   0.0, 0.0,
        posX + container->sizeX, posY, 0.0,   1.0, 0.0,
        posX, posY + container->sizeY, 0.0,   0.0, 1.0,
        posX + container->sizeX, posY + container->sizeY, 0.0,   1.0, 1.0,
    };

    glBindBuffer(GL_ARRAY_BUFFER, instance->arrayBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_DYNAMIC_DRAW);
    
    glBindBuffer(GL_ARRAY_BUFFER, 0); // Cleanup

    check_gl_error();
}

void rb_text_instance_render(RenderBuffer* buffer, TextInstance* instance)
{
    // Don't render if text has never been positioned.
    if (instance->container == -1)
        return;

    TextContainer* container = &buffer->entities[instance->container].textContainer;
    
    const int floatsPerVertex = 5;
    
    glBindBuffer(GL_ARRAY_BUFFER, instance->arrayBuffer);
    glEnableVertexAttribArray(ATTRIB_VERTEX);
    glVertexAttribPointer(ATTRIB_VERTEX, 3, GL_FLOAT, GL_FALSE, floatsPerVertex*4, BUFFER_OFFSET(0));

    glEnableVertexAttribArray(ATTRIB_TEX_COORD);
    glVertexAttribPointer(ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, floatsPerVertex*4, BUFFER_OFFSET(12));

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, container->texid);
    glUniform1i(buffer->textShader.uniforms.sampler, 0);

    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

    check_gl_error();
}

GLKMatrix4* rb_get_model_view_matrix(RenderBuffer* buffer)
{
    return &buffer->modelViewProjectionMatrix;
}
GLKMatrix3* rb_get_normal_matrix(RenderBuffer* buffer)
{
    return &buffer->normalMatrix;
}

void rb_render_entity(RenderBuffer* buffer, Entity* entity)
{
    switch (entity->type) {
    case NONE:
    case TEXTURE_ENTITY:
    case TEXT_CONTAINER:
        // Not rendered
        break;
    case TEXT_INSTANCE:
        rb_text_instance_render(buffer, &entity->textInstance);
        break;
    }

    check_gl_error();
}

static void rb_render_step(RenderBuffer* buffer, int step)
{
    for (int i = 0; i < buffer->numEntities; i++) {
        Entity* entity = &buffer->entities[i];
        
        if (entity->step != step)
            continue;
        
        rb_render_entity(buffer, entity);
    }
}

void rb_render(RenderBuffer* buffer)
{
    glUseProgram(buffer->primaryShader.program);
    
    // Step 0, perspective projection
    glEnable(GL_DEPTH_TEST);
    glUniformMatrix4fv(buffer->primaryShader.uniforms.modelViewProjectionMatrix, 1, 0,
                       buffer->modelViewProjectionMatrix.m);
    glUniformMatrix3fv(buffer->primaryShader.uniforms.normalMatrix, 1, 0,
                       buffer->normalMatrix.m);
    
    check_gl_error();
    rb_render_step(buffer, 0);

    // Step 1, orthographic projection
    glDisable(GL_DEPTH_TEST);
    glUseProgram(buffer->textShader.program);
    
    GLKMatrix4 modelViewMatrix = GLKMatrix4MakeOrtho(
        0.0, buffer->viewSizeX,   // left/right
        buffer->viewSizeY, 0.0,   // bottom/top
        0.0, 100.0    // near/far
        );

    glUniformMatrix4fv(buffer->textShader.uniforms.modelViewProjectionMatrix,
                       1, 0, modelViewMatrix.m);
    
    check_gl_error();
    rb_render_step(buffer, 1);
    
    // Finish and clean up
    
    // Seems like a decent time to free our scratch memory
    free(buffer->scratch);
    buffer->scratch = NULL;
}

// Circa bindings

#include "circa/circa.h"


void TextLabel_release(caValue* value)
{
}

void create_text_label(caStack* stack)
{
    RenderBuffer* buffer = (RenderBuffer*) circa_handle_get_object(circa_input(stack, 0));
    
    circa_handle_set_object(circa_output(stack, 0), buffer, TextLabel_release);
}

void TextLabel_setPos(caStack* stack)
{
    
}

void rb_install_bindings(caBranch* branch)
{
    circa_install_function(branch, "create_text_label", create_text_label);
    circa_install_function(branch, "TextLabel.setPos", TextLabel_setPos);
}

/*

to get a piece of text on the screen:

 On creation and every time text is changed:
   Freetype render to memory

 On creation and after graphics context is lost:
   Create a gl texture
   Create vertex array

 Every time text is re-rendered:
   Upload memory as a gl texture

 Every time text is positioned
   Update vertex buffer
     glBufferSubData

 Draw:
   Pre-drawing
     Add data to dynamic vertex array

   Drawing
   Bind the texture
   Bind the buffer
   Set the color
   Draw the vertex array
*/
