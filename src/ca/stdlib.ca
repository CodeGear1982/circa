
-- Func --
type Func {
  Block block
  Map bindings
}

def rand() -> number

def closure_block() -> Func
  -- Internally used function for declaring a closure.

def nonlocal(any _) -> any
  -- Internally used function for non-local references.

def Func.call(self, any inputs :multiple) -> any
  -- Call the func using the given inputs.

def Func.apply(self, List inputs) -> any
  -- Like .call, but the inputs are given as one list instead of separate args.

-- Builtin functions --
def convert(any value, Type t) -> any
  -- Convert the value to the given type, if possible.

def assert(bool condition)
  -- Raises an error if 'condition' is false.

def equals(any a,any b) -> bool

def from_string(String s) -> any
  -- Parse a string representation to a Circa value

def error(String msg)

def length(List list) -> int
  -- Return the number of items in the given list

def not_equals(any a,any b) -> bool

def print(any items :multiple)
  -- Prints a line of text output to the console.
def trace(any items :multiple)

def to_string(any val) -> String

def to_string_repr(any val) -> String
  -- Encode a Circa value as a string representation.

def type(any val) -> Type
  -- Returns the runtime type of a value.

def static_type(any term :meta) -> Type
  -- Returns the static type of a value.

def context(any name) -> any
  -- Fetch the context variable in the current scope with the given name.

def context_opt(any name, any default) -> any
  -- Like context(), but if the value doesn't exist then 'default' is used.

def set_context(any name, any value)
  -- Set a context var in the current scope.

def has_effects()
  -- Annotation, declare that a function has effects. Used in native-patched
  -- functions. Not fully supported yet.

def native_patch(String filename)
  -- Declare that this block should be patched by a native module.

def memoize()
  -- Instruct the VM to memoize the current frame.

def reflect_get_frame_state() -> any
  -- Special call, read this frame's state.

-- Type checking
def is_compound(any) -> bool
def is_list(any) -> bool
def is_int(any) -> bool
def is_number(any) -> bool
def is_bool(any) -> bool
def is_string(any) -> bool
def is_null(any) -> bool
def is_function(any) -> bool
def is_type(any) -> bool

def _declared_state(Type t, Func initializer :optional) -> any
  -- Internally used function for fetching a stateful value. The parser
  -- adds a call to this function whereever the 'state' keyword is used.

  existing = reflect_get_frame_state()
  
  if existing != null
    -- Try to cast to the desired type
    existing, cast_success = cast(existing, t)

    if cast_success
      return existing

  -- Cast failed. Try to use the initializer.
  if initializer != null
    return initializer.call()

  -- No initializer. Use the type's default value.
  return make(t)

def _get_root_value(Term t) -> (bool, any)
def _store_root_value(Term t, any val)

def _dynamic_eval(Term t, List inputs) -> List

def _eval_term_on_demand(Term t) -> any
  -- Internal function, used when a nonlocal() term needs a value.
  if t.is_value
    return t.value

  inputs = for Term input in t.inputs
    found, val = _get_module_frame_value(input)
    if not(found)
      val = _eval_term_on_demand(input)
    val

  outputs = _dynamic_eval(t inputs)
  result = outputs[0]
  _store_module_frame_value(t result)
  result

-- Primitive math funcs --
def add(any left, any right) -> any
  if is_int(left) and is_int(right)
    add_i(left, right)
  elif is_int(left) or is_number(left)
    add_f(left, right)
  else
    left.add(right)

def sub(any left, any right) -> any
  if is_int(left) and is_int(right)
    sub_i(left, right)
  elif is_int(left) or is_number(left)
    sub_f(left, right)
  else
    left.sub(right)

def mult(any left, any right) -> any
  if is_int(left) and is_int(right)
    mult_i(left, right)
  elif is_int(left) or is_number(left)
    mult_f(left, right)
  else
    left.mult(right)

def div(any left, any right) -> any
  if is_int(left) or is_number(left)
    div_f(left, right)
  else
    left.div(right)

-- Misc builtin funcs --

def abs(number n) -> number
  -- Absolute value
def any_true(list) -> bool
  result = true
  for i in list
    if not(i)
      return false
  true

def get_with_symbol(any lhs, Symbol symbol) -> any


def first_symbol(any val) -> Symbol
  if type(val) == Symbol
    val
  elif type(val) == List
    if length(val) > 0
      first_symbol(val[0])

def rand_range(number min, number max) -> number
  min + rand() * (max - min)
def rand_i(int range) -> int
  floor(rand() * range)

def swap(a, b) -> (any, any)
  return b, a


type Mutable;
  -- Container for a mutable value. Future status is undecided, this might
  -- be removed.
def Mutable.set(self, any val)
def Mutable.get(self) -> any

-- Modules

type ModuleRef {
  Block block
}

def native_patch_this(String filename)
  -- Annotation, declare that the current module should be patched by a native
  -- module with the given filename.

def load_module(String moduleName) -> Block
  -- Look for a loaded module with the given name, and load it if necessary.
  -- The module search path will be used, and the result is stored in module
  -- space.

def load_script(String filename) -> Block
  -- Load a script with the given filename. The result will only be available
  -- locally; it won't be loaded into module space.

def require(String moduleName) -> ModuleRef
  -- Load a module.

def package(String moduleName)
  -- Declare that the current module is a reusable library with the given name.
  -- (Note: Currently this function does nothing)

-- Packages
type Package {
  String name
  Map files
}

-- Test helpers
def test_oracle() -> any
  -- For internal testing. This function will output values that are manually
  -- inserted with the C++ function oracle_send().

def test_spy(any val)
  -- For internal testing. This function will save inputs to a global list which
  -- can be easily examined from C++ with test_spy_get_results().

-- File module
def file_exists(String filename) -> bool
def file_version(String filename) -> int
def file_read_text(String filename) -> String
def file_changed(String filename) -> bool
  ver = file_version(filename)
  changed([filename ver])

-- Reflect module
def reflect_this_block() -> Block
def reflect_caller() -> Term
def reflect_kernel() -> Block

-- Sys module
def sys_arg(int index) -> String
def sys_module_search_paths() -> List
def sys_perf_stats_reset()
def sys_perf_stats_dump() -> List

def global_script_version() -> int

-- Builtin types
type FileSignature { String filename, int time_modified }
type Callable;
type Color { number r, number g, number b, number a }
type Stack;
type Point { number x, number y }
type Point_i { int x, int y }
type Rect { number x1, number y1, number x2, number y2 }
type Rect_i { int x1 int y1 int x2 int y2 }

-- Metaprogramming on Block
def block_ref(any block :ignore_error) -> Block
  -- Obtain a Block ref from an expression.
def Block.dump(self)
  -- Dump this block's raw contents to stdout.
def Block.find_term(self, String name) -> Term
  -- Find a term inside this Block with the given name.
def Block.to_code_lines(self) -> List
def Block.format_source(self) -> List
  -- Return the block's contents as formatted source.
def Block.format_function_heading(self) -> List
  -- Return a formatted function header for this block.
def Block.functions(self) -> List
  -- Return a list of functions that occur inside this block.
def Block.get_term(self, int index) -> Term
  -- Fetch a term by index.
def Block.get_static_errors(self) -> List
  -- Return a raw list of static errors inside this block.
def Block.get_static_errors_formatted(self) -> List
  -- Return a formatted list of static errors inside this block.
def Block.has_static_error(self) -> bool
  -- Return whether this block has any static errors.
def Block.id(self) -> int
def Block.input(self, int index) -> Term
  -- Fetch an input placeholder term by index.
def Block.is_null(self) -> bool
  -- Return whether this is a null Block reference.
def Block.inputs(self) -> List
  -- Return a list of input placeholder terms.
def Block.link(self, Block lib)
  -- Iterate through this block, looking for terms that have missing references.
  -- For each missing reference, if a term with the expected name is found in 'lib',
  -- then modify the term to use the named term in 'lib'.
def Block.list_configs(self) -> List
  -- Return a list of Terms that look like configs (named literal values).
def Block.output(self, int index) -> Term
  -- Return an output term by index.
def Block.output_placeholder(self, int index) -> Term
  -- Return an output placeholder term by index.
def Block.owner(self) -> Term
  -- Return the Term that owns this Block (may be null).
def Block.parent(self) -> Block
  -- Return the Block that owns this Block (may be null).
def Block.primary_output(self) -> Term
  -- Return the primary output.
  self.output(0)
def Block.property(self, Symbol key) -> any
def Block.properties(self) -> Map
def Block.source_filename(self) -> String
def Block.statements(self) -> List
  -- Return a list of Terms that are statements.
def Block.terms(self) -> List
  -- Return a list of this block's terms.
def Block.walk_terms(self) -> List
  -- Return a list of this block's terms, and all nested terms.

def Block.to_func(self) -> Func
  Func.make(self)
def Block.to_stack(self) -> Stack
  make_stack(self.to_func)

-- Language defect: out-of-order function definition.
def Block.call(self, any inputs :multiple) -> any
  -- Invoke this Block with the given inputs.
  self.to_func.apply(inputs)

type Frame { Stack stack, int index }
type RetainedFrame { Block block, any _state }
type ModuleFrame { Block block, List registers }

def Frame.active_value(self, Term) -> any
def Frame.set_active_value(self, Term, any)
def Frame.block(self) -> Block
  -- Return the Block associated with this Frame.
def Frame.current_term(self) -> Term
  -- Fetch the term associated with the current program counter.
def Frame.create_expansion(self, Term term) -> Frame
  -- Create an expansion frame using the given Term.
  -- Errors if the Term is not part of this frame's block.
def Frame.height(self) -> int
  -- Frame height, the distance from the base frame.
def Frame.has_parent(self) -> bool
def Frame.parent(self) -> Frame
  -- Return this frame's parent.
def Frame.pc(self) -> int
  -- Fetch the current program counter (the interpreter's current position).
def Frame.parentPc(self) -> int
def Frame.register(self, int index) -> any
  -- Fetch the value in the given register index.
def Frame.registers(self) -> List
  -- Fetch a list of all register values.
def Frame.inputs(self) -> List
  -- Returns a list of input register values
def Frame.input(self, int nth) -> any
  -- Returns the nth input register value
def Frame.outputs(self) -> List
  -- Returns a list of output register values
def Frame.output(self, int nth) -> any
  -- Returns the nth output register value
def Frame.extract_state(self) -> Map
  -- Returns the frame's state as a plain object (composite of maps and lists).

def capture_stack() -> Stack
  -- Returns a frozen copy of the currently executing stack.
def Stack.apply(self, List inputs) -> any
def Stack.block(self) -> Block
  -- Returns the (topmost) block.
def Stack.call(self, any inputs :multiple) -> any
def Stack.current_term(self) -> Term
  self.top.current_term
def Stack.dump(self)
  -- Dumps a string representation to stdout.
def Stack.dump_with_bytecode(self)
def Stack.eval_on_demand(self, Term term) -> any
def Stack.find_active_value(self, Term term) -> any
def Stack.rethrow(self)
  -- If the stack has an error, raise it in this context.
  if self.has_error
    error(self.error_message)
def Stack.extract_state(self) -> Map
def Stack.find_active_frame_for_term(self, Term term) -> Frame
def Stack.id(self) -> int
def Stack.has_incoming_state(self) -> bool
def Stack.set_context(self, Map map)
def Stack.set_context_val(self, any name, any val)
def Stack.stack_push(self, Block b, List inputs)
  -- Push a new frame, using the given block and input list.
def Stack.stack_push2(self, Func func)
  self.stack_push(func.block, [])
def Stack.stack_pop(self)
  -- Pop the topmost frame.
def Stack.set_state_input(self, any)
def Stack.get_state_output(self) -> any
def Stack.migrate(self, Block from, Block to)
def Stack.migrate_to(self, Func func)
  -- Use 'func' as the new root, and migrate data and state.
def Stack.reset(self)
def Stack.reset_state(self)
def Stack.restart(self)
  -- Restart or "rewind" the stack, so the program counter is returned to the start
  -- of the topmost frame. State is preserved.
def Stack.restart_discarding_state(self)
def Stack.run(self) -> Stack
  -- Run the interpreter until either the topmost frame is finished, or an error
  -- is raised.
def Stack.frame(self, int depth) -> Frame
  -- Return the Frame with the given depth. The top of the stack has depth 0.
def Stack.frame_from_base(self, int height) -> Frame
  -- Return the Frame with the given height.
def Stack.frame_count(self) -> int
def Stack.top(self) -> Frame
  -- Return the topmost Frame.
  self.frame(0)
def Stack.active_value(self, Term term) -> any
  self.top.active_value(term)
def Stack.set_active_value(self, Term term, any val)
  self.top.set_active_value(term, val)
def Stack.output(self, int index) -> any
  -- Fetch the value in the nth output register.
def Stack.errored(self) -> bool
  -- Returns true if the interpreter has stopped due to error.
def Stack.has_error(self) -> bool
  self.errored
def Stack.error_message(self) -> String
  -- If there is a recorded error, returns a human-readable description string.
def Stack.toString(self) -> String

def make_stack(Func func) -> Stack
  -- Create a new stack

def make_actor(Func func) -> Stack
  make_stack(func)

def Func.to_stack(self) -> Stack
  make_stack(self)

def empty_list(any initialValue, int size) -> List
def repeat(any val, int count) -> List
def List.append(self, any item) -> List
  -- Append an item to the end of this list.
def List.clear(self) -> List
  -- Return an empty list.
  []

def List.concat(self, List rightSide) -> List
  -- Concatenate two lists.
def List.contains(self, any val) -> bool
  for i in self
    if i == val
      return true
  return false
def List.resize(self, int length) -> List
  -- Resize the list to have the given length. If the length is increased, then
  -- null values are appended on the right; if the length is decreased then
  -- existing values on the right are dropped.
def List.count(self) -> int
  -- Return the number of elements in this list.

def List.insert(self, int index, any val) -> List
  -- Insert an element at the given index. If necessary, existing elements will
  -- be shifted to the right to make room.
  --
  -- Example:
  --   a = [1 2 3]
  --   a.insert(1, 'X')
  --   -- a now equals [1 'X' 2 3]
    
def List.length(self) -> int
  -- Return the number of elements in this list.

def List.join(self, String joiner) -> String
  -- Return a string constructed by converting every element to a string, and
  -- concatenating those strings, each separated by 'joiner'.
  --
  -- Example:
  --  [1 2 3].join(', ')
  -- 
  -- Outputs: '1, 2, 3'

def List.slice(self, int start, int fin) -> List
  -- Return a list constructed from the elements starting from index 'start', and
  -- ending immediately before index 'fin'.
  --
  -- If either 'start' or 'fin' is negative, it's interpreted as an offset from the
  -- end of the list.
  --
  -- Examples:
  --  [1 2 3 4].slice(1 3)
  --  Outputs: [2 3]
  -- 
  --  [1 2 3 4].slice(0 -2)
  --  Outputs: [1 2 3 4]

def List.get(self, int index) -> any
  -- Get an element by index.

def List.get_optional(self, int index, any fallback) -> any
  -- Get an element by index if it exists, otherwise return 'fallback'.
  if index < 0 or index >= self.length
    fallback
  else
    self.get(index)

def List.set(self, int index, any val) -> List
  -- Set an element by index.
def List.remove(self, int index) -> List
  -- Remove an element at the given index, shrinking the list by 1.

def List.add(self, any value) -> List
  if is_compound(value)
    for i in self { i + value[index()] }
  else
    for i in self { i + value }
def List.sub(self, any value) -> List
  if is_compound(value)
    for i in self { i - value[index()] }
  else
    for i in self { i - value }
def List.mult(self, any value) -> List
  if is_compound(value)
    for i in self { i * value[index()] }
  else
    for i in self { i * value }
def List.div(self, any value) -> List
  if is_compound(value)
    for i in self { i / value[index()] }
  else
    for i in self { i / value }

def List.cycle(self, int index) -> any
  -- Get an element by index. If the index is out of bounds, then modulo the
  -- index to one that exists.
  self.get(mod(index, self.length))

def List.empty(self) -> bool
  -- Returns whether the list is empty.
  self.length == 0
def List.first(self) -> any
  -- Returns the first element
  self.get(0)
def List.last(self) -> any
  -- Returns the last element
  self.get(self.length - 1)

def List.pop(self) -> (List, any)
  return self.slice(0, -1), self.last

def List.filter(self, Func func) -> List
  result = []
  for i in self
    if func.call(i)
      result.append(i)
  result

def List.map(self, Func func) -> List
  for i in self
    func.call(i)

def List.mapItem(self, int index, Func func) -> List
  self.set(index, func.call(self[index]))

def Map.contains(self, any key) -> bool
  -- Returns true if the map contains the given key.
def Map.remove(self, any key) -> Map
  -- Removes the given key from the map.
def Map.get(self, any key) -> any
  -- Gets the key associated with this value.
def Map.get_optional(self, any key, any default) -> any
  if self.contains(key)
    self.get(key)
  else
    default
def Map.set(self, any key, any value) -> Map
  -- Sets the value associated with this key.
def Map.insertPairs(self, List pairs) -> Map
  -- Set multiple key-value pairs.
def Map.empty(self) -> bool
def Map.map_element(@self, any key, Func func)
  @self.set(key, func.call(self.get(key)))

type Set {
  Map m
}

def Set.add(self, element) -> Set
  @self.m.set(element, true)

def Set.contains(self, element) -> bool
  self.m.contains(element)

def Set.remove(self, element) -> Set
  @self.m.remove(element)

def List.to_set(self) -> Set
  set = make(Set)
  for item in self
    @set.add(item)
  set

-- Overloaded functions
def is_overloaded_func(Block block) -> bool
    -- Return true if this block is an overloaded function

def overload_get_contents(Block block) -> List
    -- Get a list of all the functions that this overloaded function uses.

def String.append(self, String right) -> String
    -- Append a string to the right side.
    concat(self, right)
    
def String.char_at(self, int index) -> String

def String.ends_with(self, String suffix) -> bool
    -- Return true if this string ends with the given substring.
def String.length(self) -> int
    -- Returns the string length.
def String.slice(self, int start, int fin) -> String
def String.starts_with(self, String prefix) -> bool
    -- Returns true if the string starts with the given prefix.
def String.split(self, String sep) -> List
def String.substr(self, int start, int fin) -> String
def String.to_camel_case(self) -> String
    -- Deprecated function
def String.to_lower(self) -> String
def String.to_upper(self) -> String

def String.characters(self) -> List
    out = for i in 0..(self.length)
        self.char_at(i)
    return out

def Type.declaringTerm(self) -> Term
def Type.cast(self, any value) -> any
    value, success = cast(value, self)
    if not(success)
        error(concat("Couldn't cast value " value " to type " self.name))
    value
        
def Type.make(self, any values :multiple) -> any
def Type.name(self) -> String
def Type.property(self, String name) -> any

-- Metaprogramming on Term
def term_ref(any term :ignore_error) -> Term
def Term.assign(self, any val)
def Term.asint(self) -> int
def Term.asfloat(self) -> number
def Term.index(self) -> int
def Term.contents(self) -> Block
    -- Fetch the nested Block contents of this Term. The format and the meaning
    -- of these contents is dictated by the term's function.
def Term.is_input(self) -> bool
def Term.is_null(self) -> bool
    -- Returns whether this is a null Term reference.
def Term.is_output(self) -> bool
def Term.is_statement(self) -> bool
def Term.name(self) -> String
    -- Return this term's local name. May be blank.
def Term.parent(self) -> Block
def Term.to_string(self) -> String
def Term.to_source_string(self) -> String
def Term.format_source(self) -> List
    -- Return a list of formatted source phrases for this Term
def Term.format_source_normal(self) -> List
    -- Return a list of formatted source phrases for this Term. This formatting is 'normal',
    -- meaning that it doesn't include the source for inputs (inputs are referred to by name
    -- or by id), and special syntax is not used.
def Term.function(self) -> Block
    -- Fetch this term's function.
def Term.get_type(self) -> Type
    -- Fetch the declared type of this term.
def Term.id(self) -> int
def Term.value(self) -> any
    -- For a value term, this fetches the actual value.
def Term.set_value(self, any val)
    -- For a value term, permanently change the value.
def Term.tweak(self, number steps)
def Term.input(self, int index) -> Term
    -- Fetch an input term by index.
def Term.inputs(self) -> List
    -- Return a list of input terms.
def Term.num_inputs(self) -> int
    -- Return the number of inputs.
def Term.source_location(self) -> Rect_i
    -- Return a Rect_i that describes where this term occurs in its source file.
def Term.location_string(self) -> String
def Term.global_id(self) -> int
    -- Fetch this term's global identifier.
def Term.properties(self) -> Map
def Term.property(self, Symbol key) -> any
    -- Fetch a term property.
def Term.is_value(self) -> bool
    self.function == block_ref(value)
def Term.is_function(self) -> bool
    self.get_type == Func
def Term.is_type(self) -> bool
    self.is_value and is_type(self.value)
def Term.is_input_placeholder(self) -> bool
    self.function == block_ref(input_placeholder)
def Term.is_comment(self) -> bool
    self.function == block_ref(comment)
def Term.trace_dependents(self, Block untilBlock) -> List

-- workaround, these functions currently need to be declared after Term:
def Block.name(self) -> String
    self.owner.name

def Block.is_method(self) -> bool
  self.owner.property("syntax:methodDecl") == true

def Block.get_top_comments(self) -> List
  out = []
  for Term t in self.terms
    if t.is_input_placeholder
      continue
    elif t.is_comment
      str = t.property('comment')
      if str == ""
        break

      out.append(t.property('comment'))
    else
      break

  out

def Point.add(self, Point b) -> Point
  [self.x + b.x, self.y + b.y]
def Point.sub(self, Point b) -> Point
  [self.x - b.x, self.y - b.y]
def Point.mult(self, number scalar) -> Point
  [self.x * scalar, self.y * scalar]
def Point.div(self, number scalar) -> Point
  [self.x / scalar, self.y / scalar]
    
def Point.distance(self, Point b) -> number
  -- Returns the distance between self and b.
  sqrt(sqr(self.x - b.x) + sqr(self.y - b.y))

def Point.magnitude(self) -> number
  -- Return the magnitude of this point, aka the distance to the origin.
  sqrt(sqr(self.x) + sqr(self.y))

def Point.norm(self) -> Point
  -- Returns the point normalized to be along the unit circle.
  m = self.magnitude
  [self.x / m, self.y / m]

def Point.perpendicular(self) -> Point
  -- Returns a vector that is perpendicular to its old value, rotated clockwise.
  [self.y -self.x]

def Point.translate(self, Point b) -> Point
  [self.x + b.x, self.y + b.y]

def Point.to_rect_center(self, Point size) -> Rect
  -- Returns a Rect with this point as the center, and the given size.
  size_half = (size * 0.5) -> Point.cast
  [self.x - size_half.x,
      self.y - size_half.y, self.x + size_half.x, self.y + size_half.y]

def Point.to_rect_topleft(self, Point size) -> Rect
  -- Returns a Rect with this point as the top-left, and the given size.
  [self.x, self.y, self.x + size.x, self.y + size.y]

def Point.delta(self) -> Point
  -- Stateful function, returns the point difference since the last step.
  state Point prev = self
  result = [self.x - prev.x, self.y - prev.y]
  prev = self
  result

def Point.rotate(self, number rotation) -> Point
  -- Return the point rotated around [0 0] by the given angle.
  [self.x*cos(rotation) - self.y*sin(rotation), self.x*sin(rotation)+self.y*cos(rotation)]

def Rect.add(self, Rect b) -> Rect
  [self.x1 + b.x1, self.y1 + b.y1, self.x2 + b.x2, self.y2 + b.y2]
def Rect.sub(self, Rect b) -> Rect
  [self.x1 - b.x1, self.y1 - b.y1, self.x2 - b.x2, self.y2 - b.y2]
def Rect.mult(self, number s) -> Rect
  [self.x1 * s, self.y1 * s, self.x2 * s, self.y2 * s]
def Rect.div(self, number s) -> Rect
  [self.x1 / s, self.y1 / s, self.x2 / s, self.y2 / s]

def Rect.width(self) -> number
  self.x2 - self.x1
def Rect.height(self) -> number
  self.y2 - self.y1
def Rect.size(self) -> Point
  [self.width self.height]
def Rect.left(self) -> number
  self.x1
def Rect.top(self) -> number
  self.y1
def Rect.right(self) -> number
  self.x2
def Rect.bottom(self) -> number
  self.y2
def Rect.topleft(self) -> Point
  -- Returns the top-left coordinates as a Point.
  [self.x1 self.y1]
def Rect.topright(self) -> Point
  -- Returns the top-rigth coordinates as a Point.
  [self.x2 self.y1]
def Rect.bottomleft(self) -> Point
  -- Returns the bottom-left coordinates as a Point.
  [self.x1 self.y2]
def Rect.bottomright(self) -> Point
  -- Returns the bottom-right coordinates as a Point.
  [self.x2 self.y2]
def Rect.center(self) -> Point
  -- Returns the rectangle's center as a Point
  [(self.x1 + self.x2) / 2, (self.y1 + self.y2) / 2]

def Rect.intersects(self, Rect b) -> bool
  -- Return whether the two rectangles intersect.
  intersects_on_x = (self.x2 > b.x1) and (b.x2 > self.x1)
  intersects_on_y = (self.y2 > b.y1) and (b.y2 > self.y1)
  intersects_on_x and intersects_on_y

def Rect.translate(self, Point p) -> Rect
  [self.x1 + p.x, self.y1 + p.y, self.x2 + p.x, self.y2 + p.y]

def Rect.contains(self, Point p) -> bool
  p.x >= self.x1 and p.y >= self.y1 and p.x < self.x2 and p.y < self.y2

def Rect.grow(self, Point size) -> Rect
  [self.x1 - size.x, self.y1 - size.y, self.x2 + size.x, self.y2 + size.y]

def Rect.subtractFrom(self, Symbol side, number dimension) -> (Rect, Rect)
  if side == :top
    min(@dimension, self.height)
    out = self.set_y2(dimension)
    self.y1 += dimension
    return self, out
  if side == :left
    min(@dimension, self.width)
    out = self.set_x2(self.x1 + dimension)
    self.x1 += dimension
    return self, out
  if side == :right
    min(@dimension, self.width)
    out = self.set_x1(self.x2 - dimension)
    self.x2 -= dimension
    return self, out
  if side == :bottom
    min(@dimension, self.height)
    out = self.set_y1(self.y2 - dimension)
    self.y2 -= dimension
    return self, out
  error(concat('Unrecognized side: ' side))

def sum(List numbers) -> number
  result = 0
  for i in numbers
    result += i
  result
    
def zip(List left, List right) -> List
  for l in left
    [l, right.get_optional(index(), null)]

-- Stateful functions

def cached(Func refresh) -> any
  state Func _refresh
  state version = global_script_version()
  state _out
  if _refresh != refresh or version != global_script_version()
    _refresh = refresh
    _out = refresh.call()
  _out

def changed(any val) -> bool
  -- Stateful function; returns true if the value has changed since the
  -- previous step.
  state any prev = null
  result = prev != val
  prev = val
  result

def delta(number val) -> number
  -- Stateful function, return the difference between this value and the value from
  -- the previous call.
  state number prev = val
  result = val - prev
  prev = val
  result

def toggle(bool tog) -> bool
  -- Stateful function, returns a boolean status. Every frame the function is called
  -- with (true), the result flips. Starts out false.

  state bool s = false
  if tog
    s = not(s)
  s

def approach(number target, number maximum_change) -> number
  -- Stateful function, returns a result which approaches 'target'. Each time the
  -- function is called, the result will change at most by 'maximum_change'.
  state current = target
  if target > current
    current += min(maximum_change, target - current)
  elif target < current
    current -= min(maximum_change, current - target)
  current

def once() -> bool
  -- Stateful function, returns true the first time it's called, and false thereafter.
  state bool s = true
  result = s
  s = false
  result

def cycle(int max) -> int
  -- Stateful function, cycles though the integers from 0 to (max - 1). When the
  -- maximum is reached, the function will start again at 0.

  state int counter = 0
  if counter >= max
    counter = 0
  result = counter
  counter += 1
  result

def cycle_elements(List list) -> any
  -- Stateful function, cycles through each item of 'list' one at a time.
  list[cycle(length(list))]

def random_element(List list) -> any
  -- Return a random element from the given list, with equal probability per element.
  list[rand_i(length(list))]

def seed() -> number
  -- Stateful function, returns a random number 0..1 which doesn't change after
  -- initialization.
  state number s = rand()
  s

-- Math utility functions
def polar(number angle) -> Point
  -- Return a point on the unit circle with the given angle.
  [cos(angle) sin(angle)]

def random_norm_vector() -> Point
  -- Return a random normalized vector.
  angle = rand() * 360
  [cos(angle) sin(angle)]

def rect(number x1, number y1, number x2, number y2) -> Rect
  [x1 y1 x2 y2]

def bezier3(number t, List points) -> Point
  -- Quadratic bezier curve, with 3 control points. t must be in the range of [0, 1].
  p0 = points[0] -> Point.cast
  p1 = points[1] -> Point.cast
  p2 = points[2] -> Point.cast
  (p0 * sqr(1 - t) + p1 * (2 * t * (1 - t)) + p2 * sqr(t))

def bezier4(number t, List points) -> Point
  -- Cubic bezier curve, with 4 control points. t must be in the range of [0, 1].
  p0 = points[0] -> Point.cast
  p1 = points[1] -> Point.cast
  p2 = points[2] -> Point.cast
  p3 = points[3] -> Point.cast
  (p0 * cube(1 - t) + p1 * (3 * t * sqr(1 - t)) + p2 * sqr(t) * (3 * (1 - t)) + p3 * cube(t))

def smooth_in_out(number t, number smooth_in, number smooth_out) -> number
  bezier4(t, [[0 0] [smooth_in, 0] [1 - smooth_out, 1] [1 1]]).y

def clamp(number x, number minVal, number maxVal) -> number
  -- Return a clamped value. If x is less than 'minVal' then return 'minVal', if it's
  -- greater than 'maxVal' then return 'maxVal', otherwise return the original 'x'.
  min(max(x, minVal), maxVal)

def smoothstep(number x, number edge0, number edge1) -> number
  -- Smooth interpolation func, see en.wikipedia.org/wiki/Smoothstep
  x = clamp((x - edge0)/(edge1-edge0), 0, 1)
  x*x*(3 - 2*x)

def smootherstep(number x, number edge0, number edge1) -> number
  -- Alternative to smoothstep by Ken Perlin, see en.wikipedia.org/wiki/Smoothstep
  x = clamp((x - edge0)/(edge1-edge0), 0, 1)
  x*x*x*(x*(x*6 - 15) + 10)

def random_color() -> Color
  -- Return a color with random RGB components.
  [rand() rand() rand() 1.0]

def hsv_to_rgb(List hsv) -> Color
  -- Convert HSV components to an RGB Color

  h = hsv[0] -> number.cast
  s = hsv[1] -> number.cast
  v = hsv[2] -> number.cast

  if s == 0
      -- grey
      return [v v v 1]

  h *= 6
  i = floor(h)
  f = h - i
  p = v * (1 - s)
  q = v * (1 - s * f)
  t = v * (1 - s * (1 - f))

  if i == 0
    [v t p 1]
  elif i == 1
    [q v p 1]
  elif i == 2
    [p v t 1]
  elif i == 3
    [p q v 1]
  elif i == 4
    [t p v 1]
  elif i == 5
    [v p q 1]
  else
    [0 0 0 0]

def Color.add(self, any value) -> Color
  for i in self { i + value }
def Color.sub(self, any value) -> Color
  for i in self { i - value }
def Color.mult(self, any value) -> Color
  for i in self { i * value }
def Color.div(self, any value) -> Color
  for i in self { i / value }

def Color.blend(self, Color rhs, number ratio) -> Color
  -- Return a color that is blended between self and rhs. If ratio is 0.0 we'll
  -- return 'self', if it's 1.0 we'll return 'rhs'.

  max(@ratio, 0.0)
  min(@ratio, 1.0)

  if ratio == 0.0
    self
  elif ratio == 1.0
    rhs
  else
    self + (rhs - self) * ratio

def Color.lighten(self, number factor) -> Color
  -- Linearly lighte each component of the color.
  [ min(self.r + factor, 1.0)
    min(self.g + factor, 1.0)
    min(self.b + factor, 1.0)
    self.a]
        
def Color.darken(self, number factor) -> Color
  -- Linearly darken each component of the color.
  [ max(self.r - factor, 0.0)
    max(self.g - factor, 0.0)
    max(self.b - factor, 0.0)
    self.a]

