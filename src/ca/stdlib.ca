
def unknown_function_prelude(any ins :multiple)

def annotate(term, Symbol key, value :optional)
def annotate_block(Symbol key, value :optional)
def declare_field()
def emit(Symbol name, any val)
  annotate_block(:effect)
def equals(any a,any b) -> bool
def not_equals(any a,any b) -> bool
def discard(any outs :multiple :optional)
def dynamic_method(any inputs :multiple)
def break(any outs :multiple :optional)
def continue(any outs :multiple :optional)
def make(Type t) -> any
def extra_output(any _) -> any
def func_call_implicit(inputs :multiple)
def get_field(any obj, String key) -> any
def method_lookup(location, any obj, Symbol name) -> List
def get_index(List list, int index) -> any
def selector(any elements :multiple) -> Selector
def get_with_selector(any object, Selector selector) -> any
def return(any outs :multiple :optional)
def set_with_selector(any object, Selector selector, any newValue) -> any
def section()
def loop_condition_bool(bool condition)
def loop_iterator()
def while()
def for(List list) -> List
def if() -> any
def case(bool b :optional)
def switch(any input :optional) -> any
def upvalue(term :ref) -> any
def reflect_caller(int height) -> Term
def reflect_stack_trace() -> List
def rand() -> number
def error(any msg :multiple)
  annotate_block(:hide_from_trace)
def to_string_repr(any val) -> String
  -- Encode a value as a string representation.
def typeof(any val) -> Type
  -- Returns the runtime type of a value.
def declared_state_close(v)

def env(any name) -> any
  -- Fetch an env variable.
def env_opt(any name, any default) -> any
def copy(any val) -> any

def cast(any val, Type t) -> any
  -- Cast the value to the given type. Returns null if cast fails.

def untyped(v) -> any
  v

def cond(bool condition, any pos, any neg) -> any
  -- If 'condition' is true, returns 'pos'. Otherwise returns 'neg'.

def str(any vals :multiple) -> String
  -- Convert inputs to a string and concatenate the result

def copy(any val) -> any

def convert(any value, Type t) -> any
  -- Convert the value to the given type, if possible.

def compute_patch(existing, new) -> any
  -- Compute a patch, which when applied to 'existing' will equal 'new'

def apply_patch(existing, patch) -> any
  -- Apply a patch

def assert(bool condition)
  -- Raises an error if 'condition' is false.

def from_string(String s) -> any
  -- Parse a string representation to a value

def print(any items :multiple)
  -- Prints a line of text output to the console.

def trace(any items :multiple)
  -- Like print()

def global_script_version() -> int

def get(obj, name) -> any
def set(obj, names_and_vals :multiple) -> any

-- deprecated:
def delete(Table val, List path) -> Table

-- List values
def make_list(any vals :multiple) -> List
def blank_list(int count) -> List

-- Logical
def and(bool a, bool b) -> bool
  -- Return whether a and b are both true
def or(bool a, bool b) -> bool
  -- Return whether a or b are both true
def not(bool b) -> bool

def make_table(any vals :multiple) -> Table

def unique_id() -> int
def source_id() -> any

-- Math
def abs(number n) -> number
  -- Absolute value
def add_i(int a, int b) -> int
def add_f(number a, number b) -> number
def div_f(number a,number b) -> number
def div_i(number a,number b) -> int
def max_f(number a,number b) -> number
  -- Maximum of two numbers
def max_i(int a,int b) -> int
  -- Maximum of two integers
def min_f(number a,number b) -> number
  -- Minimum of two numbers
def min_i(int a,int b) -> int
  -- Minimum of two integers
def remainder_i(int a,int b) -> int
def remainder_f(number a,number b) -> number
def mult_i(int a,int b) -> int
def mult_f(number a,number b) -> number
def mod_i(int a,int b) -> int
def mod_f(number a,number b) -> number
def neg_i(int i) -> int
def neg_f(number n) -> number
def sub_i(int a,int b) -> int
def sub_f(number a,number b) -> number
def round(number n) -> int
  -- Return the integer that is closest to n
def floor(number n) -> int
  -- Return the closest integer that is less than n
def ceil(number n) -> int
  -- Return the closest integer that is greater than n
def average(vals :multiple) -> number
  -- Returns the average of all inputs
def pow(number i, number x) -> number
  -- Returns i to the power of x
def sqr(number n) -> number
  -- Square function
def cube(number n) -> number
  -- Cube function
def sqrt(number n) -> number
  -- Square root
def log(number n) -> number
  -- Natural log function

-- Trig
def sin(number degrees) -> number
  -- Trigonometric sin() function
def cos(number degrees) -> number
  -- Trigonometric cos() function
def tan(number degrees) -> number
  -- Trigonometric tan() function
def arcsin(number n) -> number
  -- Trigonometric arcsin() function
def arccos(number n) -> number
  -- Trigonometric arccos() function
def arctan(number n) -> number
  -- Trigonometric arctan() function

-- Type checking
def is_compound(n) -> bool
def is_list(n) -> bool
def is_table(n) -> bool
def is_int(n) -> bool
def is_number(n) -> bool
def is_bool(n) -> bool
def is_string(n) -> bool
def is_func(n) -> bool
def is_type(n) -> bool

def is_scalar(n) -> bool
  is_int(n) or is_number(n)

-- Overloaded math funcs
def add(any left, any right) -> any
  if is_int(left) and is_int(right)
    add_i(left, right)
  elif is_int(left) or is_number(left)
    add_f(left, right)
  else
    left.add(right)

def sub(any left, any right) -> any
  if is_int(left) and is_int(right)
    sub_i(left, right)
  elif is_int(left) or is_number(left)
    sub_f(left, right)
  else
    left.sub(right)

def mult(any left, any right) -> any
  if is_int(left) and is_int(right)
    mult_i(left, right)
  elif is_int(left) or is_number(left)
    mult_f(left, right)
  else
    left.mult(right)

def div(any left, any right) -> any
  if is_int(left) or is_number(left)
    div_f(left, right)
  else
    left.div(right)

def less_than(any a, any b) -> bool
  if is_int(a) and is_int(b)
    less_than_i(a b)
  else
    less_than_f(a b)

def less_than_eq(any a, any b) -> bool
  if is_int(a) and is_int(b)
    less_than_eq_i(a b)
  else
    less_than_eq_f(a b)

def greater_than(any a, any b) -> bool
  if is_int(a) and is_int(b)
    greater_than_i(a b)
  else
    greater_than_f(a b)

def greater_than_eq(any a, any b) -> bool
  if is_int(a) and is_int(b)
    greater_than_eq_i(a b)
  else
    greater_than_eq_f(a b)

def max(any a, any b) -> any
  if is_int(a) and is_int(b)
    max_i(a b)
  else
    max_f(a b)

def min(any a, any b) -> any
  if is_int(a) and is_int(b)
    min_i(a b)
  else
    min_f(a b)

def remainder(any a, any b) -> any
  if is_int(a) and is_int(b)
    remainder_i(a b)
  else
    remainder_f(a b)

def mod(any a, any b) -> any
  if is_int(a) and is_int(b)
    mod_i(a b)
  else
    mod_f(a b)

def neg(any a) -> any
  if is_int(a)
    neg_i(a)
  else
    neg_f(a)

def number.add(left, right) -> number
  add(left, right)
def number.sub(left, right) -> number
  sub(left, right)
def number.mult(left, right) -> number
  mult(left, right)
def number.div(left, right) -> number
  div(left, right)

-- Comparison
def less_than_i(int a,int b) -> bool
def less_than_f(number a,number b) -> bool
def less_than_eq_i(int a,int b) -> bool
def less_than_eq_f(number a,number b) -> bool
def greater_than_i(int a,int b) -> bool
def greater_than_f(number a,number b) -> bool
def greater_than_eq_i(int a,int b) -> bool
def greater_than_eq_f(number a,number b) -> bool

def length(List list) -> int
  -- Return the number of items in the given list

def set_field(any obj, String key, any val) -> any
def set_index(any list, int index, any val) -> List

def static_error(any msg)

def path_dirname(path)
def path_join(paths :multiple)

-- Builtin types
struct Color { number r, number g, number b, number a }
struct Module { String name, any relativeDir }
struct Vec2 { number x, number y }
struct Vec2i { int x, int y }
struct Vec3 { number x, number y, number z }
struct Vec4 { number x, number y, number z, number w }
struct Rect { number x1, number y1, number x2, number y2 }
struct Recti { int x1, int y1, int x2, int y2 }

-- Errors

def syntax_error()
  annotate_block(:hide_from_trace)
  caller = reflect_caller(1)
  error("Syntax error: " caller.property(:Message))

def unknown_identifier()
  annotate_block(:hide_from_trace)
  caller = reflect_caller(1)
  error("Unknown identifier: " caller.name)

def unknown_function(i :multiple)
  annotate_block(:hide_from_trace)
  caller = reflect_caller(1)
  error("Unknown function: " caller.property(:Syntax_FunctionName))

def rpath(String path) -> String
  callerBlock = reflect_caller(1).parent
  dir = callerBlock.source_filename
  path_dirname(@dir)
  path_join(dir path)

def static_type(i) -> Type
  caller = reflect_caller(1)
  input = caller.input(0)
  input.get_type

def term_ref(term :ref) -> Term
  caller = reflect_caller(1)
  caller.input(0)

-- Builtin sequences

-- to_seq is used inside loops, so don't write any loops before this declaration.
def to_seq(val) -> any
  if is_list(val)
    val.to_seq
  else
    val

def List.length(self) -> int
  -- Return the number of elements in this list.

struct ListSeq {
  List list
  int index
}

def ListSeq.key(self) self.index
def ListSeq.done(self) self.index >= self.list.length
def ListSeq.current(self) self.list.get(self.index)
def ListSeq.advance(@self) self.index += 1

def List.to_seq(self)
  ListSeq.make(self 0)

struct ConcatSeq {
  any left
  any right
}

def ConcatSeq.done(self) self.left.done and self.right.done
def ConcatSeq.current(self) self.left.current
def ConcatSeq.key(self) self.left.key
def ConcatSeq.settle(self) cond(self.left.done, self.right, self)

def ConcatSeq.advance(@self)
  @self.left.advance
  @self.settle

def concat_seq(left, right)
  ConcatSeq.make(to_seq(left) to_seq(right)).settle

struct FilterSeq {
  any seq
  Func func
}

def FilterSeq.done(self) self.seq.done
def FilterSeq.current(self) self.seq.current
def FilterSeq.key(self) self.seq.key

def FilterSeq.settle(@self)
  while true
    if self.done
      return self

    if self.func.call(self.seq.current)
      return self

    @self.advance

def FilterSeq.advance(self)
  @self.seq.advance
  self.settle

def filter(seq, func) -> FilterSeq
  FilterSeq.make(to_seq(seq), func).settle

def remove(seq, func) -> FilterSeq
  FilterSeq.make(to_seq(seq) (it) -> not(func.call(it)))

struct MappedSeq {
  any seq
  Func func
}

def MappedSeq.done(self) self.seq.done
def MappedSeq.current(self) self.func.call(self.seq.current)
def MappedSeq.advance(@self) @self.seq.advance
def MappedSeq.key(self) self.seq.key

def map(seq, func) -> MappedSeq
  MappedSeq.make(to_seq(seq) func)

def for_each(seq, func)
  for it in seq
    func(it)

struct UntilSeq {
  any seq
  Func doneFunc
}

def UntilSeq.done(self) self.doneFunc.call(self.seq.current)
def UntilSeq.current(self) self.seq.current
def UntilSeq.advance(@self) @self.seq.advance
def UntilSeq.key(self) self.seq.key

def take_until(s, Func done)
  UntilSeq.make(to_seq(s) done)

struct FuncSeq {
  any current
  any done
  any key
  any private
  Func advanceFunc
}

def FuncSeq.advance(self)
  self.advanceFunc.call(self)

struct Range {
  int from
  int to
  int by
}

def Range.done(self) -> bool
  self.from >= self.to

def Range.current(self)
  self.from

def Range.key(self) -> int
  self.from
 
def Range.advance(@self) -> Range
  self.from += self.by

def range(from, to)
  Range.make(from to 1)

def range_by(from, to, by)
  Range.make(from to by)

def fold(it, func, accum)
  for i in it
    accum = func.call(accum i)
  accum

def flatten(it) -> List
  -- Language defect: Should be able to refer to the function List.append directly.
  def append(List list, item) -> List
    list.append(item)
    
  fold(it append [])

struct GroupingSeq {
  int count
  any seq
  List current
}

def GroupingSeq.settle(@self)
  while self.current.length < self.count and not self.seq.done
    @self.current.append(self.seq.current)
    @self.seq.advance

def GroupingSeq.done(self)
  self.current.length == 0 and self.seq.done

def GroupingSeq.advance(@self)
  set(@self :current [])
  @self.settle

def GroupingSeq.key(self)
  self.seq.key

def take_by(s, int count) -> GroupingSeq
  GroupingSeq.make(count to_seq(s)).settle

{-
def cache_get(key) -> List
def cache_set(key, val)
def cached(func, inputs) -> any
  key = [func inputs]
  existing = cache_get(key)
  if existing.length == 0
    val = func.apply(inputs)
    cache_set(key val)
    val
  else
    existing.get(0)
-}


-- Func
struct Func {
  Block block
  List bindings
}

def Func.call(self, any inputs :multiple) -> any
  -- Call the func using the given inputs.

  -- This function is replaced by special bytecode, however in some situations
  -- (like dynamic methods), we might find ourselves actually calling this
  -- function. So we have another closure call here, and this one will definitely
  -- be compiled with the correct bytecode.
  self.apply(inputs)

def Func.apply(self, List inputs) -> any
  -- Like .call, but the inputs are given as one list instead of separate args.

  -- See note in Func.call:
  self.apply(inputs)

def call(Func func, inputs :multiple) -> any
  func.apply(inputs)

def method_call(location, obj, Symbol name, List args)
  found = method_lookup(location obj name)
  if found.length == 0
    error('Method not found: ' name)
  found.first.call(args)

def method_capture(object, Symbol name) -> List
  if typeof(object) == Module
    found = object._get(name)
    @found.filter(is_func)
    return found
  
  found = method_lookup(nil object name)
  for f in @found
    curry(@f [object])
  found

def method_opt(object, Symbol name, List args, Value default)
  found = method_capture(object name)
  if found.length == 0
    default
  else
    found.first.apply(args)

def closure_block() -> Func
  -- Internally used function for declaring a closure.

def curry(Func func, List frontInputs) -> Func
  def callback(ins :multiple)
    func.apply(frontInputs.concat(ins))
  callback

def update(@obj, keys_and_funcs_or_values :multiple)
  for p in take_by(keys_and_funcs_or_values 2)
    key = p[0]
    val = p[1]

    if is_func(val)
      set(@obj key val.call(get(obj key)))
    else
      set(@obj key val)

def declared_state(existing, Type type, initializer) -> any
  -- Fetch a declared state variable. The 'state' keyword uses this.
  
  if existing != nil
    -- Try to cast to the desired type
    existing = cast(existing, type)

    if existing != nil
      return existing

  -- Cast failed. Try to use the initializer.
  if initializer != nil
    return initializer.call()

  -- No initializer. Use the type's default value.
  return make(type)

def vm_demand_eval_find_existing(Term t) -> List
def vm_demand_eval_store(Term t, any val)

def vm_demand_eval(Term t) -> any
  if t.is_value or t.is_func_decl
    return t.value

  existing = vm_demand_eval_find_existing(t)
  if existing != []
    return existing.first

  inputs = for Term input in t.inputs
    vm_demand_eval(input)

  result = t.function.to_func.apply(inputs)
  vm_demand_eval_store(t result)
  result

-- Misc builtin funcs --

def any_true(list) -> bool
  for i in list
    if not(i)
      return false
  true

def get_with_symbol(any lhs, Symbol symbol) -> any

def first_symbol(any val) -> Symbol
  if typeof(val) == Symbol
    val
  elif typeof(val) == List
    if length(val) > 0
      first_symbol(val[0])

def rand_range(number min, number max) -> number
  min + rand() * (max - min)

def rand_i(int range) -> int
  floor(rand() * range)

def increment(int i) -> int
  i + 1

def decrement(int i) -> int
  i - 1

def make_module(name, relativeTo) -> Module
def Module._get(self, name) -> List
def Module.block(self) -> Block
def Module.resolve(self) -> Block
  self.block
def Module.to_func(self) -> Func
  self.block.to_func
def Module.to_vm(self) -> VM
  self.block.to_vm
def Module.is_local(self) -> bool
  self.relativeDir != nil

def require(String name) -> Module
  m = make_module(name nil)
  require_check(m)
  m

def require_local(String name) -> Module
  annotate_block(:hide_from_trace)
  relativeTo = reflect_caller(1).parent
  m = make_module(name relativeTo)
  require_check(m)
  m

def require_file(String filename) -> Module
  annotate_block(:hide_from_trace)
  m = make_module('' filename)
  require_check(m)
  m

def require_check(Module module)
  annotate_block(:hide_from_trace)

  block = module.resolve
  if block.is_null
    error("Couldn't find ", cond(module.is_local, "local ", "") "module: " module.name)

  if block.has_static_error
    msg = [str("Module '" module.name "' has static errors: ")]
    for error in block.get_static_errors_formatted
      @msg.append(str('  ' error))

    print(msg.join('\n'))

def package(String moduleName)
  -- Declare that the current module is a reusable library with the given name.
  -- (Note: Currently this function does nothing)

-- Test helpers
def test_oracle() -> any
  -- For internal testing. This function will output values that are manually
  -- inserted with the C++ function oracle_send().

def test_spy(any val)
  -- For internal testing. This function will save inputs to a global list which
  -- can be easily examined from C++ with test_spy_get_results().

-- File module
def file_exists(String filename) -> bool
def file_version(String filename) -> int
def file_read_text(String filename) -> String
def file_changed(String filename) -> bool
  ver = file_version(filename)
  changed([filename ver])

-- Sys module
def sys_arg(int index) -> String
def sys_module_search_paths() -> List

def make_blob(int size) -> Blob
def Blob.size(self) -> int
def Blob.slice(self, int offset, int len) -> Blob
def Blob.set_u8(self, int offset, int value)
def Blob.set_u16(self, int offset, int value)
def Blob.set_u32(self, int offset, int value)
def Blob.set_i8(self, int offset, int value)
def Blob.set_i16(self, int offset, int value)
def Blob.set_i32(self, int offset, int value)
def Blob.u8(self, int offset) -> int
def Blob.u16(self, int offset) -> int
def Blob.u32(self, int offset) -> int
def Blob.i8(self, int offset) -> int
def Blob.i16(self, int offset) -> int
def Blob.i32(self, int offset) -> int

def Blob.to_hex_string(self, offset :optional, len :optional) -> String
  if offset == nil
    offset = 0

  if len == nil
    len = self.size

  if len + offset > self.size
    len = self.size - offset

  def to_hex_digit(int i)
    if i >= 0 and i < 10
      String.make.from_char_code('0'.char_code + i)
    else
      String.make.from_char_code('a'.char_code + i - 10)

  result = ""
  for i in range(offset, offset+len)
    byte = self.u8(i)
    @result.append(to_hex_digit(byte // 16))
    @result.append(to_hex_digit(byte % 16))
  result

def Block.dump(self)
  -- Dump this block's raw contents to stdout.
def Block.enclosing_filename(self)
  filename = self.property
def Block.find_term(self, String name) -> Term
  -- Find a term inside this Block with the given name.
def Block.functions(self) -> List
  -- Return a list of functions that occur inside this block.
def Block.get_term(self, int index) -> Term
  -- Fetch a term by index.
def Block.get_static_errors(self) -> List
  -- Return a raw list of static errors inside this block.
  -- TODO
  []
def Block.get_static_errors_formatted(self) -> List
  -- Return a formatted list of static errors inside this block.
  -- TODO
  []
def Block.has_static_error(self) -> bool
  -- Return whether this block has any static errors.
  -- TODO
  false
def Block.id(self) -> int
def Block.input(self, int index) -> Term
  -- Fetch an input placeholder term by index.
def Block.is_major(self) -> bool
def Block.is_null(self) -> bool
  -- Return whether this is a null Block reference.
def Block.inputs(self) -> List
  -- Return a list of input placeholder terms.
def Block.link(self, Block lib)
  -- Iterate through this block, looking for terms that have missing references.
  -- For each missing reference, if a term with the expected name is found in 'lib',
  -- then modify the term to use the named term in 'lib'.
def Block.list_configs(self) -> List
  -- Return a list of Terms that look like configs (named literal values).
def Block.nearest_major(self) -> Block
  if self.is_major
    self
  else
    self.parent.nearest_major
def Block.output(self, int index) -> Term
  -- Return an output term by index.
def Block.outputs(self) -> List
  -- List of output placeholder terms.
def Block.output_placeholder(self, int index) -> Term
  -- Return an output placeholder term by index.
def Block.owner(self) -> Term
  -- Return the Term that owns this Block (may be null).
def Block.parent(self) -> Block
  -- Return the Block that owns this Block (may be null).
def Block.primary_output(self) -> Term
  -- Return the primary output.
  self.output(0)
def Block.find_property(self, Symbol key) -> List
def Block.property(self, Symbol key) -> any
  self.find_property(key).or(nil)
def Block.properties(self) -> Table
def Block.filename(self)
  n = self.find_property(:filename)
  if not n.empty
    n.first
  elif self.parent.is_null
    nil
  else
    self.parent.filename
def Block.source_filename(self) -> String
def Block.statements(self) -> List
  -- Return a list of Terms that are statements.
def Block.terms(self) -> List
  -- Return a list of this block's terms.
def Block.term_named(self, String name) -> Term
def Block.walk_terms(self) -> List
  -- Return a list of this block's terms, and all nested terms.

def Block.to_func(self) -> Func
  Func.make(self)

def Block.to_vm(self) -> VM
  self.to_func.to_vm

def Block.to_vm(self) -> VM
  self.to_func.to_vm

def Block.name(self) -> String
    self.owner.name

def Block.is_method(self) -> bool
  self.owner.property("syntax:methodDecl") == true

def Block.get_top_comments(self) -> List
  out = []
  for Term t in self.terms
    if t.is_input_placeholder
      continue
    elif t.is_comment
      s = t.property('comment')
      if s == ""
        break

      out.append(t.property('comment'))
    else
      break

  out

def Block.call(self, any inputs :multiple) -> any
  -- Invoke this Block with the given inputs.
  self.to_func.apply(inputs)

def Block.if_block_cases(self) -> List
  self.terms.filter((term) -> term.function.name == 'case')

def capture_stack() -> VM
  -- Returns a frozen copy of the currently executing stack.

def VM.apply(self, List inputs) -> any
def VM.block(self) -> Block
  -- Returns the (topmost) block.
def VM.call(self, any inputs :multiple) -> any
def VM.expect_messages(self, key)
def VM.consume_messages(self, key) -> List
def VM.run(self)
  self.call
def VM.copy(self) -> VM
def VM.dump(self)
  -- Dumps a string representation to stdout.
def VM.dump_with_bytecode(self)
def VM.dump_compiled(self)

def VM.get_raw_slots(self) -> List
def VM.get_raw_ops(self) -> Blob
def VM.get_raw_mops(self) -> Blob
def VM.get_func_raw_ops(self, Func func) -> Blob
def VM.get_bytecode_const(self, index) -> any
def VM.precompile(self, Block b)
def bytecode_mop_size() -> int

def VM.rethrow(self)
  -- If the stack has an error, raise it in this context.
  if self.has_error
    error(self.error_message)
def VM.id(self) -> int
def VM.init(self, Func func)
def VM.has_incoming_state(self) -> bool

def VM.env(self, name) -> any
def VM.env_map(self) -> Table
def VM.set_env(self, any name, any val)
def VM.set_env_map(self, Table table)

def VM.init_env(self)
  self.set_env_map(Table.make)

def VM.modify_env(self, Func func)
  new = func.call(self.env_map)
  self.set_env_map(new)

def VM.append_hack(self, any hack)
  self.modify_env((env) -> env.list_append(:hacks hack))

def VM.forward_env(self, names :multiple)
  for name in names
    self.set_env(name env(name))

def VM.get_watch_result(self, key) -> any
def VM.stack_push(self, Block b, List inputs)
  -- Push a new frame, using the given block and input list.
def VM.stack_push2(self, Func func)
  self.stack_push(func.block, [])
def VM.stack_pop(self)
  -- Pop the topmost frame.
def VM.set_state_input(self, any)

def VM.get_state(self) -> any
def VM.set_state(self, any)

def VM.migrate(self, Block from, Block to)
def VM.migrate_to(self, Func func)
  -- Use 'func' as the new root, and migrate data and state.
def VM.reset(self)
def VM.reset_state(self)
  self.set_state(nil)
def VM.restart(self)

def VM.frame_list(self) -> List
def VM.slot(self, index) -> any

def VM.active_value(self, Term term) -> any
  self.top.active_value(term)

def VM.set_active_value(self, Term term, any val)
  self.top.set_active_value(term, val)

def VM.output(self, int index) -> any
  -- Fetch the value in the nth output register.

def VM.errored(self) -> bool
  -- Returns true if the interpreter has stopped due to error.

def VM.has_error(self) -> bool
  self.errored

def VM.error_message(self) -> String
  assert(self.has_error)
  self.slot(0)

def VM.toString(self) -> String

def VM.perf_stats(self) -> Table

def make_vm(Func func) -> VM
  -- Create a new VM

def Func.to_vm(self) -> VM
  make_vm(self)

def repeat(any val, int count) -> List

def int.to_hex_string(val) -> String

def List.append(self, any item) -> List
  -- Append an item to the end of this list.

def List.by_pairs(self) -> List
  out = []
  for i in range(0, self.length // 2)
    @out.append(1)

  if true
    @out.append(2)

  []

def List.clear(self) -> List
  -- Return an empty list.
  []

def List.concat(self, List rightSide) -> List
  -- Concatenate two lists.

def List.contains(self, any val) -> bool
  for i in self
    if i == val
      return true
  return false

def List.resize(self, int length) -> List
  -- Resize the list to have the given length. If the length is increased, then
  -- null values are appended on the right; if the length is decreased then
  -- existing values on the right are dropped.

def List.count(self) -> int
  -- Return the number of elements in this list.

def List.insert(self, int index, any val) -> List
  -- Insert an element at the given index. If necessary, existing elements will
  -- be shifted to the right to make room.
  --
  -- Example:
  --   a = [1 2 3]
  --   a.insert(1, 'X')
  --   -- a now equals [1 'X' 2 3]

def List.prepend(self, any val) -> List
  self.insert(0, val)
    
def List.join(self, String joiner) -> String
  -- Return a string constructed by converting every element to a string, and
  -- concatenating those strings, each separated by 'joiner'.
  --
  -- Example:
  --  [1 2 3].join(', ')
  -- 
  -- Outputs: '1, 2, 3'

def List.or(self, right) -> any
  -- If list is not empty, returns self.first. Otherwise, returns 'right'
  if self.length == 0
    right
  else
    self.first

def List.split(self, boundaryValue) -> List
  out = [[]]
  for item in self
    if item == boundaryValue
      @out.append([])
    else
      @out.modify(out.length - 1, (el) -> el.append(item))
  out

def List.slice(self, int start, int fin) -> List
  -- Return a list constructed from the elements starting from index 'start', and
  -- ending immediately before index 'fin'.
  --
  -- If either 'start' or 'fin' is negative, it's interpreted as an offset from the
  -- end of the list.
  --
  -- Examples:
  --  [1 2 3 4].slice(1 3)
  --  Outputs: [2 3]
  -- 
  --  [1 2 3 4].slice(0 -2)
  --  Outputs: [1 2 3 4]

def List.get(self, int index) -> any
  -- Get an element by index.

def List.get_opt(self, int index, any fallback) -> any
  -- Get an element by index if it exists, otherwise return 'fallback'.
  if index < 0 or index >= self.length
    fallback
  else
    self.get(index)

def List.set(self, int index, any val) -> List
  -- Set an element by index.

def List.remove(self, int index) -> List
  -- Remove an element at the given index, shrinking the list by 1.

def List.modify(self, int index, Func func)
  self.set(index, func.call(self.get(index)))

def List.add(self, any value) -> List
  if is_compound(value)
    for i,el in self { el + value[i] }
  else
    for el in self { el + value }

def List.sub(self, any value) -> List
  if is_compound(value)
    for i,el in self { el - value[i] }
  else
    for el in self { el - value }

def List.mult(self, any value) -> List
  if is_compound(value)
    for i,el in self { el * value[i] }
  else
    for el in self { el * value }

def List.div(self, any value) -> List
  if is_compound(value)
    for i,el in self { el / value[i] }
  else
    for el in self { el / value }

def List.cycle(self, int index) -> any
  -- Get an element by index. If the index is out of bounds, then modulo the
  -- index to one that exists.
  self.get(mod(index, self.length))

def List.empty(self) -> bool
  -- Returns whether the list is empty.
  self.length == 0

def List.first(self) -> any
  -- Returns the first element
  if self.length == 0
    error("Tried to get .first of empty list")
  self.get(0)

def List.last(self) -> any
  -- Returns the last element
  self.get(self.length - 1)

def List.push(self, val) -> List
  self.append(val)

def List.pop(self) -> List
  self.slice(0, -1)

def List.map(self, Func func) -> List
  for el in self
    func(el)

def List.filter(self, Func func) -> List
  result = []
  for i in self
    if func.call(i)
      @result.append(i)
  result

def List.flatten(self) -> List
  -- Take a list of lists, and concat them all into one list.
  out = []
  for el in self
    @out.concat(el)
  out

def List.each(self, Func func) -> List
  for i in self
    func.call(i)

def List.apply(self, int index, Func func) -> List
  self.set(index, func.call(self[index]))

def Table.contains(self, key) -> bool
  -- Returns true if the map contains the given key.

def Table.remove(self, key) -> Table
  -- Removes the given key from the map.

def Table.get(self, key) -> any
  -- Gets the key associated with this value.

def Table.get_opt(self, key, default) -> any
  if self.contains(key)
    self.get(key)
  else
    default

def Table.get_and_call(self, key, args :multiple)
  val = self.get(key)
  val.apply(args)

def Table.find(self, key) -> List
  if self.contains(key)
    [self.get(key)]
  else
    []
    
def Table.set(self, any key, any value) -> Table
  -- Sets the value associated with this key.

def Table.empty(self) -> bool
  -- Whether the map has no values

def Table.apply(self, any key, Func func) -> Table
  self.set(key, func.call(self.get(key)))

def Table.modify(self, any key, Func func) -> Table
  self.set(key, func.call(self.get(key)))

def Table.list_append(self, any key, any value) -> Table
  if self.contains(key)
    self.modify(key, (l) -> l.append(value))
  else
    self.set(key, [value])

def Table.bucketize(self, List list, Func getKey) -> Table
  for el in list
    @self.list_append(getKey.call(el), el)

  -- language defect, shouldn't be required:
  self

def Table.keys(self) -> List

struct Set {
  Table m
}

def Set.add(self, element) -> Set
  @self.m.set(element, true)

def Set.contains(self, element) -> bool
  self.m.contains(element)

def Set.remove(self, element) -> Set
  @self.m.remove(element)

def Set.elements(self) -> List
  self.m.keys

def List.to_set(self) -> Set
  set = make(Set)
  for item in self
    @set.add(item)
  set

def String.append(self, String right) -> String
  -- Append a string to the right side.
  str(self right)

def String.prepend(self, String left) -> String
  str(left self)
    
def String.char_at(self, int index) -> String
  -- Get character at a given index. UTF unsafe.

def String.index_of(self, String substr) -> any
  for i in 0..self.length
    if self.substr(i, substr.length) == substr
      return i
  return nil

def String.ends_with(self, String suffix) -> bool
  -- Return true if this string ends with the given substring.

def String.char_code(self) -> int
def String.from_char_code(self, int code) -> String

def String.length(self) -> int
  -- Returns the string length.

def String.slice(self, int start, int fin) -> String

def String.starts_with(self, String prefix) -> bool
  -- Returns true if the string starts with the given prefix.

def String.split(self, String sep) -> List

def String.substr(self, int start, int length) -> String

def String.to_camel_case(self) -> String
  -- Deprecated function

def String.to_lower(self) -> String

def String.to_upper(self) -> String

def String.to_number(self) -> number
def String.to_int(self) -> int

def String.characters(self) -> List
    out = for i in 0..(self.length)
        self.char_at(i)
    return out

-- Type
def Type.declaringTerm(self) -> Term
        
def Type.make(self, any values :multiple) -> any
def Type.name(self) -> String
def Type.property(self, String name) -> any
def Type.includes(self, value) -> bool
  result = cast(value self)
  result != nil

def Type.cast(self, any value) -> any
  result = cast(value, self)
  if result == nil
    error(str("Couldn't cast value " value " to type " self.name))
  result

def Term.assign(self, any val)
def Term.asint(self) -> int
def Term.asfloat(self) -> number
def Term.index(self) -> int
def Term.contents(self) -> Block
    -- Fetch the nested Block contents of this Term. The format and the meaning
    -- of these contents is dictated by the term's function.
def Term.is_input(self) -> bool
def Term.is_null(self) -> bool
    -- Returns whether this is a null Term reference.
def Term.is_output(self) -> bool
def Term.name(self) -> String
    -- Return this term's local name. May be blank.
def Term.parent(self) -> Block
def Term.to_string(self) -> String
def Term.unique_name(self) -> any
def Term.function(self) -> Block
    -- Fetch this term's function.
def Term.get_type(self) -> Type
    -- Fetch the declared type of this term.
def Term.id(self) -> int
def Term.value(self) -> any
    -- Static value
def Term.set_value(self, any val)
    -- For a value term, permanently change the value.
def Term.input(self, int index) -> Term
    -- Fetch an input term by index.
def Term.inputs(self) -> List
    -- Return a list of input terms.
def Term.num_inputs(self) -> int
    -- Return the number of inputs.
def Term.source_location(self) -> Recti
    -- Return a Recti that describes where this term occurs in its source file.
def Term.location_string(self) -> String
def Term.global_id(self) -> int
    -- Fetch this term's global identifier.

def Term.properties(self) -> Table

def Term.has_property(self, Symbol key) -> bool
def Term.property(self, Symbol key) -> any
    -- Fetch a term property.
def Term.property_opt(self, Symbol key, default) -> any
    -- Fetch an optional term property.

def Term.input_property(self, int index, Symbol key) -> any
def Term.input_property_opt(self, int index, Symbol key, any default) -> any
def Term.has_input_property(self, int index, Symbol key) -> bool

def Term.is_value(self) -> bool
def Term.is_function(self) -> bool
    self.get_type == Func
def Term.is_func_decl(self) -> bool
    self.function == function_decl.block
def Term.has_name(term) -> bool
  term.name != ''
def Term.is_hidden(term) -> bool
  term.property_opt(:hidden, false)
def Term.is_statement(term) -> bool
  term.property_opt(:statement, false)
def Term.is_type(self) -> bool
    self.is_value and is_type(self.value)
def Term.is_input_placeholder(self) -> bool
    self.function == input_placeholder.block
def Term.is_comment(self) -> bool
    self.function == comment.block
def Term.trace_dependents(self, Block untilBlock) -> List
def Term.extra_output(self, int index)
  self.parent.get_term(self.index + index + 1)
def Term.output(self, int index) -> Term
  if index == 0
    self
  else
    self.extra_output(index - 1)

def vec2(number x, number y)
  Vec2.make(x y)

def Vec2.add(self, rhs) -> Vec2
  rvec = cast(rhs, Vec2)
  if rvec != nil
    [self.x + rvec.x, self.y + rvec.y]
  else
    [self.x + rhs, self.y + rhs]

def Vec2.sub(self, rhs) -> Vec2
  rvec = cast(rhs, Vec2)
  if rvec != nil
    [self.x - rvec.x, self.y - rvec.y]
  else
    [self.x - rhs, self.y - rhs]

def Vec2.mult(self, rhs) -> Vec2
  rvec = cast(rhs, Vec2)
  if rvec != nil
    [self.x * rvec.x, self.y * rvec.y]
  else
    [self.x * rhs, self.y * rhs]

def Vec2.div(self, rhs) -> Vec2
  rvec = cast(rhs, Vec2)
  if rvec != nil
    [self.x / rvec.x, self.y / rvec.y]
  else
    [self.x / rhs, self.y / rhs]
    
def Vec2.distance(self, Vec2 b) -> number
  -- Returns the distance between self and b.
  sqrt(sqr(self.x - b.x) + sqr(self.y - b.y))

def Vec2.distance_sqr(self, Vec2 b) -> number
  sqr(self.x - b.x) + sqr(self.y - b.y)

def Vec2.magnitude(self) -> number
  -- Return the magnitude of this point, aka the distance to the origin.
  sqrt(sqr(self.x) + sqr(self.y))

def Vec2.magnitude_sqr(self) -> number
  sqr(self.x) + sqr(self.y)

def Vec2.norm(self) -> Vec2
  -- Returns the point normalized to be along the unit circle.
  m = self.magnitude
  [self.x / m, self.y / m]

def Vec2.perpendicular(self) -> Vec2
  -- Returns a perpendicular vector, rotated clockwise.
  [self.y -self.x]

def Vec2.translate(self, Vec2 b) -> Vec2
  [self.x + b.x, self.y + b.y]

def Vec2.to_rect(self, Symbol anchor, Vec2 size) -> Rect
  switch anchor
    case :center
      Rect.make.from_size(self - size * .5, size)
    case :topleft
      Rect.make.from_size(self, size)

def Vec2.to_rect_center(self, Vec2 size) -> Rect
  -- Returns a Rect with this point as the center, and the given size.
  size_half = (size * 0.5) -> Vec2.cast
  [self.x - size_half.x,
      self.y - size_half.y, self.x + size_half.x, self.y + size_half.y]

def Vec2.to_rect_topleft(self, Vec2 size) -> Rect
  -- Returns a Rect with this point as the top-left, and the given size.
  [self.x, self.y, self.x + size.x, self.y + size.y]

def Vec2.delta(self) -> Vec2
  -- Stateful function, returns the point difference since the last step.
  state Vec2 prev = self
  result = [self.x - prev.x, self.y - prev.y]
  prev = self
  result

def Vec2.rotate(self, number rotation) -> Vec2
  -- Return the point rotated around [0 0] by the given angle.
  [self.x*cos(rotation) - self.y*sin(rotation), self.x*sin(rotation)+self.y*cos(rotation)]

def Vec2.limit(self, number max_magnitude) -> Vec2
  m = self.magnitude
  if m > max_magnitude
    self.mult(max_magnitude / m)
  else
    self

def Vec2.rand(self) -> Vec2
  angle = rand() * 360
  [cos(angle) sin(angle)]

def vec3(number x, number y, number z)
  Vec3.make(x y z)
def Vec3.add(self, Vec3 b) -> Vec3
  [self.x + b.x, self.y + b.y, self.z + b.z]
def Vec3.sub(self, Vec3 b) -> Vec3
  [self.x - b.x, self.y - b.y, self.z - b.z]
def Vec3.mult(self, number s) -> Vec3
  [self.x * s, self.y * s, self.z * s]
def Vec3.div(self, number s) -> Vec3
  [self.x / s, self.y / s, self.z / s]

def vec4(number x, number y, number z, number w)
  Vec4.make(x y z w)

def Rect.from_size(self, Vec2 topleft, Vec2 size) -> Rect
  [topleft.x, topleft.y, topleft.x + size.x, topleft.y + size.y]
  
def Rect.add(self, Rect b) -> Rect
  [self.x1 + b.x1, self.y1 + b.y1, self.x2 + b.x2, self.y2 + b.y2]
def Rect.sub(self, Rect b) -> Rect
  [self.x1 - b.x1, self.y1 - b.y1, self.x2 - b.x2, self.y2 - b.y2]
def Rect.mult(self, number s) -> Rect
  [self.x1 * s, self.y1 * s, self.x2 * s, self.y2 * s]
def Rect.div(self, number s) -> Rect
  [self.x1 / s, self.y1 / s, self.x2 / s, self.y2 / s]

def Rect.width(self) -> number
  self.x2 - self.x1
def Rect.height(self) -> number
  self.y2 - self.y1
def Rect.size(self) -> Vec2
  [self.width self.height]
def Rect.left(self) -> number
  self.x1
def Rect.top(self) -> number
  self.y1
def Rect.right(self) -> number
  self.x2
def Rect.bottom(self) -> number
  self.y2
def Rect.top_left(self) -> Vec2
  -- Returns the top-left coordinates as a Vec2.
  [self.x1 self.y1]
def Rect.top_right(self) -> Vec2
  -- Returns the top-rigth coordinates as a Vec2.
  [self.x2 self.y1]
def Rect.bottom_left(self) -> Vec2
  -- Returns the bottom-left coordinates as a Vec2.
  [self.x1 self.y2]
def Rect.bottom_center(self) -> Vec2
  [(self.x1+self.x2)/2, self.y2]
def Rect.bottom_right(self) -> Vec2
  -- Returns the bottom-right coordinates as a Vec2.
  [self.x2 self.y2]
def Rect.center(self) -> Vec2
  -- Returns the rectangle's center as a Vec2
  [(self.x1 + self.x2) / 2, (self.y1 + self.y2) / 2]
def Rect.points_cw(self) -> List
  [self.top_left self.top_right self.bottom_right self.bottom_left]
def Rect.points_ccw(self) -> List
  [self.top_left self.bottom_left self.bottom_right self.top_right]

def Rect.intersects(self, Rect b) -> bool
  -- Return whether the two rectangles intersect.
  intersects_on_x = (self.x2 > b.x1) and (b.x2 > self.x1)
  intersects_on_y = (self.y2 > b.y1) and (b.y2 > self.y1)
  intersects_on_x and intersects_on_y

def Rect.translate(self, Vec2 p) -> Rect
  [self.x1 + p.x, self.y1 + p.y, self.x2 + p.x, self.y2 + p.y]

def Rect.contains(self, Vec2 p) -> bool
  p.x >= self.x1 and p.y >= self.y1 and p.x < self.x2 and p.y < self.y2

def Rect.grow(self, Vec2 size) -> Rect
  [self.x1 - size.x, self.y1 - size.y, self.x2 + size.x, self.y2 + size.y]

def Rect.grow_s(self, number size) -> Rect
  [self.x1 - size, self.y1 - size, self.x2 + size, self.y2 + size]

def Rect.subtractFrom(self, Symbol side, number dimension) -> List
  if side == :top
    min(@dimension, self.height)
    out = self.set_y2(dimension)
    self.y1 += dimension
    return [self, out]
  if side == :left
    min(@dimension, self.width)
    out = self.set_x2(self.x1 + dimension)
    self.x1 += dimension
    return [self, out]
  if side == :right
    min(@dimension, self.width)
    out = self.set_x1(self.x2 - dimension)
    self.x2 -= dimension
    return [self, out]
  if side == :bottom
    min(@dimension, self.height)
    out = self.set_y1(self.y2 - dimension)
    self.y2 -= dimension
    return [self, out]
  error(str('Unrecognized side: ' side))

def sum(numbersSeq)
  result = 0
  for i in numbersSeq
    result += i
  result
    
def zip(List left, List right) -> List
  for i,l in left
    [l, right.get_opt(i, nil)]

-- Stateful functions

def changed(any val) -> bool
  -- Stateful function; returns true if the value has changed since the
  -- previous step.
  state any prev
  result = prev != val
  prev = val
  result

def cached(Func refresh)
  state out
  if changed([refresh global_script_version()])
    out = refresh.call()
  out

def delta(number val) -> number
  -- Stateful function, return the difference between this value and the value from
  -- the previous call.
  state number prev = val
  result = val - prev
  prev = val
  result

def toggle(bool tog) -> bool
  -- Stateful function, returns a boolean status. Every frame the function is called
  -- with (true), the result flips. Starts out false.

  state bool s = false
  if tog
    s = not(s)
  s

def approach(number target, number maximum_change) -> number
  -- Stateful function, returns a result which approaches 'target'. Each time the
  -- function is called, the result will change at most by 'maximum_change'.
  state current = target
  if target > current
    current += min(maximum_change, target - current)
  elif target < current
    current -= min(maximum_change, current - target)
  current

def once() -> bool
  -- Stateful function, returns true the first time it's called, and false thereafter.
  state bool s = true
  result = s
  s = false
  result

def cycle(int max) -> int
  -- Stateful function, cycles though the integers from 0 to (max - 1). When the
  -- maximum is reached, the function will start again at 0.

  state int counter = 0
  if counter >= max
    counter = 0
  result = counter
  counter += 1
  result

def cycle_elements(List list) -> any
  -- Stateful function, cycles through each item of 'list' one at a time.
  list[cycle(length(list))]

def random_element(List list) -> any
  -- Return a random element from the given list, with equal probability per element.
  list[rand_i(length(list))]

def seed() -> number
  -- Stateful function, returns a random number 0..1 which doesn't change after
  -- initialization.
  state number s = rand()
  s

-- Math utility functions
def polar(number angle) -> Vec2
  -- Return a point on the unit circle with the given angle.
  [cos(angle) sin(angle)]

def rect(number x1, number y1, number x2, number y2) -> Rect
  [x1 y1 x2 y2]

def bezier3(number t, List points) -> Vec2
  -- Quadratic bezier curve, with 3 control points. t must be in the range of [0, 1].
  p0 = points[0] -> Vec2.cast
  p1 = points[1] -> Vec2.cast
  p2 = points[2] -> Vec2.cast
  (p0 * sqr(1 - t) + p1 * (2 * t * (1 - t)) + p2 * sqr(t))

def bezier4(number t, List points) -> Vec2
  -- Cubic bezier curve, with 4 control points. t must be in the range of [0, 1].
  p0 = points[0] -> Vec2.cast
  p1 = points[1] -> Vec2.cast
  p2 = points[2] -> Vec2.cast
  p3 = points[3] -> Vec2.cast
  (p0 * cube(1 - t) + p1 * (3 * t * sqr(1 - t)) + p2 * sqr(t) * (3 * (1 - t)) + p3 * cube(t))

def smooth_in_out(number t, number smooth_in, number smooth_out) -> number
  bezier4(t, [[0 0] [smooth_in, 0] [1 - smooth_out, 1] [1 1]]).y

def clamp(number x, number minVal, number maxVal) -> number
  -- Return a clamped value. If x is less than 'minVal' then return 'minVal', if it's
  -- greater than 'maxVal' then return 'maxVal', otherwise return the original 'x'.
  min(max(x, minVal), maxVal)

def smoothstep(number x, number edge0, number edge1) -> number
  -- Smooth interpolation func, see en.wikipedia.org/wiki/Smoothstep
  x = clamp((x - edge0)/(edge1-edge0), 0, 1)
  x*x*(3 - 2*x)

def smootherstep(number x, number edge0, number edge1) -> number
  -- Alternative to smoothstep by Ken Perlin, see en.wikipedia.org/wiki/Smoothstep
  x = clamp((x - edge0)/(edge1-edge0), 0, 1)
  x*x*x*(x*(x*6 - 15) + 10)

def random_color() -> Color
  -- Return a color with random RGB components.
  [rand() rand() rand() 1.0]

def hsv_to_rgb(List hsv) -> Color
  -- Convert HSV components to an RGB Color

  h = hsv[0] -> number.cast
  s = hsv[1] -> number.cast
  v = hsv[2] -> number.cast

  if s == 0
      -- grey
      return [v v v 1]

  h *= 6
  i = floor(h)
  f = h - i
  p = v * (1 - s)
  q = v * (1 - s * f)
  t = v * (1 - s * (1 - f))

  if i == 0
    [v t p 1]
  elif i == 1
    [q v p 1]
  elif i == 2
    [p v t 1]
  elif i == 3
    [p q v 1]
  elif i == 4
    [t p v 1]
  elif i == 5
    [v p q 1]
  else
    [0 0 0 0]

def hsl_color(number h, number s, number l) -> Color
  if s == 0
    [1 1 1 1]
  else
    def hue_to_rgb(number p, number q, number t)
      mod(@t 1)
      if t < 1/6
        p + (q - p) * 6 * t
      elif t < 1/2
        q
      elif t < 2/3
        p + (q - p) * (2/3 - t) * 6
      else
        p

    q = if l < 0.5
      l * (1 + s)
    else
      l + s - l * s

    p = 2 * l - q
    r = hue_to_rgb(p, q, h + 1/3)
    g = hue_to_rgb(p, q, h)
    b = hue_to_rgb(p, q, h - 1/3)
    [r g b 1]

def Color.add(self, any value) -> Color
  for i in self { i + value }
def Color.sub(self, any value) -> Color
  for i in self { i - value }
def Color.mult(self, any value) -> Color
  for i in self { i * value }
def Color.div(self, any value) -> Color
  for i in self { i / value }

def Color.blend(self, Color rhs, number ratio) -> Color
  -- Return a color that is blended between self and rhs. If ratio is 0.0 we'll
  -- return 'self', if it's 1.0 we'll return 'rhs'.

  max(@ratio, 0.0)
  min(@ratio, 1.0)

  if ratio == 0.0
    self
  elif ratio == 1.0
    rhs
  else
    self + (rhs - self) * ratio

def Color.lighten(self, number factor) -> Color
  -- Linearly lighten each component of the color.
  [ min(self.r + factor, 1.0)
    min(self.g + factor, 1.0)
    min(self.b + factor, 1.0)
    self.a]
        
def Color.darken(self, number factor) -> Color
  -- Linearly darken each component of the color.
  [ max(self.r - factor, 0.0)
    max(self.g - factor, 0.0)
    max(self.b - factor, 0.0)
    self.a]

def weighted_rand(List choices :multiple) -> any
  total = 0
  for choice in choices
    weight = choice[0]
    total += weight

  r = rand() * total
  for choice in choices
    r -= choice[0]
    if r < 0
      return choice[1]

  return nil

def rand_gaussian()
  -- Box-Muller transform
  rand1 = -2 * log(rand())
  rand2 = (rand()) * 360
  sqrt(rand1) * cos(rand2)

def number.map(x, Vec2 fromRange, Vec2 toRange)
  ratio = (x - fromRange[0]) / (fromRange[1] - fromRange[0])
  (toRange[0] + ratio * (toRange[1] - toRange[0]))

def int.map(x, Vec2 fromRange, Vec2 toRange)
  ratio = (x - fromRange[0]) / (fromRange[1] - fromRange[0])
  (toRange[0] + ratio * (toRange[1] - toRange[0]))

def noise(number x)
  -- Perlin noise
