
-- Parse errors
def unknown_function(any ins :multiple)
def unknown_identifier()

-- Misc builtins
def declare_field()
def return(any outs :multiple :optional)
def discard(any outs :multiple :optional)
def dynamic_method(any inputs :multiple)
def break(any outs :multiple :optional)
def continue(any outs :multiple :optional)
def extra_output(any _) -> any
def func_call_implicit(any inputs :multiple)
def get_field(any obj, String key) -> any
def get_index(List list, int index) -> any
def selector(any elements :multiple) -> Selector
def get_with_selector(any object, Selector selector) -> any
def set_with_selector(any object, Selector selector, any newValue) -> any
def syntax_error(msg :multiple)
def section()
def case_condition_bool(bool condition)
def loop_condition_bool(bool condition)
def minor_return_if_empty()

-- While-block
def while()

-- For-block
def for(List list) -> List
def loop_index() -> int
def loop_get_element(list, int index)
def loop_output_index() -> any

-- If-block
def if() -> any
def case(bool b :optional)

-- Switch-block
def switch(any input :optional) -> any

-- Explicit input/output (future questionable)
def output(any _)

-- List values
def list(any vals :multiple) -> List
def blank_list(int count) -> List

-- Logical
def and(bool a, bool b) -> bool
  -- Return whether a and b are both true
def or(bool a, bool b) -> bool
  -- Return whether a or b are both true
def not(bool b) -> bool

-- Map values
def map(any vals :multiple) -> Map

-- Math
def add_i(int a, int b) -> int
def add_f(number a, number b) -> number
def max_f(number a,number b) -> number
  -- Maximum of two numbers
def max_i(int a,int b) -> int
  -- Maximum of two integers
def min_f(number a,number b) -> number
  -- Minimum of two numbers
def min_i(int a,int b) -> int
  -- Minimum of two integers
def remainder_i(int a,int b) -> int
def remainder_f(number a,number b) -> number
def mult_i(int a,int b) -> int
def mult_f(number a,number b) -> number
def mod_i(int a,int b) -> int
def mod_f(number a,number b) -> number
def neg_i(int i) -> int
def neg_f(number n) -> number
def sub_i(int a,int b) -> int
def sub_f(number a,number b) -> number
def round(number n) -> int
  -- Return the integer that is closest to n
def floor(number n) -> int
  -- Return the closest integer that is less than n
def ceil(number n) -> int
  -- Return the closest integer that is greater than n
def average(vals :multiple) -> number
  -- Returns the average of all inputs
def pow(number i, number x) -> number
  -- Returns i to the power of x
def sqr(number n) -> number
  -- Square function
def cube(number n) -> number
  -- Cube function
def sqrt(number n) -> number
  -- Square root
def log(number n) -> number
  -- Natural log function

-- Trig
def sin(number degrees) -> number
  -- Trigonometric sin() function
def cos(number degrees) -> number
  -- Trigonometric cos() function
def tan(number degrees) -> number
  -- Trigonometric tan() function
def arcsin(number n) -> number
  -- Trigonometric arcsin() function
def arccos(number n) -> number
  -- Trigonometric arccos() function
def arctan(number n) -> number
  -- Trigonometric arctan() function

-- Secret functions used by interpreter
def _get_local_state() -> any
  -- Special call, read this frame's state.
def _get_local_stack_path() -> any
def _find_active_value(term) -> (any, bool)
def _save_state_result(Term declaredStateTerm, any result)
def _get_demand_value(Term t) -> (bool, any)
def _store_demand_value(Term t, any val)
def _extract_stack_path() -> List
def dbg_get_incoming_state() -> any
def dbg_get_outgoing_state() -> any
def dbg_set_incoming_state(val)
def dbg_set_outgoing_state(val)

-- Type checking
def is_compound(n) -> bool
def is_list(n) -> bool
def is_map(n) -> bool
def is_int(n) -> bool
def is_number(n) -> bool
def is_bool(n) -> bool
def is_string(n) -> bool
def is_null(n) -> bool
def is_function(n) -> bool
def is_type(n) -> bool

def is_scalar(n) -> bool
  is_int(n) or is_number(n)

-- Overloaded math funcs
def add(any left, any right) -> any
  if is_int(left) and is_int(right)
    add_i(left, right)
  elif is_int(left) or is_number(left)
    add_f(left, right)
  else
    left.add(right)

def sub(any left, any right) -> any
  if is_int(left) and is_int(right)
    sub_i(left, right)
  elif is_int(left) or is_number(left)
    sub_f(left, right)
  else
    left.sub(right)

def mult(any left, any right) -> any
  if is_int(left) and is_int(right)
    mult_i(left, right)
  elif is_int(left) or is_number(left)
    mult_f(left, right)
  else
    left.mult(right)

def div(any left, any right) -> any
  if is_int(left) or is_number(left)
    div_f(left, right)
  else
    left.div(right)

def less_than(any a, any b) -> bool
  if is_int(a) and is_int(b)
    less_than_i(a b)
  else
    less_than_f(a b)

def less_than_eq(any a, any b) -> bool
  if is_int(a) and is_int(b)
    less_than_eq_i(a b)
  else
    less_than_eq_f(a b)

def greater_than(any a, any b) -> bool
  if is_int(a) and is_int(b)
    greater_than_i(a b)
  else
    greater_than_f(a b)

def greater_than_eq(any a, any b) -> bool
  if is_int(a) and is_int(b)
    greater_than_eq_i(a b)
  else
    greater_than_eq_f(a b)

def max(any a, any b) -> any
  if is_int(a) and is_int(b)
    max_i(a b)
  else
    max_f(a b)

def min(any a, any b) -> any
  if is_int(a) and is_int(b)
    min_i(a b)
  else
    min_f(a b)

def remainder(any a, any b) -> any
  if is_int(a) and is_int(b)
    remainder_i(a b)
  else
    remainder_f(a b)

def mod(any a, any b) -> any
  if is_int(a) and is_int(b)
    mod_i(a b)
  else
    mod_f(a b)

def neg(any a) -> any
  if is_int(a)
    neg_i(a)
  else
    neg_f(a)

def number.add(left, right) -> number
  add(left, right)
def number.sub(left, right) -> number
  sub(left, right)
def number.mult(left, right) -> number
  mult(left, right)
def number.div(left, right) -> number
  div(left, right)

def rand() -> number

def copy(any val) -> any

def cast_declared_type(any val) -> any
def cast(any val, Type t) -> (any, bool)

def cond(bool condition, any pos, any neg) -> any
  -- If 'condition' is true, returns 'pos'. Otherwise returns 'neg'.

def str(any vals :multiple) -> String
  -- Convert inputs to a string and concatenate the result

def copy(any val) -> any

def convert(any value, Type t) -> any
  -- Convert the value to the given type, if possible.

def compute_patch(existing, new) -> any
  -- Compute a patch, which when applied to 'existing' will equal 'new'

def div_f(number a,number b) -> number
def div_i(number a,number b) -> int

def apply_patch(existing, patch) -> any
  -- Apply a patch

def assert(bool condition)
  -- Raises an error if 'condition' is false.

def equals(any a,any b) -> bool

def from_string(String s) -> any
  -- Parse a string representation to a Circa value

def error(any msg :multiple)


-- Comparison
def less_than_i(int a,int b) -> bool
def less_than_f(number a,number b) -> bool
def less_than_eq_i(int a,int b) -> bool
def less_than_eq_f(number a,number b) -> bool
def greater_than_i(int a,int b) -> bool
def greater_than_f(number a,number b) -> bool
def greater_than_eq_i(int a,int b) -> bool
def greater_than_eq_f(number a,number b) -> bool

def length(List list) -> int
  -- Return the number of items in the given list

def make(Type t) -> any

def range(int start, int max) -> List
  -- Return a list of integers from start to max-1

def rpath(String path) -> String

def set_field(any obj, String key, any val) -> any
def set_index(any list, int index, any val) -> List

def static_error(any msg)

def not_equals(any a,any b) -> bool

def print(any items :multiple)
  -- Prints a line of text output to the console.

def get(Map val, List path) -> any
def set(Map val, List path, any newValue) -> any
def delete(Map val, List path) -> Map

def trace(any items :multiple)

def to_string(any val) -> String

def to_string_repr(any val) -> String
  -- Encode a Circa value as a string representation.

def type(any val) -> Type
  -- Returns the runtime type of a value.

def static_type(any term :meta) -> Type
  -- Returns the static type of a value.

def env(any name) -> any
  -- Fetch the env variable in the current scope with the given name.

def env_opt(any name, any default) -> any
  -- Like env(), but if the value doesn't exist then 'default' is used.

def set_env(any name, any value)
  -- Set an env var in the current scope.

def has_effects()
  -- Annotation, declare that a function has effects. Used in native-patched
  -- functions. Not fully supported yet.

def native_patch(String filename)
  -- Declare that this block should be patched by a native module.

def memoize()
  -- Instruct the VM to memoize the current frame.

def write_text_file(String filename, String contents)
  -- Write contents to the given filename, overwriting any existing file. (future questionable)


def inputs_fit_function(List inputs,Func func) -> bool
def overload_error_no_match(List inputs)
def unique_id() -> int
def source_id() -> any

-- Channels
def channel_send(Symbol name, any val)
def channel_read(Symbol name) -> List

def global_script_version() -> int

-- Func
struct Func {
  Block block
  Map bindings
}

def Func.call(self, any inputs :multiple) -> any
  -- Call the func using the given inputs.

  -- This function is replaced by special bytecode, however in some situations
  -- (like dynamic methods), we might find ourselves actually calling this
  -- function. So we have another closure call here, and this one will definitely
  -- be compiled with the correct bytecode.
  self.apply(inputs)

def Func.apply(self, List inputs) -> any
  -- Like .call, but the inputs are given as one list instead of separate args.

  -- See note in Func.call:
  self.apply(inputs)

def call(Func func, inputs :multiple) -> any
  func.apply(inputs)

def closure_block() -> Func
  -- Internally used function for declaring a closure.

-- Secret internally-used funcs

def _nonlocal(term :ref) -> any
  value, found = _find_active_value(term)
  if found
    value
  else
    _eval_on_demand(term)

def _declared_state(Type t, Func initializer :optional) -> any
  -- Internally used function for fetching a stateful value. The parser
  -- adds a call to this function whereever the 'state' keyword is used.

  existing = _get_local_state()

  if existing != null
    -- Try to cast to the desired type
    existing, cast_success = cast(existing, t)

    if cast_success
      return existing

  -- Cast failed. Try to use the initializer.
  if initializer != null
    return initializer.call()

  -- No initializer. Use the type's default value.
  return make(t)

def _dynamic_term_eval(Term t, List inputs) -> any
  t.function.to_func.apply(inputs)

def _eval_on_demand(Term t) -> any
  -- Internal function, used when a nonlocal() term needs a value.
  if t.is_value or t.is_func_decl
    return t.value

  found, val = _get_demand_value(t)
  if found
    return val

  inputs = for Term input in t.inputs
    _eval_on_demand(input)

  result = _dynamic_term_eval(t inputs)
  _store_demand_value(t result)
  result

-- Misc builtin funcs --

def abs(number n) -> number
  -- Absolute value
def any_true(list) -> bool
  for i in list
    if not(i)
      return false
  true

def get_with_symbol(any lhs, Symbol symbol) -> any

def first_symbol(any val) -> Symbol
  if type(val) == Symbol
    val
  elif type(val) == List
    if length(val) > 0
      first_symbol(val[0])

def rand_range(number min, number max) -> number
  min + rand() * (max - min)
def rand_i(int range) -> int
  floor(rand() * range)

def swap(a, b) -> (any, any)
  return b, a

def increment(int i) -> int
  i + 1

def decrement(int i) -> int
  i - 1

-- Builtin types
struct FileSignature { String filename, int time_modified }
struct Callable;
struct Color { number r, number g, number b, number a }
struct Module { String name, Block relativeTo }
struct Stack;
struct Vec2 { number x, number y }
struct Vec2i { int x, int y }
struct Vec3 { number x, number y, number z }
struct Vec4 { number x, number y, number z, number w }
struct Rect { number x1, number y1, number x2, number y2 }
struct Rect_i { int x1, int y1, int x2, int y2 }

def Module._get(self, name)
def Module.block(self) -> Block
def Module.resolve(self) -> Block
  self.block
def Module.to_func(self) -> Func
  self.block.to_func
def Module.to_stack(self) -> Stack
  self.block.to_stack

def load_script(String filename) -> Block
  -- Load a script file with the given filename.

def require(String name) -> Module
  -- Load a module.

def require_check(Module module)
  block = module.resolve
  if block.has_static_error
    msg = [str("Module '" module.name "' has static errors: ")]
    for error in block.get_static_errors_formatted
      @msg.append(str('  ' error))

    print(msg.join('\n'))

def package(String moduleName)
  -- Declare that the current module is a reusable library with the given name.
  -- (Note: Currently this function does nothing)

-- Test helpers
def test_oracle() -> any
  -- For internal testing. This function will output values that are manually
  -- inserted with the C++ function oracle_send().

def test_spy(any val)
  -- For internal testing. This function will save inputs to a global list which
  -- can be easily examined from C++ with test_spy_get_results().

-- File module
def file_exists(String filename) -> bool
def file_version(String filename) -> int
def file_read_text(String filename) -> String
def file_changed(String filename) -> bool
  ver = file_version(filename)
  changed([filename ver])

-- Reflect module
def reflect_this_block() -> Block
def reflect_caller() -> Term
def reflect_kernel() -> Block

-- Sys module
def sys_arg(int index) -> String
def sys_module_search_paths() -> List
def _perf_stats_dump() -> Map


def make_blob(int size) -> Blob
def Blob.size(self) -> int
def Blob.slice(self, int offset, int len) -> Blob
def Blob.set_u8(self, int offset, int value)
def Blob.set_u16(self, int offset, int value)
def Blob.set_u32(self, int offset, int value)
def Blob.set_i8(self, int offset, int value)
def Blob.set_i16(self, int offset, int value)
def Blob.set_i32(self, int offset, int value)
def Blob.u8(self, int offset) -> int
def Blob.u16(self, int offset) -> int
def Blob.u32(self, int offset) -> int
def Blob.i8(self, int offset) -> int
def Blob.i16(self, int offset) -> int
def Blob.i32(self, int offset) -> int

def Blob.to_hex_string(self, int offset, int len) -> String
  def to_hex_digit(int i)
    if i >= 0 and i < 10
      String.make.from_char_code('0'.char_code + i)
    else
      String.make.from_char_code('a'.char_code + i - 10)

  result = ""
  for i in offset..(offset+len)
    byte = self.u8(i)
    @result.append(to_hex_digit(byte // 16))
    @result.append(to_hex_digit(byte % 16))
  result

def Block.dump(self)
  -- Dump this block's raw contents to stdout.
def Block.find_term(self, String name) -> Term
  -- Find a term inside this Block with the given name.
def Block.functions(self) -> List
  -- Return a list of functions that occur inside this block.
def Block.get_term(self, int index) -> Term
  -- Fetch a term by index.
def Block.get_static_errors(self) -> List
  -- Return a raw list of static errors inside this block.
def Block.get_static_errors_formatted(self) -> List
  -- Return a formatted list of static errors inside this block.
def Block.has_static_error(self) -> bool
  -- Return whether this block has any static errors.
def Block.id(self) -> int
def Block.input(self, int index) -> Term
  -- Fetch an input placeholder term by index.
def Block.is_null(self) -> bool
  -- Return whether this is a null Block reference.
def Block.inputs(self) -> List
  -- Return a list of input placeholder terms.
def Block.link(self, Block lib)
  -- Iterate through this block, looking for terms that have missing references.
  -- For each missing reference, if a term with the expected name is found in 'lib',
  -- then modify the term to use the named term in 'lib'.
def Block.list_configs(self) -> List
  -- Return a list of Terms that look like configs (named literal values).
def Block.output(self, int index) -> Term
  -- Return an output term by index.
def Block.outputs(self) -> List
  -- List of output placeholder terms.
def Block.output_placeholder(self, int index) -> Term
  -- Return an output placeholder term by index.
def Block.owner(self) -> Term
  -- Return the Term that owns this Block (may be null).
def Block.parent(self) -> Block
  -- Return the Block that owns this Block (may be null).
def Block.primary_output(self) -> Term
  -- Return the primary output.
  self.output(0)
def Block.property(self, Symbol key) -> any
def Block.properties(self) -> Map
def Block.source_filename(self) -> String
def Block.statements(self) -> List
  -- Return a list of Terms that are statements.
def Block.terms(self) -> List
  -- Return a list of this block's terms.
def Block.term_named(self, String name) -> Term
def Block.walk_terms(self) -> List
  -- Return a list of this block's terms, and all nested terms.

def Block.to_func(self) -> Func
  Func.make(self)

def Block.to_stack(self) -> Stack
  self.to_func.to_stack

def Block.name(self) -> String
    self.owner.name

def Block.is_method(self) -> bool
  self.owner.property("syntax:methodDecl") == true

def Block.get_top_comments(self) -> List
  out = []
  for Term t in self.terms
    if t.is_input_placeholder
      continue
    elif t.is_comment
      s = t.property('comment')
      if s == ""
        break

      out.append(t.property('comment'))
    else
      break

  out

def Block.call(self, any inputs :multiple) -> any
  -- Invoke this Block with the given inputs.
  self.to_func.apply(inputs)

def Block.get_loop_index(self) -> Term
  -- For a for-loop, return the index term
  for term in self.terms
    if term.function == loop_index.block
      return term
  error("Iterator not found in Block.get_iterator")

def Block.get_iterator(self) -> Term
  -- For a for-loop, return the iterator term
  for term in self.terms
    if term.function == loop_get_element.block
      return term
  error("Iterator not found in Block.get_iterator")

def Block.if_block_cases(self) -> List
  self.terms.filter((term) -> term.function.name == 'case')

def Block.case_find_condition(self) -> Term
  for term in self.terms
    if term.function == case_condition_bool.block
      return term
  return null

def Block.find_while_condition(self) -> Term
  for term in self.terms
    if term.function == loop_condition_bool.block
      return term
  return null

struct Frame { Stack stack, int index }
struct ModuleFrame { Block block, List registers }

def Frame.active_value(self, Term) -> any
def Frame.set_active_value(self, Term, any)
def Frame.block(self) -> Block
  -- Return the Block associated with this Frame.
def Frame.current_term(self) -> Term
  -- Fetch the term associated with the current program counter.
def Frame.create_expansion(self, Term term) -> Frame
  -- Create an expansion frame using the given Term.
  -- Errors if the Term is not part of this frame's block.
def Frame.height(self) -> int
  -- Frame height, the distance from the base frame.
def Frame.has_parent(self) -> bool
def Frame.parent(self) -> Frame
  -- Return this frame's parent.
def Frame.pc(self) -> int
  -- Fetch the current program counter (the interpreter's current position).
def Frame.parentPc(self) -> int
def Frame.register(self, int index) -> any
  -- Fetch the value in the given register index.
def Frame.registers(self) -> List
  -- Fetch a list of all register values.
def Frame.inputs(self) -> List
  -- Returns a list of input register values
def Frame.input(self, int nth) -> any
  -- Returns the nth input register value
def Frame.outputs(self) -> List
  -- Returns a list of output register values
def Frame.output(self, int nth) -> any
  -- Returns the nth output register value
def Frame.extract_state(self) -> Map
  -- Returns the frame's state as a plain object (composite of maps and lists).

def capture_stack() -> Stack
  -- Returns a frozen copy of the currently executing stack.

def Stack.apply(self, List inputs) -> any
def Stack.block(self) -> Block
  -- Returns the (topmost) block.
def Stack.call(self, any inputs :multiple) -> any
def Stack.copy(self) -> Stack
def Stack.current_term(self) -> Term
  self.top.current_term
def Stack.dump(self)
  -- Dumps a string representation to stdout.
def Stack.dump_with_bytecode(self)
def Stack.dump_compiled(self)
def Stack.eval_on_demand(self, Term term) -> any
def Stack.find_active_value(self, Term term) -> any
def Stack.rethrow(self)
  -- If the stack has an error, raise it in this context.
  if self.has_error
    error(self.error_message)
def Stack.extract_state(self) -> Map
def Stack.find_active_frame_for_term(self, Term term) -> Frame
def Stack.id(self) -> int
def Stack.init(self, Func func)
def Stack.has_incoming_state(self) -> bool

def Stack.env(self, name) -> any
def Stack.env_map(self) -> Map
def Stack.set_env(self, any name, any val)
def Stack.set_env_map(self, Map map)

def Stack.init_env(self)
  self.set_env_map(Map.make)

def Stack.modify_env(self, Func func)
  self.set_env_map(func.call(self.env_map))

def Stack.append_hack(self, any hack)
  self.modify_env((env) -> env.list_append(:_hacks hack))

def Stack.forward_env(self, names :multiple)
  for name in names
    self.set_env(name env(name))

def Stack.init_channel(self, any name)
  self.set_env(name, [])

def Stack.read_channel(self, any name)
  out = self.env_map.get(name)
  self.set_env(name, [])
  return out

def Stack.get_watch_result(self, key) -> any
def Stack.stack_push(self, Block b, List inputs)
  -- Push a new frame, using the given block and input list.
def Stack.stack_push2(self, Func func)
  self.stack_push(func.block, [])
def Stack.stack_pop(self)
  -- Pop the topmost frame.
def Stack.set_state_input(self, any)
def Stack.get_state(self) -> any
def Stack.migrate(self, Block from, Block to)
def Stack.migrate_to(self, Func func)
  -- Use 'func' as the new root, and migrate data and state.
def Stack.reset(self)
def Stack.reset_state(self)
def Stack.restart(self)
  -- Restart or "rewind" the stack, so the program counter is returned to the start
  -- of the topmost frame. State is preserved.
def Stack.run(self) -> Stack
  -- Run the interpreter until either the topmost frame is finished, or an error
  -- is raised.
def Stack.frame(self, int depth) -> Frame
  -- Return the Frame with the given depth. The top of the stack has depth 0.
def Stack.frame_from_base(self, int height) -> Frame
  -- Return the Frame with the given height.
def Stack.frame_count(self) -> int

def Stack.frames_from_top(self) -> List
  for i in 0..self.frame_count
    self.frame(i)

def Stack.frames_from_start(self) -> List
  for i in self.frame_count..0
    self.frame(i-1)

def Stack.top(self) -> Frame
  -- Return the topmost Frame.
  self.frame(0)

def Stack.active_value(self, Term term) -> any
  self.top.active_value(term)

def Stack.set_active_value(self, Term term, any val)
  self.top.set_active_value(term, val)

def Stack.output(self, int index) -> any
  -- Fetch the value in the nth output register.

def Stack.errored(self) -> bool
  -- Returns true if the interpreter has stopped due to error.

def Stack.has_error(self) -> bool
  self.errored

def Stack.error_message(self) -> String
  -- If there is a recorded error, returns a human-readable description string.

def Stack.toString(self) -> String

def make_stack(Func func) -> Stack
  -- Create a new stack (deprecated name, see make_vm)

def make_vm(Func func) -> Stack
  -- Create a new Stack

def Func.to_stack(self) -> Stack
  make_stack(self)

def repeat(any val, int count) -> List

def int.to_hex_string(val) -> String

def List.append(self, any item) -> List
  -- Append an item to the end of this list.

def List.by_pairs(self) -> List
  out = []
  for i in range(0, self.length // 2)
    @out.append([self.get(i*2) self.get(i*2 + 1)])

  if self.length > 0 and (self.length % 2) == 1
    @out.append([self.get(self.length - 1)])

  out

def List.clear(self) -> List
  -- Return an empty list.
  []

def List.concat(self, List rightSide) -> List
  -- Concatenate two lists.

def List.contains(self, any val) -> bool
  for i in self
    if i == val
      return true
  return false

def List.resize(self, int length) -> List
  -- Resize the list to have the given length. If the length is increased, then
  -- null values are appended on the right; if the length is decreased then
  -- existing values on the right are dropped.

def List.count(self) -> int
  -- Return the number of elements in this list.

def List.insert(self, int index, any val) -> List
  -- Insert an element at the given index. If necessary, existing elements will
  -- be shifted to the right to make room.
  --
  -- Example:
  --   a = [1 2 3]
  --   a.insert(1, 'X')
  --   -- a now equals [1 'X' 2 3]

def List.prepend(self, any val) -> List
  self.insert(0, val)
    
def List.length(self) -> int
  -- Return the number of elements in this list.

def List.join(self, String joiner) -> String
  -- Return a string constructed by converting every element to a string, and
  -- concatenating those strings, each separated by 'joiner'.
  --
  -- Example:
  --  [1 2 3].join(', ')
  -- 
  -- Outputs: '1, 2, 3'

def List.split(self, boundaryValue) -> List
  out = [[]]
  for item in self
    if item == boundaryValue
      @out.append([])
    else
      @out.modify(out.length - 1, (el) -> el.append(item))
  out

def List.slice(self, int start, int fin) -> List
  -- Return a list constructed from the elements starting from index 'start', and
  -- ending immediately before index 'fin'.
  --
  -- If either 'start' or 'fin' is negative, it's interpreted as an offset from the
  -- end of the list.
  --
  -- Examples:
  --  [1 2 3 4].slice(1 3)
  --  Outputs: [2 3]
  -- 
  --  [1 2 3 4].slice(0 -2)
  --  Outputs: [1 2 3 4]

def List.get(self, int index) -> any
  -- Get an element by index.

def List.get_opt(self, int index, any fallback) -> any
  -- Get an element by index if it exists, otherwise return 'fallback'.
  if index < 0 or index >= self.length
    fallback
  else
    self.get(index)

def List.set(self, int index, any val) -> List
  -- Set an element by index.

def List.remove(self, int index) -> List
  -- Remove an element at the given index, shrinking the list by 1.

def List.modify(self, int index, Func func)
  self.set(index, func.call(self.get(index)))

def List.add(self, any value) -> List
  if is_compound(value)
    for i,el in self { el + value[i] }
  else
    for el in self { el + value }

def List.sub(self, any value) -> List
  if is_compound(value)
    for i,el in self { el - value[i] }
  else
    for el in self { el - value }

def List.mult(self, any value) -> List
  if is_compound(value)
    for i,el in self { el * value[i] }
  else
    for el in self { el * value }

def List.div(self, any value) -> List
  if is_compound(value)
    for i,el in self { el / value[i] }
  else
    for el in self { el / value }

def List.cycle(self, int index) -> any
  -- Get an element by index. If the index is out of bounds, then modulo the
  -- index to one that exists.
  self.get(mod(index, self.length))

def List.empty(self) -> bool
  -- Returns whether the list is empty.
  self.length == 0

def List.first(self) -> any
  -- Returns the first element
  self.get(0)

def List.last(self) -> any
  -- Returns the last element
  self.get(self.length - 1)

def List.pop(self) -> (List, any)
  return self.slice(0, -1), self.last

def List.filter(self, Func func) -> List
  result = []
  for i in self
    if func.call(i)
      @result.append(i)
  result

def List.flatten(self) -> List
  -- Take a list of lists, and concat them all into one list.
  out = []
  for el in self
    @out.concat(el)
  out

def List.each(self, Func func) -> List
  for i in self
    func.call(i)

def List.apply(self, int index, Func func) -> List
  self.set(index, func.call(self[index]))

def Map.contains(self, any key) -> bool
  -- Returns true if the map contains the given key.

def Map.remove(self, any key) -> Map
  -- Removes the given key from the map.

def Map.get(self, any key) -> any
  -- Gets the key associated with this value.

def Map.get_opt(self, any key, any default) -> any
  if self.contains(key)
    self.get(key)
  else
    default
    
def Map.set(self, any key, any value) -> Map
  -- Sets the value associated with this key.

def Map.empty(self) -> bool
  -- Whether the map has no values

def Map.apply(@self, any key, Func func)
  @self.set(key, func.call(self.get(key)))

def Map.modify(@self, any key, Func func)
  @self.set(key, func.call(self.get(key)))

def Map.list_append(@self, any key, any value) -> Map
  if self.contains(key)
    @self.modify(key, (l) -> l.append(value))
  else
    @self.set(key, [value])

def Map.bucketize(@self, List list, Func getKey) -> Map
  for el in list
    @self.list_append(getKey.call(el), el)

  -- language defect, shouldn't be required:
  self

def Map.keys(self) -> List

struct Set {
  Map m
}

def Set.add(@self, element) -> Set
  @self.m.set(element, true)

def Set.contains(@self, element) -> bool
  self.m.contains(element)

def Set.remove(@self, element) -> Set
  @self.m.remove(element)

def Set.elements(self) -> List
  self.m.keys

def List.to_set(self) -> Set
  set = make(Set)
  for item in self
    @set.add(item)
  set

def String.append(self, String right) -> String
  -- Append a string to the right side.
  str(self, right)
    
def String.char_at(self, int index) -> String
  -- Get character at a given index. UTF unsafe.

def String.index_of(self, String substr) -> (bool, int)
  for i in 0..self.length
    if self.substr(i, substr.length) == substr
      return true, i
  return false, 0

def String.ends_with(self, String suffix) -> bool
  -- Return true if this string ends with the given substring.

def String.char_code(self) -> int
def String.from_char_code(self, int code) -> String

def String.length(self) -> int
  -- Returns the string length.

def String.slice(self, int start, int fin) -> String

def String.starts_with(self, String prefix) -> bool
  -- Returns true if the string starts with the given prefix.

def String.split(self, String sep) -> List

def String.substr(self, int start, int length) -> String

def String.to_camel_case(self) -> String
  -- Deprecated function

def String.to_lower(self) -> String

def String.to_upper(self) -> String

def String.to_number(self) -> number
def String.to_int(self) -> int

def String.characters(self) -> List
    out = for i in 0..(self.length)
        self.char_at(i)
    return out

-- Type
def Type.declaringTerm(self) -> Term
def Type.cast(self, any value) -> any
    value, success = cast(value, self)
    if not(success)
        error(str("Couldn't cast value " value " to type " self.name))
    value
        
def Type.make(self, any values :multiple) -> any
def Type.name(self) -> String
def Type.property(self, String name) -> any

-- Term
def term_ref(term :ref) -> Term
  if term.function == _nonlocal.block
    term = term.input(0)
  term
def Term.assign(self, any val)
def Term.asint(self) -> int
def Term.asfloat(self) -> number
def Term.index(self) -> int
def Term.contents(self) -> Block
    -- Fetch the nested Block contents of this Term. The format and the meaning
    -- of these contents is dictated by the term's function.
def Term.is_input(self) -> bool
def Term.is_null(self) -> bool
    -- Returns whether this is a null Term reference.
def Term.is_output(self) -> bool
def Term.name(self) -> String
    -- Return this term's local name. May be blank.
def Term.parent(self) -> Block
def Term.to_string(self) -> String
def Term.unique_name(self) -> any
def Term.function(self) -> Block
    -- Fetch this term's function.
def Term.get_type(self) -> Type
    -- Fetch the declared type of this term.
def Term.id(self) -> int
def Term.value(self) -> any
    -- For a value term, this fetches the actual value.
def Term.set_value(self, any val)
    -- For a value term, permanently change the value.
def Term.input(self, int index) -> Term
    -- Fetch an input term by index.
def Term.inputs(self) -> List
    -- Return a list of input terms.
def Term.num_inputs(self) -> int
    -- Return the number of inputs.
def Term.source_location(self) -> Rect_i
    -- Return a Rect_i that describes where this term occurs in its source file.
def Term.location_string(self) -> String
def Term.global_id(self) -> int
    -- Fetch this term's global identifier.

def Term.properties(self) -> Map

def Term.has_property(self, Symbol key) -> bool
def Term.property(self, Symbol key) -> any
    -- Fetch a term property.
def Term.property_opt(self, Symbol key, default) -> any
    -- Fetch an optional term property.

def Term.input_property(self, int index, Symbol key) -> any
def Term.input_property_opt(self, int index, Symbol key, any default) -> any
def Term.has_input_property(self, int index, Symbol key) -> bool

def Term.is_value(self) -> bool
def Term.is_function(self) -> bool
    self.get_type == Func
def Term.is_func_decl(self) -> bool
    self.function == function_decl.block
def Term.has_name(term) -> bool
  term.name != ''
def Term.is_hidden(term) -> bool
  term.property_opt(:Hidden, false)
def Term.is_statement(term) -> bool
  term.property_opt(:Statement, false)
def Term.is_type(self) -> bool
    self.is_value and is_type(self.value)
def Term.is_input_placeholder(self) -> bool
    self.function == input_placeholder.block
def Term.is_comment(self) -> bool
    self.function == comment.block
def Term.trace_dependents(self, Block untilBlock) -> List
def Term.output(self, int index) -> Term
  if index == 0
    self
  else
    self.extra_output(index - 1)
def Term.extra_output(self, int index)
  self.parent.get_term(self.index + index + 1)

def vec2(number x, number y)
  Vec2.make(x y)

def Vec2.add(self, rhs) -> Vec2
  rhs, isVec = cast(rhs, Vec2)
  if isVec
    [self.x + rhs.x, self.y + rhs.y]
  else
    [self.x + rhs, self.y + rhs]

def Vec2.sub(self, rhs) -> Vec2
  rhs, isVec = cast(rhs, Vec2)
  if isVec
    [self.x - rhs.x, self.y - rhs.y]
  else
    [self.x - rhs, self.y - rhs]

def Vec2.mult(self, rhs) -> Vec2
  rhs, isVec = cast(rhs, Vec2)
  if isVec
    [self.x * rhs.x, self.y * rhs.y]
  else
    [self.x * rhs, self.y * rhs]

def Vec2.div(self, rhs) -> Vec2
  rhs, isVec = cast(rhs, Vec2)
  if isVec
    [self.x / rhs.x, self.y / rhs.y]
  else
    [self.x / rhs, self.y / rhs]
    
def Vec2.distance(self, Vec2 b) -> number
  -- Returns the distance between self and b.
  sqrt(sqr(self.x - b.x) + sqr(self.y - b.y))

def Vec2.distance_sqr(self, Vec2 b) -> number
  sqr(self.x - b.x) + sqr(self.y - b.y)

def Vec2.magnitude(self) -> number
  -- Return the magnitude of this point, aka the distance to the origin.
  sqrt(sqr(self.x) + sqr(self.y))

def Vec2.magnitude_sqr(self) -> number
  sqr(self.x) + sqr(self.y)

def Vec2.norm(self) -> Vec2
  -- Returns the point normalized to be along the unit circle.
  m = self.magnitude
  [self.x / m, self.y / m]

def Vec2.perpendicular(self) -> Vec2
  -- Returns a perpendicular vector, rotated clockwise.
  [self.y -self.x]

def Vec2.translate(self, Vec2 b) -> Vec2
  [self.x + b.x, self.y + b.y]

def Vec2.to_rect_center(self, Vec2 size) -> Rect
  -- Returns a Rect with this point as the center, and the given size.
  size_half = (size * 0.5) -> Vec2.cast
  [self.x - size_half.x,
      self.y - size_half.y, self.x + size_half.x, self.y + size_half.y]

def Vec2.to_rect_topleft(self, Vec2 size) -> Rect
  -- Returns a Rect with this point as the top-left, and the given size.
  [self.x, self.y, self.x + size.x, self.y + size.y]

def Vec2.delta(self) -> Vec2
  -- Stateful function, returns the point difference since the last step.
  state Vec2 prev = self
  result = [self.x - prev.x, self.y - prev.y]
  prev = self
  result

def Vec2.rotate(self, number rotation) -> Vec2
  -- Return the point rotated around [0 0] by the given angle.
  [self.x*cos(rotation) - self.y*sin(rotation), self.x*sin(rotation)+self.y*cos(rotation)]

def vec3(number x, number y, number z)
  Vec3.make(x y z)
def Vec3.add(self, Vec3 b) -> Vec3
  [self.x + b.x, self.y + b.y, self.z + b.z]
def Vec3.sub(self, Vec3 b) -> Vec3
  [self.x - b.x, self.y - b.y, self.z - b.z]
def Vec3.mult(self, number s) -> Vec3
  [self.x * s, self.y * s, self.z * s]
def Vec3.div(self, number s) -> Vec3
  [self.x / s, self.y / s, self.z / s]

def vec4(number x, number y, number z, number w)
  Vec4.make(x y z w)

def Rect.add(self, Rect b) -> Rect
  [self.x1 + b.x1, self.y1 + b.y1, self.x2 + b.x2, self.y2 + b.y2]
def Rect.sub(self, Rect b) -> Rect
  [self.x1 - b.x1, self.y1 - b.y1, self.x2 - b.x2, self.y2 - b.y2]
def Rect.mult(self, number s) -> Rect
  [self.x1 * s, self.y1 * s, self.x2 * s, self.y2 * s]
def Rect.div(self, number s) -> Rect
  [self.x1 / s, self.y1 / s, self.x2 / s, self.y2 / s]

def Rect.width(self) -> number
  self.x2 - self.x1
def Rect.height(self) -> number
  self.y2 - self.y1
def Rect.size(self) -> Vec2
  [self.width self.height]
def Rect.left(self) -> number
  self.x1
def Rect.top(self) -> number
  self.y1
def Rect.right(self) -> number
  self.x2
def Rect.bottom(self) -> number
  self.y2
def Rect.top_left(self) -> Vec2
  -- Returns the top-left coordinates as a Vec2.
  [self.x1 self.y1]
def Rect.top_right(self) -> Vec2
  -- Returns the top-rigth coordinates as a Vec2.
  [self.x2 self.y1]
def Rect.bottom_left(self) -> Vec2
  -- Returns the bottom-left coordinates as a Vec2.
  [self.x1 self.y2]
def Rect.bottom_center(self) -> Vec2
  [(self.x1+self.x2)/2, self.y2]
def Rect.bottom_right(self) -> Vec2
  -- Returns the bottom-right coordinates as a Vec2.
  [self.x2 self.y2]
def Rect.center(self) -> Vec2
  -- Returns the rectangle's center as a Vec2
  [(self.x1 + self.x2) / 2, (self.y1 + self.y2) / 2]
def Rect.points_cw(self) -> List
  [self.top_left self.top_right self.bottom_right self.bottom_left]
def Rect.points_ccw(self) -> List
  [self.top_left self.bottom_left self.bottom_right self.top_right]

def Rect.intersects(self, Rect b) -> bool
  -- Return whether the two rectangles intersect.
  intersects_on_x = (self.x2 > b.x1) and (b.x2 > self.x1)
  intersects_on_y = (self.y2 > b.y1) and (b.y2 > self.y1)
  intersects_on_x and intersects_on_y

def Rect.translate(self, Vec2 p) -> Rect
  [self.x1 + p.x, self.y1 + p.y, self.x2 + p.x, self.y2 + p.y]

def Rect.contains(self, Vec2 p) -> bool
  p.x >= self.x1 and p.y >= self.y1 and p.x < self.x2 and p.y < self.y2

def Rect.grow(self, Vec2 size) -> Rect
  [self.x1 - size.x, self.y1 - size.y, self.x2 + size.x, self.y2 + size.y]

def Rect.grow_s(self, number size) -> Rect
  [self.x1 - size, self.y1 - size, self.x2 + size, self.y2 + size]

def Rect.subtractFrom(self, Symbol side, number dimension) -> (Rect, Rect)
  if side == :top
    min(@dimension, self.height)
    out = self.set_y2(dimension)
    self.y1 += dimension
    return self, out
  if side == :left
    min(@dimension, self.width)
    out = self.set_x2(self.x1 + dimension)
    self.x1 += dimension
    return self, out
  if side == :right
    min(@dimension, self.width)
    out = self.set_x1(self.x2 - dimension)
    self.x2 -= dimension
    return self, out
  if side == :bottom
    min(@dimension, self.height)
    out = self.set_y1(self.y2 - dimension)
    self.y2 -= dimension
    return self, out
  error(str('Unrecognized side: ' side))

def sum(List numbers) -> number
  result = 0
  for i in numbers
    result += i
  result
    
def zip(List left, List right) -> List
  for i,l in left
    [l, right.get_opt(i, null)]

-- Stateful functions

def cached(Func refresh) -> any
  -- Cache a function's result, the function will only be (re)evaluated as needed.

  state Func prev_refresh
  state prev_version = global_script_version()
  state out
  if prev_refresh != refresh or prev_version != global_script_version()
    prev_refresh = refresh
    prev_version = global_script_version()
    out = refresh.call()
  out

def changed(any val) -> bool
  -- Stateful function; returns true if the value has changed since the
  -- previous step.
  state any prev = null
  result = prev != val
  prev = val
  result

def delta(number val) -> number
  -- Stateful function, return the difference between this value and the value from
  -- the previous call.
  state number prev = val
  result = val - prev
  prev = val
  result

def toggle(bool tog) -> bool
  -- Stateful function, returns a boolean status. Every frame the function is called
  -- with (true), the result flips. Starts out false.

  state bool s = false
  if tog
    s = not(s)
  s

def approach(number target, number maximum_change) -> number
  -- Stateful function, returns a result which approaches 'target'. Each time the
  -- function is called, the result will change at most by 'maximum_change'.
  state current = target
  if target > current
    current += min(maximum_change, target - current)
  elif target < current
    current -= min(maximum_change, current - target)
  current

def once() -> bool
  -- Stateful function, returns true the first time it's called, and false thereafter.
  state bool s = true
  result = s
  s = false
  result

def cycle(int max) -> int
  -- Stateful function, cycles though the integers from 0 to (max - 1). When the
  -- maximum is reached, the function will start again at 0.

  state int counter = 0
  if counter >= max
    counter = 0
  result = counter
  counter += 1
  result

def cycle_elements(List list) -> any
  -- Stateful function, cycles through each item of 'list' one at a time.
  list[cycle(length(list))]

def random_element(List list) -> any
  -- Return a random element from the given list, with equal probability per element.
  list[rand_i(length(list))]

def seed() -> number
  -- Stateful function, returns a random number 0..1 which doesn't change after
  -- initialization.
  state number s = rand()
  s

-- Math utility functions
def polar(number angle) -> Vec2
  -- Return a point on the unit circle with the given angle.
  [cos(angle) sin(angle)]

def random_norm_vector() -> Vec2
  -- Return a random normalized vector.
  angle = rand() * 360
  [cos(angle) sin(angle)]

def rect(number x1, number y1, number x2, number y2) -> Rect
  [x1 y1 x2 y2]

def bezier3(number t, List points) -> Vec2
  -- Quadratic bezier curve, with 3 control points. t must be in the range of [0, 1].
  p0 = points[0] -> Vec2.cast
  p1 = points[1] -> Vec2.cast
  p2 = points[2] -> Vec2.cast
  (p0 * sqr(1 - t) + p1 * (2 * t * (1 - t)) + p2 * sqr(t))

def bezier4(number t, List points) -> Vec2
  -- Cubic bezier curve, with 4 control points. t must be in the range of [0, 1].
  p0 = points[0] -> Vec2.cast
  p1 = points[1] -> Vec2.cast
  p2 = points[2] -> Vec2.cast
  p3 = points[3] -> Vec2.cast
  (p0 * cube(1 - t) + p1 * (3 * t * sqr(1 - t)) + p2 * sqr(t) * (3 * (1 - t)) + p3 * cube(t))

def smooth_in_out(number t, number smooth_in, number smooth_out) -> number
  bezier4(t, [[0 0] [smooth_in, 0] [1 - smooth_out, 1] [1 1]]).y

def clamp(number x, number minVal, number maxVal) -> number
  -- Return a clamped value. If x is less than 'minVal' then return 'minVal', if it's
  -- greater than 'maxVal' then return 'maxVal', otherwise return the original 'x'.
  min(max(x, minVal), maxVal)

def smoothstep(number x, number edge0, number edge1) -> number
  -- Smooth interpolation func, see en.wikipedia.org/wiki/Smoothstep
  x = clamp((x - edge0)/(edge1-edge0), 0, 1)
  x*x*(3 - 2*x)

def smootherstep(number x, number edge0, number edge1) -> number
  -- Alternative to smoothstep by Ken Perlin, see en.wikipedia.org/wiki/Smoothstep
  x = clamp((x - edge0)/(edge1-edge0), 0, 1)
  x*x*x*(x*(x*6 - 15) + 10)

def random_color() -> Color
  -- Return a color with random RGB components.
  [rand() rand() rand() 1.0]

def hsv_to_rgb(List hsv) -> Color
  -- Convert HSV components to an RGB Color

  h = hsv[0] -> number.cast
  s = hsv[1] -> number.cast
  v = hsv[2] -> number.cast

  if s == 0
      -- grey
      return [v v v 1]

  h *= 6
  i = floor(h)
  f = h - i
  p = v * (1 - s)
  q = v * (1 - s * f)
  t = v * (1 - s * (1 - f))

  if i == 0
    [v t p 1]
  elif i == 1
    [q v p 1]
  elif i == 2
    [p v t 1]
  elif i == 3
    [p q v 1]
  elif i == 4
    [t p v 1]
  elif i == 5
    [v p q 1]
  else
    [0 0 0 0]

def hsl_color(number h, number s, number l) -> Color
  if s == 0
    [1 1 1 1]
  else
    def hue_to_rgb(number p, number q, number t)
      mod(@t 1)
      if t < 1/6
        p + (q - p) * 6 * t
      elif t < 1/2
        q
      elif t < 2/3
        p + (q - p) * (2/3 - t) * 6
      else
        p

    q = if l < 0.5
      l * (1 + s)
    else
      l + s - l * s

    p = 2 * l - q
    r = hue_to_rgb(p, q, h + 1/3)
    g = hue_to_rgb(p, q, h)
    b = hue_to_rgb(p, q, h - 1/3)
    [r g b 1]

def Color.add(self, any value) -> Color
  for i in self { i + value }
def Color.sub(self, any value) -> Color
  for i in self { i - value }
def Color.mult(self, any value) -> Color
  for i in self { i * value }
def Color.div(self, any value) -> Color
  for i in self { i / value }

def Color.blend(self, Color rhs, number ratio) -> Color
  -- Return a color that is blended between self and rhs. If ratio is 0.0 we'll
  -- return 'self', if it's 1.0 we'll return 'rhs'.

  max(@ratio, 0.0)
  min(@ratio, 1.0)

  if ratio == 0.0
    self
  elif ratio == 1.0
    rhs
  else
    self + (rhs - self) * ratio

def Color.lighten(self, number factor) -> Color
  -- Linearly lighten each component of the color.
  [ min(self.r + factor, 1.0)
    min(self.g + factor, 1.0)
    min(self.b + factor, 1.0)
    self.a]
        
def Color.darken(self, number factor) -> Color
  -- Linearly darken each component of the color.
  [ max(self.r - factor, 0.0)
    max(self.g - factor, 0.0)
    max(self.b - factor, 0.0)
    self.a]

def weighted_rand(List choices :multiple) -> any
  total = 0
  for choice in choices
    weight = choice[0]
    total += weight

  r = rand() * total
  for choice in choices
    r -= choice[0]
    if r < 0
      return choice[1]

  return null

def rand_gaussian()
  -- Box-Muller transform

  rand1 = -2 * log(rand())
  rand2 = (rand()) * 360
  sqrt(rand1) * cos(rand2)

def number.map(x, Vec2 fromRange, Vec2 toRange)
  ratio = (x - fromRange[0]) / (fromRange[1] - fromRange[0])
  (toRange[0] + ratio * (toRange[1] - toRange[0]))

def int.map(x, Vec2 fromRange, Vec2 toRange)
  ratio = (x - fromRange[0]) / (fromRange[1] - fromRange[0])
  (toRange[0] + ratio * (toRange[1] - toRange[0]))

def noise(number x)
  -- Perlin noise

-- Codechange objects
def codechange_set_value(Term target, any newValue) -> List
  [:set_value target newValue]

def debug_break()
