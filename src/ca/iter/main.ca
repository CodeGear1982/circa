
struct ListIterator {
  List list
  int index
}

def ListIterator.done(self) -> bool
  self.index >= self.list.length

def ListIterator.next(self) -> any
  self.list[self.index]

def ListIterator.advance(self) -> any
  self.index += 1
  if self.done
    self = []
  self

def List.to_iterator(self)
  it = ListIterator.make(self 0)
  if it.done
    []
  else
    it

def to_iterator(it) -> any
  if is_list(it)
    @it.to_iterator
  it

def visit(it, func)
  to_iterator(@it)

  while it != []
    func(it.next)
    @it.advance

def fold(it, func, accum)
  to_iterator(@it)

  while it != []
    accum = func.call(accum it.next)
    @it.advance

  accum

def flatten(it) -> List
  to_iterator(@it)
  if it == []
    return []

  -- Language defect: Should be able to refer to the function List.append directly.
  def append(List list, item) -> List
    list.append(item)
    
  fold(it append [])

struct ConcatenatedIterator {
  any left
  any right
}

def concat(left, right)
  to_iterator(@left)
  to_iterator(@right)

  if left == []
    right
  else
    ConcatenatedIterator.make(left right)

def ConcatenatedIterator.next(self)
  self.left.next

def ConcatenatedIterator.advance(self)

  nextLeft = self.left.advance

  if nextLeft == []
    self = self.right
  else
    self.left = nextLeft

  self

def flatmap(it, transformer)
