
def toggle(bool tog) -> bool
    <<<
    Stateful function, returns a boolean status. Every frame the function is called
    with (true), the result flips. Starts out false.
    >>>
    state bool on = false
    if tog; on = not(on); end
    return on
end

def approach(number target, number maximum_change) -> number
    <<<
    Stateful function, returns a result which approaches 'target'. Each frame, this
    result will change at most by 'maximum_change'
    >>>
    state current = target
    if target > current
        current += min(maximum_change, target - current)
    elif target < current
        current -= min(maximum_change, current - target)
    end
    return current
end

def once() -> bool
    <<<
    Stateful function, returns true the first time it's called, and false thereafter.
    >>>
    state bool s = true
    result = s
    s = false
    return result
end

-- Math utility functions
def to_rect(Point topLeft, Point size) -> Rect
    return [topLeft.x, topLeft.y, topLeft.x + size.x, topLeft.y + size.y]
end

def polar(number angle) -> Point
    return [cos(angle) sin(angle)]
end

def magnitude(Point point) -> number
    "Returns the magnitude, or the distance from [0,0] to this point."
    return sqrt(sqr(point.x) + sqr(point.y))
end

def point_distance(Point a, Point b) -> number
    "Returns the distance between a and b."
    return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y))
end

def rotate_point(Point p, number rotation) -> Point
    "Rotate p around [0,0] by the given angle. Angles are specified in the range 0..1."
    return [p.x*cos(rotation) - p.y*sin(rotation),
        p.x*sin(rotation)+p.y*cos(rotation)]
end

def random_norm_vector() -> Point
    "Return a random normalized vector"
    angle = rand()
    return [cos(angle) sin(angle)]
end

def norm(Point v) -> Point
    "Returns v normalized to be along the unit circle."
    m = magnitude(v)
    return [v.x / m, v.y / m]
end

def perpendicular(Point v) -> Point
    "Returns a vector that is perpendicular to v, rotated clockwise."
    return [v.y -v.x]
end

def expand_rect(Point center, number width, number height) -> Rect
    "Return a rectangle with the given center, width, and height."
    return [center.x - width/2, center.y - height/2, center.x + width / 2, center.y + height/2]
end

def rect(Point topleft, Point bottomright) -> Rect
    return [topleft.x topleft.y bottomright.x bottomright.y]
end

def rect_intersects_rect(Rect rect_a, Rect rect_b) -> bool
    "Return whether the two rectangles intersect."
    def unit_tests()
        rect_intersects_rect([0 0 10 10] [1 1 2 2])
        rect_intersects_rect([0 0 2 1] [1 0 3 1])
        rect_intersects_rect([1 0 3 1] [0 0 2 1])
    end

    intersects_on_x = (rect_a.x2 > rect_b.x1) and (rect_b.x2 > rect_a.x1)
    intersects_on_y = (rect_a.y2 > rect_b.y1) and (rect_b.y2 > rect_a.y1)
    return intersects_on_x and intersects_on_y
end

def random_color() -> Color
    return [rand() rand() rand() 1.0]
end

def blend_color(Color a, Color b, number ratio) -> Color
    def unit_tests()
        blend_color(#abc #123 0.0) == #abc
        blend_color(#abc #123 1.0) == #123
        blend_color(#abc #123 2.0) == #123
        blend_color(#abc #123 -1.0) == #abc
        blend_color(#fff #fff 0.5) == #fff
    end

    max(@ratio, 0.0)
    min(@ratio, 1.0)

    if ratio == 0.0
        return a
    elif ratio == 1.0
        return b
    else
        result = a + (b - a) * ratio

        -- hack to preserve alpha:
        result[3] = 1.0
        return result
    end
end

def delta(number val) -> number
    state number prev = val
    result = val - prev
    prev = val
    return result
end

namespace styled_source
    literal_string = 1
    literal_number = 4
    paren = 2
    comment = 3
    name = 5
    keyword = 205
    type_name = 203
    function_name = 202
    infix_operator = 201
    whitespace = 206
end
