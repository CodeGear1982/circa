// This file was autogenerated

#include <cstring>

namespace circa {

const char* find_builtin_file(const char* filename) {

    if (strncmp(filename, "$builtins/", 10) != 0)
        return NULL;

    if (strncmp(filename, "$builtins/bytecode_analysis.ca", 30) == 0) return
        "\n"
        "struct Mop {\n"
        "  int maddr\n"
        "  Symbol opcode\n"
        "  int addr\n"
        "  int slot\n"
        "  int related_maddr\n"
        "}\n"
        "\n"
        "def read_op(Blob blob)\n"
        "  {:opcode => opcode_from_int(blob.i16(6)), :a => blob.i16(0), :b => blob.i16(2), :c => blob.i16(4)}\n"
        "\n"
        "def read_mop(int maddr, Blob blob) -> Mop\n"
        "  Mop.make(maddr, mopcode_from_int(blob.i32(0)), blob.i32(4), blob.i32(8) blob.i32(12))\n"
        "\n"
        "def opcode_from_int(int opcode) -> Symbol\n"
        "  switch opcode\n"
        "    case 0x1 :nope\n"
        "    case 0x3 :uncompiled_call\n"
        "    case 0x8 :call\n"
        "    case 0x43 :func_call_s\n"
        "    case 0x2 :func_call_d\n"
        "    case 0x39 :func_apply_d\n"
        "    case 0x38 :dyn_method\n"
        "    case 0x4 :jump\n"
        "    case 0x30 :jif\n"
        "    case 0x31 :jnif\n"
        "    case 0x24 :jeq\n"
        "    case 0x25 :jneq\n"
        "    case 0x26 :jgt\n"
        "    case 0x27 :jgte\n"
        "    case 0x28 :jlt\n"
        "    case 0x29 :jlte\n"
        "    case 0x5 :ret\n"
        "    case 0x18 :ret_or_stop\n"
        "    case 0x16 :grow_frame\n"
        "    case 0x15 :load_const\n"
        "    case 0x45 :load_i\n"
        "    case 0x14 :varargs_to_list\n"
        "    case 0x42 :splat_upvalues\n"
        "    case 0x17 :native\n"
        "    case 0x12 :copy\n"
        "    case 0x7 :move\n"
        "    case 0x6 :set_null\n"
        "    case 0x40 :cast_fixed_type\n"
        "    case 0x13 :make_func\n"
        "    case 0x41 :make_list\n"
        "    case 0x20 :add_i\n"
        "    case 0x21 :sub_i\n"
        "    case 0x22 :mult_i\n"
        "    case 0x23 :div_i\n"
        "    case 0x35 :push_state_frame\n"
        "    case 0x47 :push_state_frame_dkey\n"
        "    case 0x36 :pop_state_frame\n"
        "    case 0x46 :pop_discard_state_frame\n"
        "    case 0x37 :get_state_value\n"
        "    case 0x44 :save_state_value\n"
        "    case 0x11 :comment\n"
        "    else\n"
        "      error('opcode not found: ' opcode)\n"
        "\n"
        "def mopcode_from_int(int mopcode) -> Symbol\n"
        "  switch mopcode\n"
        "    case 1 :term_eval_start\n"
        "    case 2 :term_eval_end\n"
        "    case 3 :term_live\n"
        "    case 4 :major_block_start\n"
        "    case 5 :major_block_end\n"
        "    case 6 :minor_block_start\n"
        "    case 7 :minor_block_end\n"
        "    case 8 :state_key\n"
        "    case 9 :state_header\n"
        "    else\n"
        "      error('mopcode not found: ' mopcode)\n"
        "\n"
        "def Blob.slices(self, int sliceSize)\n"
        "  for b in range_by(0, self.size, sliceSize)\n"
        "    self.slice(b, sliceSize)\n"
        "\n"
        "def dump_ops(VM vm, Blob ops)\n"
        "  for addr, op in ops.slices(8)\n"
        "    op = read_op(op)\n"
        "    @op.set(:addr addr)\n"
        "\n"
        "    s = switch op.opcode\n"
        "      case :comment\n"
        "        msg = vm.get_bytecode_const(op.a)\n"
        "        str('# ' msg)\n"
        "      case :grow_frame\n"
        "        str('grow_frame ' op.a)\n"
        "      case :load_const\n"
        "        str('load_const slot: ' op.a ', value: ' vm.get_bytecode_const(op.b))\n"
        "      case :ret_or_stop\n"
        "        str('ret_or_stop')\n"
        "      else\n"
        "        str(op.opcode ' ' op.a ' ' op.b ' ' op.c)\n"
        "\n"
        "    @s.prepend(str('[' addr '] '))\n"
        "    print(s)\n"
        "\n"
        "def parse_ops(VM vm, Blob ops) -> List\n"
        "  for addr, op in ops.slices(8)\n"
        "    op = read_op(op)\n"
        "    @op.set(:addr addr)\n"
        "\n"
        "def func_ops(VM vm, Func func)\n"
        "  vm.precompile(func.block)\n"
        "  parse_ops(vm, vm.get_func_raw_ops(func))\n"
        "\n"
        "def dump(VM vm)\n"
        "  dump_ops(vm, vm.get_raw_ops)\n"
        "\n"
        "def dump_func(VM vm, Func func)\n"
        "  vm.precompile(func.block)\n"
        "  dump_ops(vm, vm.get_func_raw_ops(func))\n"
        ;

    if (strncmp(filename, "$builtins/bytecode_generated.ca", 31) == 0) return
        "\n"
        "struct Writer {\n"
        "    int curIndent\n"
        "    bool needsIndent\n"
        "    List output\n"
        "}\n"
        "\n"
        "def Writer.write(@self, any args :multiple)\n"
        "    if self.needsIndent\n"
        "        self.needsIndent = false\n"
        "        for i in 0..self.curIndent\n"
        "            self.output.append('    ')\n"
        "    self.output.append(args.join(''))\n"
        "def Writer.writeln(@self, any args :multiple)\n"
        "    self.write(args.join(''))\n"
        "    self.output.append(\"\\n\")\n"
        "    self.needsIndent = true\n"
        "def Writer.indent(@self)\n"
        "    self.curIndent += 1\n"
        "def Writer.unindent(@self)\n"
        "    self.curIndent -= 1\n"
        "def Writer.toString(self) -> String\n"
        "    return self.output.join(\"\")\n"
        "def Writer.save(self, String filename)\n"
        "    write_text_file(filename, self.toString)\n"
        "\n"
        "OpNames = [\n"
        "    'NoOp'\n"
        "    'Pause'\n"
        "    'SetNull'\n"
        "    'InlineCopy'\n"
        "    'PushBlock'\n"
        "    'FireNative'\n"
        "    'CaseBlock'\n"
        "    'ForLoop'\n"
        "    'ErrorNotEnoughInputs'\n"
        "    'ErrorTooManyInputs'\n"
        "]\n"
        "\n"
        "index = 0\n"
        "Ops = for op_name in OpNames\n"
        "    cname = concat('op_' op_name)\n"
        "    op = [index op_name cname]\n"
        "    index += 1\n"
        "    op\n"
        "\n"
        "header = make(Writer)\n"
        "header.writeln(\"// This file was generated using bytecode_generated.ca\")\n"
        "header.writeln('')\n"
        "\n"
        "impl = make(Writer)\n"
        "impl.writeln(\"// This file was generated using bytecode_generated.ca\")\n"
        "impl.writeln('')\n"
        "impl.writeln('#include \"common_headers.h\"')\n"
        "impl.writeln('')\n"
        "impl.writeln('#include \"bytecode_generated.h\"')\n"
        "impl.writeln('')\n"
        "\n"
        "header.writeln('#pragma once')\n"
        "header.writeln('')\n"
        "\n"
        "for op in Ops\n"
        "    header.writeln('const char ' op[2] ' = ' op[0] ';')\n"
        "\n"
        "header.writeln('')\n"
        "header.writeln('const char* bytecode_op_name(char op);')\n"
        "\n"
        "impl.writeln('const char* bytecode_op_name(char op)')\n"
        "impl.writeln('{')\n"
        "impl.indent\n"
        "impl.writeln('switch (op) {')\n"
        "for op in Ops\n"
        "    impl.writeln('case ' op[2] ': return \"' op[1] '\";')\n"
        "impl.writeln('default: return \"(unknown op)\";')\n"
        "impl.writeln('}')\n"
        "impl.unindent\n"
        "impl.writeln('}')\n"
        "\n"
        "header.save('src/bytecode_generated.h')\n"
        "impl.save('src/bytecode_generated.cpp')\n"
        ;

    if (strncmp(filename, "$builtins/code_change.ca", 24) == 0) return
        "\n"
        "\n"
        "def codechange_set_value(Term target, any newValue) -> List\n"
        "  [:set_value target newValue]\n"
        ;

    if (strncmp(filename, "$builtins/command_line.ca", 25) == 0) return
        "\n"
        "require stack_trace\n"
        "\n"
        "def run(Func func)\n"
        "  vm = make_vm(func)\n"
        "  vm.call\n"
        "\n"
        "  if vm.has_error\n"
        "    stack_trace.dump(vm)\n"
        ;

    if (strncmp(filename, "$builtins/cpp_codegen.ca", 24) == 0) return
        "\n"
        "struct CodeWriter\n"
        "{\n"
        "    int curIndent\n"
        "    bool needsIndent\n"
        "    List output\n"
        "}\n"
        "\n"
        "def CodeWriter.write(self :out, String s)\n"
        "    if self.needsIndent\n"
        "        self.needsIndent = false\n"
        "        for i in 0..self.curIndent\n"
        "            self.output.append('    ')\n"
        "    self.output.append(s)\n"
        "\n"
        "def CodeWriter.writeln(self :out, String line)\n"
        "    self.write(line)\n"
        "    self.output.append(\"\\n\")\n"
        "    self.needsIndent = true\n"
        "\n"
        "def CodeWriter.indent(self :out)\n"
        "    self.curIndent += 1\n"
        "def CodeWriter.unindent(self :out)\n"
        "    self.curIndent -= 1\n"
        "def CodeWriter.toString(self) -> String\n"
        "    return self.output.join(\"\")\n"
        "\n"
        "def CodeWriter.write_type_name(self :out, Term term)\n"
        "    self.write(term.get_type.name)\n"
        "\n"
        "def write_literal_function(CodeWriter w :out, Term term)\n"
        "\n"
        "    func = term.value -> Function\n"
        "\n"
        "    w.write(func.output(0).get_type.name)\n"
        "    w.write(' ')\n"
        "    w.write(func.name)\n"
        "    w.write('(')\n"
        "\n"
        "    inputs = for input in func.inputs\n"
        "        @input -> Term\n"
        "        str(input.get_type.name ' ' input.name)\n"
        "    w.write(inputs.join(', '))\n"
        "    w.writeln(')')\n"
        "    w.writeln('{')\n"
        "    w.indent()\n"
        "    write_block(&w, func.contents)\n"
        "    w.unindent()\n"
        "    w.writeln('}')\n"
        "\n"
        "def write_value_term(CodeWriter w :out, Term term)\n"
        "    v = term.value\n"
        "\n"
        "    if is_function(v)\n"
        "        write_literal_function(&w, term)\n"
        "    else\n"
        "        -- Value\n"
        "        w.write('const ')\n"
        "        w.write_type_name(term)\n"
        "        w.write(' ')\n"
        "        w.write(term.name)\n"
        "        w.write(' = ')\n"
        "        w.write(term.value -> to_string)\n"
        "        w.writeln(';')\n"
        "\n"
        "def write_block(CodeWriter w :out, Block block)\n"
        "\n"
        "    for term in block.terms\n"
        "        @term -> Term\n"
        "\n"
        "        if term.property('statement') != true\n"
        "            continue\n"
        "\n"
        "        if term.function == comment\n"
        "            commentStr = term.property('comment')\n"
        "            if commentStr == \"\"\n"
        "                w.writeln('')\n"
        "            else\n"
        "                w.writeln(str('// ' commentStr))\n"
        "        elif term.function == value\n"
        "            write_value_term(&w, term)\n"
        "\n"
        "        else\n"
        "            -- Normal function call\n"
        "            termName = term.name\n"
        "            if termName != \"\"\n"
        "                w.write(str(termName ' = '))\n"
        "            w.write(term.function.name)\n"
        "            w.write('(')\n"
        "            first = true\n"
        "            for input in term.inputs\n"
        "                if not(first)\n"
        "                    w.write(', ')\n"
        "                first = false\n"
        "                @input -> Term\n"
        "                if input.name != \"\"\n"
        "                    w.write(input.name)\n"
        "\n"
        "            w.write(')')\n"
        "            w.writeln(';')\n"
        "        \n"
        "\n"
        "def block_to_cpp_string(Block b) -> String\n"
        "    writer = make(CodeWriter)\n"
        "\n"
        "    write_block(&writer, b)\n"
        "\n"
        "    return writer.toString()\n"
        "\n"
        "test_block = {\n"
        "\n"
        "    def my_function(int a, int b) -> int\n"
        "        return a - b\n"
        "\n"
        "    a = 1\n"
        "    b = 2\n"
        "    -- this is a comment\n"
        "    add(a 3)\n"
        "    print(b)\n"
        "}\n"
        "\n"
        "block_to_cpp_string(block_ref(test_block)) -> print\n"
        ;

    if (strncmp(filename, "$builtins/Feedback.ca", 21) == 0) return
        "\n"
        "struct TargetSubElement {\n"
        "    List list\n"
        "}\n"
        "\n"
        "def TargetSubElement.top(self) -> List\n"
        "    if self.list.empty\n"
        "        null\n"
        "    else\n"
        "        self.list.last\n"
        "def TargetSubElement.pop(@self)\n"
        "    self.list.pop\n"
        "def TargetSubElement.append(@self, any subElement)\n"
        "    self.list.append(subElement)\n"
        "def TargetSubElement.empty(self) -> bool\n"
        "    self.list.empty\n"
        "\n"
        "struct Target {\n"
        "    Term term\n"
        "    TargetSubElement subElement\n"
        "}\n"
        "\n"
        "struct ConstraintSet {\n"
        "    Map byTerm\n"
        "}\n"
        "def ConstraintSet.setValue(@self, Term term, any value)\n"
        "    self.byTerm.set(term, value)\n"
        "def ConstraintSet.getKnowledge(@self, Term term) -> any\n"
        "    if self.byTerm.contains(term)\n"
        "        self.byTerm.get(term)\n"
        "    elif term.is_value\n"
        "        term.value\n"
        "    else\n"
        "        null\n"
        "\n"
        "struct Desire {\n"
        "    Symbol name\n"
        "    List args\n"
        "}\n"
        "\n"
        "struct Request {\n"
        "    Target target\n"
        "    ConstraintSet constraints\n"
        "    Desire desire\n"
        "}\n"
        "\n"
        "struct Failure {\n"
        "    Symbol name\n"
        "    List args\n"
        "}\n"
        "\n"
        "struct ChangeOperation {\n"
        "    Symbol name\n"
        "    List args\n"
        "}\n"
        "\n"
        "def advance_request(Request request) -> any\n"
        "\n"
        "    term = request.target.term\n"
        "    desireType = request.desire[0]\n"
        "\n"
        "    -- First dispatch on function\n"
        "\n"
        "    -- value() function\n"
        "    if term.function == block_ref(value)\n"
        "\n"
        "        -- Accept an :assign request\n"
        "        if request.desire.name == :assign\n"
        "            result = make(ChangeOperation)\n"
        "            result.name = :assign_value\n"
        "            result.args = request.desire.args\n"
        "            return result\n"
        "        else\n"
        "            return Failure([:FuncCantHandleRequest request])\n"
        "\n"
        "    -- copy() function, forward to input\n"
        "    elif term.function == block_ref(copy) or term.function == block_ref(output_placeholder)\n"
        "        \n"
        "        -- TODO, need to correct request.knowledge\n"
        "        request.target.term = term.input(0)\n"
        "        return request\n"
        "\n"
        "    -- get_index\n"
        "    elif term.function == block_ref(get_index)\n"
        "        -- TODO, handle requests that target the index value.\n"
        "        indexTerm = term.input(1)\n"
        "\n"
        "        -- Dispatch based on our knowledge of the index\n"
        "        knowledge = request.constraints.getKnowledge(indexTerm)\n"
        "\n"
        "        if knowledge == null\n"
        "            return Failure([:NotEnoughInformation request])\n"
        "\n"
        "        indexValue = term.value()\n"
        "\n"
        "        request.target.subElement.append([:index indexValue])\n"
        "        request.target.term = term.input(0)\n"
        "        return request\n"
        "\n"
        "    -- for-loop\n"
        "    elif term.function.name == 'for'\n"
        "\n"
        "        lastElement = request.target.subElement.top\n"
        "\n"
        "        if lastElement[0] != :index\n"
        "            -- Don't know how to target for if the subElement is not an index.\n"
        "            return Failure([:FuncCantHandleRequest request])\n"
        "\n"
        "        forContents = request.target.term.contents\n"
        "        loopIndex = forContents.input(1)\n"
        "        outputTerm = forContents.output(0)\n"
        "\n"
        "        newRequest = request\n"
        "        newRequest.target.subElement.pop\n"
        "        newRequest.constraints.setValue(loopIndex lastElement[1])\n"
        "        newRequest.target.term = outputTerm\n"
        "\n"
        "        return newRequest\n"
        "\n"
        "    return :DidNotUnderstand\n"
        "\n"
        "def resolve_request(Request request) -> any\n"
        "\n"
        "    print('trying to resolve: ' request)\n"
        "    \n"
        "    -- TODO, use unbounded loop here when available\n"
        "    max_iterations = 100\n"
        "    for i in 0..max_iterations\n"
        "\n"
        "        advanced = advance_request(request)\n"
        "\n"
        "        print('advanced: ' advanced)\n"
        "        \n"
        "        if type(advanced) != Request\n"
        "            return advanced\n"
        "\n"
        "        request = advanced\n"
        "\n"
        "    return :TooManyIterations\n"
        ;

    if (strncmp(filename, "$builtins/FeedbackTest.ca", 25) == 0) return
        "\n"
        "import Feedback\n"
        "\n"
        "def mySample()\n"
        "    a = 1\n"
        "\n"
        "    mylist = [a]\n"
        "    for a in @mylist\n"
        "        a = a\n"
        "\n"
        "    b = mylist[0]\n"
        "\n"
        "\n"
        "br = block_ref(mySample)\n"
        "br.dump\n"
        "--print('a is ' br.find_term(\"a\"))\n"
        "--print('b is ' br.find_term(\"b\"))\n"
        "\n"
        "request = make(Request)\n"
        "request.target.term = br.find_term(\"b\")\n"
        "request.desire = [:assign [2]]\n"
        "\n"
        "req = resolve_request(request)\n"
        ;

    if (strncmp(filename, "$builtins/GenBindingsCpp.ca", 27) == 0) return
        "\n"
        "struct CodeWriter\n"
        "{\n"
        "    int curIndent\n"
        "    bool needsIndent\n"
        "    List output\n"
        "}\n"
        "\n"
        "def CodeWriter.write(@self, String s)\n"
        "    if self.needsIndent\n"
        "        self.needsIndent = false\n"
        "        for i in 0..self.curIndent\n"
        "            self.output.append('    ')\n"
        "    self.output.append(s)\n"
        "\n"
        "def CodeWriter.writeln(@self, String line)\n"
        "    self.write(line)\n"
        "    self.output.append(\"\\n\")\n"
        "    self.needsIndent = true\n"
        "\n"
        "def CodeWriter.indent(@self)\n"
        "    self.curIndent += 1\n"
        "def CodeWriter.unindent(@self)\n"
        "    self.curIndent -= 1\n"
        "\n"
        "def CodeWriter.toString(self) -> String\n"
        "    return self.output.join(\"\")\n"
        "\n"
        "def circa_name_to_c_name(String s) -> String\n"
        "    result = \"\"\n"
        "\n"
        "    for c in s.characters\n"
        "        if c == '.'\n"
        "            result.append('__')\n"
        "        elif c == ':'\n"
        "            result.append('__')\n"
        "        else\n"
        "            result.append(c)\n"
        "\n"
        "    return result\n"
        "\n"
        "def write_function(CodeWriter writer :out, Function func, String cname :out)\n"
        "    writer.write('void ')\n"
        "    cname = circa_name_to_c_name(func.name)\n"
        "    writer.write(cname)\n"
        "    writer.write('(Stack* stack)')\n"
        "    writer.writeln('')\n"
        "    writer.writeln('{')\n"
        "    writer.indent()\n"
        "\n"
        "    -- Write each input\n"
        "    index = 0\n"
        "    for Term input in func.inputs\n"
        "        name = input.name\n"
        "\n"
        "        -- check if this is a #anonymous name. If so, use the type name, lower cased.\n"
        "        if name.char_at(0) == '#' or name == '_'\n"
        "            name = input.get_type.name.to_camel_case\n"
        "\n"
        "        t = input.get_type\n"
        "        if t == String\n"
        "            writer.write('const char* ')\n"
        "            writer.write(name)\n"
        "            writer.write(str(' = circa_string(circa_input(stack, ' index '))'))\n"
        "            writer.writeln(';')\n"
        "        elif t == int\n"
        "            writer.write('int ')\n"
        "            writer.write(name)\n"
        "            writer.write(str(' = circa_int(circa_input(stack, ' index '))'))\n"
        "            writer.writeln(';')\n"
        "        elif t == number\n"
        "            writer.write('float ')\n"
        "            writer.write(name)\n"
        "            writer.write(str(' = circa_float(circa_input(stack, ' index '))'))\n"
        "            writer.writeln(';')\n"
        "        else\n"
        "            writer.write('Value* ')\n"
        "            writer.write(name)\n"
        "            writer.write(str(' = circa_input(stack, ' index ')'))\n"
        "            writer.writeln(';')\n"
        "\n"
        "        index += 1\n"
        "\n"
        "    -- Function body\n"
        "    for Term statement in func.contents.statements\n"
        "        writer.writeln(statement.to_source_string)\n"
        "\n"
        "    index = 0\n"
        "    for Term input in func.outputs\n"
        "\n"
        "        if input.get_type == void\n"
        "            continue\n"
        "\n"
        "        if index == 0\n"
        "            name = 'output'\n"
        "        else\n"
        "            name = str('output_' index)\n"
        "\n"
        "        writer.write('Value* ')\n"
        "        writer.write(name)\n"
        "        writer.write(str(' = circa_output(stack, ' index ')'))\n"
        "        writer.writeln(';')\n"
        "\n"
        "        index += 1\n"
        "\n"
        "        \n"
        "    writer.unindent()\n"
        "    writer.writeln('}')\n"
        "\n"
        "def write_bindings(Block block) -> String\n"
        "\n"
        "    writer = make(CodeWriter)\n"
        "\n"
        "    writer.writeln('#include \"circa/circa.h\"')\n"
        "    writer.writeln('')\n"
        "\n"
        "    bindings = []\n"
        "\n"
        "    for Function func in block.functions\n"
        "        cname = \"\"\n"
        "        write_function(&writer, func, &cname)\n"
        "\n"
        "        bindings.append([func, cname])\n"
        "\n"
        "    -- Import list\n"
        "    writer.writeln('static const caFunctionBinding IMPORTS[] = {')\n"
        "    writer.indent()\n"
        "    for binding in bindings\n"
        "        func = binding[0] -> Function\n"
        "        cname = binding[1] -> String\n"
        "\n"
        "        writer.writeln(str('{\"' func.name '\", ' cname '},'))\n"
        "    writer.writeln(str('{0, 0}'))\n"
        "    writer.unindent()\n"
        "    writer.writeln('};')\n"
        "\n"
        "    -- Installation function\n"
        "    writer.writeln(\"void Install_xxx(caBlock* block)\")\n"
        "    writer.writeln(\"{\")\n"
        "    writer.indent()\n"
        "    writer.writeln(\"circa_install_function_list(block, IMPORTS);\")\n"
        "    writer.unindent()\n"
        "    writer.writeln(\"}\")\n"
        "\n"
        "    return writer.toString\n"
        "   \n"
        "def load_and_write(String filename) -> String\n"
        "    script = load_script(filename)\n"
        "    out = write_bindings(script)\n"
        "    return out\n"
        ;

    if (strncmp(filename, "$builtins/indent_writer.ca", 26) == 0) return
        "\n"
        "struct IndentWriter {\n"
        "    int curIndent\n"
        "    bool needsIndent\n"
        "    List output\n"
        "}\n"
        "\n"
        "def IndentWriter.write(self, args :multiple)\n"
        "    if self.needsIndent\n"
        "        self.needsIndent = false\n"
        "        for i in 0..self.curIndent\n"
        "            @self.output.append(' ')\n"
        "    @self.output.append(str.apply(args))\n"
        "    self\n"
        "\n"
        "def IndentWriter.writeln(self, args :multiple)\n"
        "    @self.write(str.apply(args))\n"
        "    @self.output.append(\"\\n\")\n"
        "    self.needsIndent = true\n"
        "    self\n"
        "\n"
        "def IndentWriter.indent(self)\n"
        "    self.curIndent += 1\n"
        "    self\n"
        "def IndentWriter.unindent(self)\n"
        "    self.curIndent -= 1\n"
        "    self\n"
        "\n"
        "def IndentWriter.toString(self) -> String\n"
        "    self.output.join(\"\")\n"
        "\n"
        "def new() -> IndentWriter\n"
        "    IndentWriter.make\n"
        ;

    if (strncmp(filename, "$builtins/json.ca", 17) == 0) return
        "\n"
        "def is_digit(String s)\n"
        "  if s.length < 1\n"
        "    return false\n"
        "  (s.char_code >= '0'.char_code) and (s.char_code <= '9'.char_code)\n"
        "\n"
        "struct Reader {\n"
        "  String str\n"
        "  int pos\n"
        "  any last\n"
        "}\n"
        "\n"
        "def Reader.empty(self) -> bool\n"
        "  self.pos >= self.str.length\n"
        "\n"
        "def Reader.next(self) -> String\n"
        "  self.str.char_at(self.pos)\n"
        "\n"
        "def Reader.advance(@self)\n"
        "  self.pos += 1\n"
        "\n"
        "def Reader.consumeWhitespace(@self)\n"
        "  while self.next == ' '\n"
        "    @self.advance\n"
        "\n"
        "  self\n"
        "\n"
        "def Reader.matches(self, str) -> bool\n"
        "  self.str.substr(self.pos, str.length) == str\n"
        "\n"
        "def Reader.consume(@self, str)\n"
        "  self.pos += str.length\n"
        "\n"
        "def Reader.parse_string(@self) -> Reader\n"
        "  @self.advance\n"
        "\n"
        "  p = self.pos\n"
        "  while self.next != '\"'\n"
        "    if self.empty\n"
        "      error(\"Unexpected end of string, looking for: \\\"\")\n"
        "\n"
        "    -- TODO: handle escapes and unicode\n"
        "    @self.advance\n"
        "\n"
        "  result = self.str.slice(p, self.pos)\n"
        "  @self.advance\n"
        "  self.last = result\n"
        "\n"
        "def Reader.parse_value(@self) -> Reader\n"
        "  @self.consumeWhitespace\n"
        "\n"
        "  result = null\n"
        "\n"
        "  if self.next == '['\n"
        "    @self.advance\n"
        "    @self.consumeWhitespace\n"
        "    \n"
        "    result = []\n"
        "\n"
        "    first = true\n"
        "    while self.next != ']'\n"
        "      @self.consumeWhitespace\n"
        "      if self.empty\n"
        "        error(\"Unexpected end of string, looking for: ] or ,\")\n"
        "\n"
        "      if not first\n"
        "        if self.next != ','\n"
        "          error(\"Expected: ,\" self)\n"
        "        @self.advance\n"
        "        @self.consumeWhitespace\n"
        "\n"
        "      @self.parse_value\n"
        "      @result.append(self.last)\n"
        "      first = false\n"
        "\n"
        "      @self.consumeWhitespace\n"
        "\n"
        "    @self.advance\n"
        "\n"
        "  if self.next == '{'\n"
        "    @self.advance\n"
        "    @self.consumeWhitespace\n"
        "\n"
        "    result = Map.make\n"
        "\n"
        "    first = true\n"
        "    while self.next != '}'\n"
        "      @self.consumeWhitespace\n"
        "      if self.empty\n"
        "        error(\"Unexpected end of string, looking for: } or ,\")\n"
        "\n"
        "      if not first\n"
        "        if self.next != ','\n"
        "          error('Expected ,' self)\n"
        "        @self.advance\n"
        "        @self.consumeWhitespace\n"
        "\n"
        "      @self.parse_string\n"
        "      key = self.last\n"
        "      @self.consumeWhitespace\n"
        "\n"
        "      if self.next != ':'\n"
        "        error('Expected :')\n"
        "      @self.advance\n"
        "      @self.consumeWhitespace\n"
        "\n"
        "      @self.parse_value\n"
        "      @result.set(key,self.last)\n"
        "      first = false\n"
        "\n"
        "    @self.advance\n"
        "\n"
        "  elif self.matches(\"true\")\n"
        "    @self.consume(\"true\")\n"
        "    result = true\n"
        "\n"
        "  elif self.matches(\"false\")\n"
        "    @self.consume(\"false\")\n"
        "    result = false\n"
        "\n"
        "  elif self.matches(\"null\")\n"
        "    @self.consume(\"null\")\n"
        "    result = null\n"
        "\n"
        "  elif is_digit(self.next) or self.next == '-'\n"
        "\n"
        "    p = self.pos\n"
        "\n"
        "    @self.advance\n"
        "    while is_digit(self.next)\n"
        "      @self.advance\n"
        "\n"
        "    foundDot = false\n"
        "    if self.next == \".\"\n"
        "      foundDot = true\n"
        "      @self.advance\n"
        "\n"
        "      while is_digit(self.next)\n"
        "        @self.advance\n"
        "\n"
        "    -- TODO: exponent notation\n"
        "\n"
        "    result = self.str.slice(p, self.pos)\n"
        "    assert(is_string(result))\n"
        "\n"
        "    if foundDot\n"
        "      @result.to_number\n"
        "    else\n"
        "      @result.to_int\n"
        "\n"
        "  elif self.next == '\"'\n"
        "    @self.parse_string\n"
        "    result = self.last\n"
        "\n"
        "  self.last = result\n"
        "\n"
        "def parse(String str) -> any\n"
        "  reader = Reader.make(str 0)\n"
        "  @reader.parse_value\n"
        "  return reader.last\n"
        "\n"
        "def String.quote(self) -> String\n"
        "  -- TODO: insert escapes as needed\n"
        "  str('\"' self '\"')\n"
        "\n"
        "def write(val) -> String\n"
        "  if is_list(val)\n"
        "    str('[' (for el in val { write(el) }).join(', ') ']')\n"
        "  elif is_map(val)\n"
        "    str('{' (for k in val.keys { str(k.quote, \": \", write(val.get(k))) }).join(', ') '}')\n"
        "  elif is_string(val)\n"
        "    val.quote\n"
        "  else\n"
        "    str(val)\n"
        ;

    if (strncmp(filename, "$builtins/matrix.ca", 19) == 0) return
        "\n"
        "struct Mat2 {\n"
        "  List col0\n"
        "  List col1\n"
        "}\n"
        "struct Mat3 {\n"
        "  List col0\n"
        "  List col1\n"
        "  List col2\n"
        "}\n"
        "struct Mat4 {\n"
        "  List col0\n"
        "  List col1\n"
        "  List col2\n"
        "  List col3\n"
        "}\n"
        "\n"
        "def make_mat3() -> Mat3\n"
        "  Mat3.make([1.0 0.0 0.0] [0.0 1.0 0.0] [0.0 0.0 1.0])\n"
        "\n"
        "def make_scale3(Vec2 vec) -> Mat3\n"
        "  Mat3.make([vec.x 0.0 0.0] [0.0 vec.y 0.0] [0.0 0.0 1.0])\n"
        "\n"
        "def make_translate3(Vec2 vec) -> Mat3\n"
        "  Mat3.make([1.0 0.0 0.0] [0.0 1.0 0.0] [vec.x vec.y 1.0])\n"
        "\n"
        "def col3_mult(List left, List right) -> number\n"
        "  left[0] * right[0] + left[1] * right[1] + left[2] * right[2]\n"
        "\n"
        "def Mat3.mult(self, Mat3 rhs) -> Mat3\n"
        "  lrow0 = [self.col0[0] self.col1[0] self.col2[0]]\n"
        "  lrow1 = [self.col0[1] self.col1[1] self.col2[1]]\n"
        "  lrow2 = [self.col0[2] self.col1[2] self.col2[2]]\n"
        "\n"
        "  rcol0 = rhs.col0\n"
        "  rcol1 = rhs.col1\n"
        "  rcol2 = rhs.col2\n"
        "\n"
        "  Mat3.make([col3_mult(lrow0 rcol0) col3_mult(lrow1 rcol0) col3_mult(lrow2 rcol0)]\n"
        "    [col3_mult(lrow0 rcol1) col3_mult(lrow1 rcol1) col3_mult(lrow2 rcol1)]\n"
        "    [col3_mult(lrow0 rcol2) col3_mult(lrow1 rcol2) col3_mult(lrow2 rcol2)])\n"
        "\n"
        "def Mat3.scale(self, Vec2 vec) -> Mat3\n"
        "  self.mult(make_scale3(vec))\n"
        "\n"
        "def Mat3.translate(self, Vec2 vec) -> Mat3\n"
        "  self.mult(make_translate3(vec))\n"
        ;

    if (strncmp(filename, "$builtins/socket.ca", 19) == 0) return
        "\n"
        "struct Server {\n"
        "    native_ptr native\n"
        "}\n"
        "\n"
        "struct Connection {\n"
        "    native_ptr native\n"
        "}\n"
        "\n"
        "struct ServerRequest {\n"
        "    Connection conn\n"
        "    any data\n"
        "}\n"
        "\n"
        "struct WebsockServer {\n"
        "    native_ptr native\n"
        "}\n"
        "\n"
        "def ServerRequest.reply(self, msg)\n"
        "  self.conn.send(msg)\n"
        "\n"
        "def make_server(String ip, int port, Symbol t) -> Server\n"
        "def make_tcp_server(String ip, int port) -> Server\n"
        "  make_server(ip port :tcp)\n"
        "def make_websock_server(String ip, int port) -> Server\n"
        "  make_server(ip port :websock)\n"
        "\n"
        "def Server.connections(self) -> List\n"
        "\n"
        "def Server.listen(self) -> List\n"
        "  -- returns list of ServerRequest\n"
        "  reqs = []\n"
        "  for Connection c in self.connections\n"
        "    for msg in c.receive\n"
        "      @reqs.append(ServerRequest.make(c msg))\n"
        "  reqs\n"
        "\n"
        "def make_tcp_client(String ip, int port) -> Connection\n"
        "def Connection.send(self, any msg)\n"
        "def Connection.outgoing_queue(self) -> List\n"
        "def Connection.receive(self) -> List\n"
        "def Connection.is_open(self) -> bool\n"
        ;

    if (strncmp(filename, "$builtins/source_repro.ca", 25) == 0) return
        "\n"
        "struct SourceRepro {\n"
        "  List phrases\n"
        "}\n"
        "\n"
        "struct Phrase {\n"
        "  Symbol type\n"
        "  any val\n"
        "}\n"
        "\n"
        "def Phrase.term(self) -> Term\n"
        "  self.val\n"
        "\n"
        "def Phrase.block(self) -> Block\n"
        "  self.val\n"
        "\n"
        "def Phrase.text(self) -> String\n"
        "  switch\n"
        "    case type(self.val) == String\n"
        "      self.val\n"
        "    case self.type == :name_ref\n"
        "      self.term.name\n"
        "    case self.type == :block_start or self.type == :block_end\n"
        "      ''\n"
        "    else\n"
        "      self.val | to_string\n"
        "\n"
        "def new()\n"
        "  SourceRepro.make([] 1 0)\n"
        "\n"
        "def Term.is_neg(term)\n"
        "  term.function == neg.block\n"
        "def Term.is_def_function_decl(term)\n"
        "  term.function == function_decl.block and not term.property_opt(:Syntax_AnonFunction false)\n"
        "def Term.is_anon_function_decl(term)\n"
        "  term.function == function_decl.block and term.property_opt(:Syntax_AnonFunction false)\n"
        "def Term.is_struct_decl(term)\n"
        "  term.is_value and is_type(term.value)\n"
        "def Term.is_require(term)\n"
        "  term.function.name == 'require'\n"
        "def Term.is_declared_state(term)\n"
        "  term.function == _declared_state.block\n"
        "def Term.is_get_index(term)\n"
        "  term.function == get_index.block\n"
        "def Term.is_set_with_selector(term)\n"
        "  term.function == set_with_selector.block\n"
        "def Term.is_for_loop(term)\n"
        "  term.function.name == 'for'\n"
        "def Term.is_while_loop(term)\n"
        "  term.function.name == 'while'\n"
        "def Term.is_if_block(term)\n"
        "  term.function.name == 'if'\n"
        "def Term.is_switch_block(term)\n"
        "  term.function.name == 'switch'\n"
        "def Term.is_copy(term)\n"
        "  term.function == copy.block\n"
        "def Term.is_nonlocal(term)\n"
        "  term.function == _nonlocal.block\n"
        "def Term.is_continue(term)\n"
        "  term.function.name == 'continue'\n"
        "def Term.is_break(term)\n"
        "  term.function.name == 'break'\n"
        "def Term.is_discard(term)\n"
        "  term.function.name == 'discard'\n"
        "def Term.is_syntax_error(term)\n"
        "  term.function == syntax_error.block\n"
        "\n"
        "def break_apart_newlines(String str) -> List\n"
        "  newlineFound, loc = str.index_of('\\n')\n"
        "\n"
        "  if newlineFound\n"
        "    [str.substr(0, loc), str.substr(loc, 1)].concat(break_apart_newlines(str.substr(loc+1, -1)))\n"
        "  else\n"
        "    [str]\n"
        "\n"
        "def SourceRepro.append_phrase(@self, Symbol type, val)\n"
        "  phrase = Phrase.make(type val)\n"
        "  @self.phrases.append(phrase)\n"
        "\n"
        "def SourceRepro.phrase(@self, Symbol type, val)\n"
        "  if type == :ws\n"
        "    for s in break_apart_newlines(val)\n"
        "      if s == ''\n"
        "        discard\n"
        "      @self.append_phrase(:ws s)\n"
        "    -- language defect: this 'self' shouldn't be necessary:\n"
        "    self\n"
        "  else\n"
        "    @self.append_phrase(type val)\n"
        "\n"
        "def SourceRepro.neg(self, Term term) -> SourceRepro\n"
        "  @self.phrase(:operator '-')\n"
        "  @self.term_input(term 0)\n"
        "\n"
        "def SourceRepro.literal_color(self, Term term) -> SourceRepro\n"
        "  color = term.value\n"
        "  hasAlpha = color.a != 1.0\n"
        "  digits = term.property_opt(:Syntax_ColorFormat 6)\n"
        "  digitsPerChannel = cond(digits == 6 or digits == 8, 2, 1)\n"
        "  specifyAlpha = hasAlpha or digits == 4 or digits == 8\n"
        "  specifyColorCount = cond(specifyAlpha, 4, 3)\n"
        "\n"
        "  out = ['#']\n"
        "  for c in 0..specifyColorCount\n"
        "    if digitsPerChannel == 1\n"
        "      @out.append(floor(color[c] * 15.999).to_hex_string)\n"
        "    else\n"
        "      mod255 = floor(color[c] * 255)\n"
        "      @out.append((mod255 // 0x10).to_hex_string)\n"
        "      @out.append((mod255 % 0x10).to_hex_string)\n"
        "\n"
        "  @self.phrase(:value out.join(''))\n"
        "\n"
        "def SourceRepro.literal_int(self, Term term) -> SourceRepro\n"
        "  if term.property_opt(:Syntax_IntegerFormat '') == 'hex'\n"
        "    @self.phrase(:value str('0x' term.value.to_hex_string))\n"
        "  else\n"
        "    @self.phrase(:value term.value)\n"
        "  self\n"
        "\n"
        "def SourceRepro.term_value(self, Term term) -> SourceRepro\n"
        "  @self.name_binding_source(term)\n"
        "  if type(term.value) == Color\n"
        "    return self.literal_color(term)\n"
        "  if type(term.value) == int\n"
        "    return self.literal_int(term)\n"
        "  if is_string(term.value)\n"
        "    if term.has_property(:Syntax_OriginalFormat)\n"
        "      return self.phrase(:value term.property(:Syntax_OriginalFormat))\n"
        "\n"
        "    quote = term.property(:Syntax_QuoteType)\n"
        "    startQuote = quote\n"
        "    endQuote = quote\n"
        "    if quote == '<'\n"
        "      startQuote = '<<<'\n"
        "      endQuote = '>>>'\n"
        "\n"
        "    @self.phrase(:value str(startQuote term.value endQuote))\n"
        "\n"
        "  elif is_number(term.value)\n"
        "    if term.has_property(:Syntax_OriginalFormat)\n"
        "      return self.phrase(:value term.property(:Syntax_OriginalFormat))\n"
        "\n"
        "  else\n"
        "    @self.phrase(:value to_string(term.value))\n"
        "\n"
        "  self\n"
        "\n"
        "def SourceRepro.require_statement(self, Term term) -> SourceRepro\n"
        "  if term.property_opt(:Syntax_Require false)\n"
        "    @self.phrase(:text 'require ')\n"
        "    @self.phrase(:name term.name)\n"
        "  elif term.property_opt(:Syntax_Import false)\n"
        "    @self.phrase(:text 'import ')\n"
        "    @self.term_input(term 0)\n"
        "  else\n"
        "    @self.term_default_format(term)\n"
        "  self\n"
        "\n"
        "def SourceRepro.anon_function_decl(self, Term term) -> SourceRepro\n"
        "  inputs = term.contents.inputs\n"
        "\n"
        "  if inputs != []\n"
        "    @self.phrase(:text '(')\n"
        "\n"
        "    for i,input in inputs\n"
        "      if i > 0\n"
        "        @self.phrase(:text ',')\n"
        "\n"
        "      @self.phrase(:name input.name)\n"
        "\n"
        "    @self.phrase(:text ') ')\n"
        "\n"
        "  @self.phrase(:text '->')\n"
        "  \n"
        "  @self.block_pre(term)\n"
        "  @self.block_contents(term.contents)\n"
        "  @self.block_post(term)\n"
        "\n"
        "def SourceRepro.function_decl(self, Term term) -> SourceRepro\n"
        "  @self.phrase(:text \"def \")\n"
        "  @self.phrase(:name term.name)\n"
        "  @self.phrase(:ws term.property_opt(:Syntax_PostNameWs ''))\n"
        "  @self.phrase(:ws term.property_opt(:Syntax_Properties ''))\n"
        "  @self.phrase(:text \"(\")\n"
        "\n"
        "  inputs = term.contents.inputs.filter((term) -> not term.property_opt(:HiddenInput false) )\n"
        "\n"
        "  for i,input in inputs\n"
        "    if input.property_opt(:State false)\n"
        "      @self.phrase(:text \"state \")\n"
        "\n"
        "    if i > 0\n"
        "      @self.phrase(:text \", \")\n"
        "\n"
        "    if input.property_opt(:Syntax_ExplicitType true)\n"
        "      @self.phrase(:text input.get_type.name)\n"
        "      @self.phrase(:ws \" \")\n"
        "\n"
        "    if input.property_opt(:Syntax_RebindSymbol false)\n"
        "      @self.phrase(:text \"@\")\n"
        "\n"
        "    @self.phrase(:name input.name)\n"
        "\n"
        "    if input.property_opt(:Output false) and not input.property_opt(:Syntax_RebindSymbol false)\n"
        "      @self.phrase(:text \" :out\")\n"
        "\n"
        "    if input.property_opt(:Meta false)\n"
        "      @self.phrase(:text \" :meta\")\n"
        "\n"
        "    if input.property_opt(:Rebind false)\n"
        "      @self.phrase(:text \" :rebind\")\n"
        "\n"
        "    if input.property_opt(:Multiple false)\n"
        "      @self.phrase(:text \" :multiple\")\n"
        "\n"
        "    first = false\n"
        "\n"
        "  @self.phrase(:text ')')\n"
        "\n"
        "  if term.property_opt(:Syntax_ExplicitType false)\n"
        "    @self.phrase(:ws term.property_opt(:Syntax_WhitespacePreColon ''))\n"
        "    @self.phrase(:text '->')\n"
        "    @self.phrase(:ws term.property_opt(:Syntax_WhitespacePostColon ''))\n"
        "\n"
        "    outputs = term.contents.outputs.filter((term) -> not term.property_opt(:Hidden false))\n"
        "\n"
        "    if outputs.length > 1\n"
        "      @self.phrase(:text \"(\")\n"
        "\n"
        "    first = true\n"
        "    for output in outputs\n"
        "      if not first\n"
        "        @self.phrase(:text \", \")\n"
        "      first = false\n"
        "\n"
        "      @self.phrase(:name output.get_type.name)\n"
        "\n"
        "    if outputs.length > 1\n"
        "      @self.phrase(:text \")\")\n"
        "\n"
        "  @self.block_pre(term)\n"
        "  @self.block_contents(term.contents)\n"
        "  @self.block_post(term)\n"
        "\n"
        "  self\n"
        "\n"
        "def SourceRepro.struct_decl(self, Term term) -> SourceRepro\n"
        "  @self.phrase(:text \"struct \")\n"
        "  @self.phrase(:name term.name)\n"
        "\n"
        "  if term.has_property(:Syntax_TypeMagicSymbol)\n"
        "    @self.phrase(:text \" = \")\n"
        "    @self.phrase(:text term.property(:Syntax_TypeMagicSymbol))\n"
        "\n"
        "  if term.property_opt(:Syntax_NoBrackets false)\n"
        "    return self\n"
        "\n"
        "  @self.phrase(:ws term.property_opt(:Syntax_PreLBracketWs ' '))\n"
        "  @self.phrase(:text '{')\n"
        "  @self.phrase(:ws term.property_opt(:Syntax_PostLBracketWs ' '))\n"
        "\n"
        "  for field in term.contents.terms\n"
        "    if field.is_comment\n"
        "      @self.phrase(:comment field.property(:Comment))\n"
        "      @self.phrase(:ws field.property_opt(:Syntax_LineEnding ''))\n"
        "    elif field.property_opt(:FieldAccessor false)\n"
        "      @self.phrase(:ws field.property_opt(:Syntax_PreWs ''))\n"
        "      @self.phrase(:name field.contents.output_placeholder(0).get_type.name)\n"
        "      @self.phrase(:ws field.property_opt(:Syntax_PostNameWs ' '))\n"
        "      @self.phrase(:name field.name)\n"
        "      @self.phrase(:ws field.property_opt(:Syntax_PostWs ''))\n"
        "\n"
        "  @self.phrase(:ws term.property_opt(:Syntax_PreRBracketWs ''))\n"
        "  @self.phrase(:text '}')\n"
        "\n"
        "def SourceRepro.get_index_brackets(self, Term term) -> SourceRepro\n"
        "  @self.name_binding_source(term)\n"
        "  @self.term_input(term 0)\n"
        "  @self.phrase(:text '[')\n"
        "  @self.term_input_inner(term 1)\n"
        "  @self.phrase(:text ']')\n"
        "\n"
        "def SourceRepro.selector(self, Term term) -> SourceRepro\n"
        "  for i in 0..(term.num_inputs)\n"
        "    input = term.input(i)\n"
        "\n"
        "    if input.is_value and is_string(input.value)\n"
        "      @self.phrase(:text '.')\n"
        "      @self.phrase(:identifier input.value)\n"
        "    else\n"
        "      @self.phrase(:text '[')\n"
        "      @self.term_input_inner(term i)\n"
        "      @self.phrase(:text ']')\n"
        "\n"
        "  self\n"
        "\n"
        "def SourceRepro.set_with_selector(self, Term term) -> SourceRepro\n"
        "  @self.term_input_inner(term 0)\n"
        "  @self.selector(term.input(1))\n"
        "  @self.phrase(:text term.property_opt(:Syntax_PreEqualsSpace ''))\n"
        "  if term.has_property(:Syntax_RebindOperator)\n"
        "    @self.phrase(:text term.property(:Syntax_RebindOperator))\n"
        "    @self.phrase(:text term.property_opt(:Syntax_PostEqualsSpace ''))\n"
        "    @self.term_input(term.input(2) 1)\n"
        "  else\n"
        "    @self.phrase(:text '=')\n"
        "    @self.phrase(:ws term.property_opt(:Syntax_PostEqualsSpace ''))\n"
        "    @self.term_input_inner(term 2)\n"
        "  self\n"
        "\n"
        "def SourceRepro.return_statement(self, Term term) -> SourceRepro\n"
        "  @self.phrase(:text 'return')\n"
        "  @self.phrase(:ws term.property_opt(:Syntax_PostKeywordWs ' '))\n"
        "  for inputIndex in 0..(term.num_inputs)\n"
        "    if inputIndex != 0\n"
        "      @self.phrase(:text ', ')\n"
        "    @self.term_input_inner(term inputIndex)\n"
        "  self\n"
        "\n"
        "def SourceRepro.declared_state(self, Term term) -> SourceRepro\n"
        "  if not term.property_opt(:Syntax_StateKeyword false)\n"
        "    return self.term_default_format(term)\n"
        "\n"
        "  @self.phrase(:text 'state ')\n"
        "  if term.has_property(:Syntax_ExplicitType)\n"
        "    @self.phrase(:name term.property(:Syntax_ExplicitType))\n"
        "    @self.phrase(:text ' ')\n"
        "  @self.phrase(:name term.name)\n"
        "\n"
        "  if not term.input(1).is_null\n"
        "    @self.phrase(:text ' = ')\n"
        "    initializer = term.input(1).contents.output(0)\n"
        "    if initializer.property_opt(:Hidden false)\n"
        "      initializer = initializer.input(0)\n"
        "    @self.term(initializer)\n"
        "  self\n"
        "\n"
        "def SourceRepro.for_loop(self, Term term) -> SourceRepro\n"
        "  @self.phrase(:text 'for ')\n"
        "  index = term.contents.get_loop_index\n"
        "\n"
        "  if index.has_name\n"
        "    @self.phrase(:name index.name)\n"
        "    @self.phrase(:text ', ')\n"
        "\n"
        "  if term.has_property(:Syntax_ExplicitType)\n"
        "    @self.phrase(:name term.property(:Syntax_ExplicitType))\n"
        "    @self.phrase(:ws ' ')\n"
        "  @self.phrase(:name term.contents.get_iterator.name)\n"
        "  @self.phrase(:text ' in ')\n"
        "  if term.property_opt(:ModifyList false)\n"
        "    @self.phrase(:text '@')\n"
        "  @self.term_input(term 0)\n"
        "\n"
        "  @self.block_pre(term)\n"
        "  @self.block_contents(term.contents)\n"
        "  @self.block_post(term)\n"
        "\n"
        "def SourceRepro.while_loop(self, Term term) -> SourceRepro\n"
        "  @self.name_binding_source(term)\n"
        "  @self.phrase(:text 'while ')\n"
        "  @self.term_input(term.contents.find_while_condition, 0)\n"
        "  @self.phrase(:ws term.property_opt(:Syntax_LineEnding ''))\n"
        "\n"
        "  @self.block_pre(term)\n"
        "  @self.block_contents(term.contents)\n"
        "  @self.block_post(term)\n"
        "\n"
        "  @self.phrase(:ws term.property_opt(:Syntax_WhitespaceBeforeEnd ''))\n"
        "\n"
        "def SourceRepro.if_block(self, Term term) -> SourceRepro\n"
        "  @self.name_binding_source(term)\n"
        "  cases = term.contents.if_block_cases.filter((term) -> not term.property_opt(:Hidden false))\n"
        "  for i,caseTerm in cases\n"
        "    @self.phrase(:ws caseTerm.property_opt(:Syntax_PreWs ''))\n"
        "\n"
        "    if caseTerm.name != 'else'\n"
        "      if i == 0\n"
        "        @self.phrase(:text 'if ')\n"
        "      else\n"
        "        @self.phrase(:text 'elif ')\n"
        "\n"
        "      condition = caseTerm.contents.case_find_condition\n"
        "      assert(not condition.is_null)\n"
        "      @self.term_input(condition 0)\n"
        "    else\n"
        "      @self.phrase(:text 'else')\n"
        "    @self.phrase(:ws caseTerm.property_opt(:Syntax_LineEnding ''))\n"
        "\n"
        "    @self.block_pre(caseTerm)\n"
        "    @self.block_contents(caseTerm.contents)\n"
        "    @self.block_post(caseTerm)\n"
        "  self\n"
        "\n"
        "def SourceRepro.switch_block(self, Term term) -> SourceRepro\n"
        "  @self.name_binding_source(term)\n"
        "  @self.phrase(:text 'switch')\n"
        "\n"
        "  if term.num_inputs > 0\n"
        "    @self.phrase(:text ' ')\n"
        "    @self.term_input(term 0)\n"
        "\n"
        "  @self.block_pre(term)\n"
        "\n"
        "  cases = term.contents.if_block_cases.filter((term) -> not term.property_opt(:Hidden false))\n"
        "  for caseTerm in cases\n"
        "    @self.phrase(:ws caseTerm.property_opt(:Syntax_PreWs ''))\n"
        "    @self.phrase(:text 'case ')\n"
        "    condition = caseTerm.contents.case_find_condition\n"
        "\n"
        "    @self.term_input_pre(condition 0)\n"
        "    if condition.input(0).property_opt(:Hidden false)\n"
        "      @self.term_expr(condition.input(0).input(0))\n"
        "    else\n"
        "      @self.term_expr(condition.input(0))\n"
        "    @self.term_input_post(condition 0)\n"
        "\n"
        "    @self.phrase(:ws caseTerm.property_opt(:Syntax_LineEnding ''))\n"
        "    @self.block_pre(caseTerm)\n"
        "    @self.block_contents(caseTerm.contents)\n"
        "    @self.block_post(caseTerm)\n"
        "  self\n"
        "\n"
        "def SourceRepro.implicit_copy(self, Term term) -> SourceRepro\n"
        "  @self.name_binding_source(term)\n"
        "  @self.term_input(term 0)\n"
        "\n"
        "def SourceRepro.nonlocal(self, Term term) -> SourceRepro\n"
        "  @self.phrase(:name term.input(0).name)\n"
        "\n"
        "def SourceRepro.term(@self, Term term)\n"
        "  if term.is_comment\n"
        "    @self.phrase(:comment term.property_opt(:Comment ''))\n"
        "  elif term.is_neg\n"
        "    @self.neg(term)\n"
        "  elif term.is_require\n"
        "    @self.require_statement(term)\n"
        "  elif term.is_def_function_decl\n"
        "    @self.function_decl(term)\n"
        "  elif term.is_struct_decl\n"
        "    @self.struct_decl(term)\n"
        "  elif term.is_get_index and term.property_opt(:Syntax_Brackets false)\n"
        "    @self.get_index_brackets(term)\n"
        "  elif term.is_set_with_selector\n"
        "    @self.set_with_selector(term)\n"
        "  elif term.property_opt(:Syntax_ReturnStatement false)\n"
        "    @self.return_statement(term)\n"
        "  elif term.is_declared_state\n"
        "    @self.declared_state(term)\n"
        "  elif term.is_while_loop\n"
        "    @self.while_loop(term)\n"
        "  elif term.is_if_block\n"
        "    @self.if_block(term)\n"
        "  elif term.is_switch_block\n"
        "    @self.switch_block(term)\n"
        "  elif term.is_copy\n"
        "    @self.implicit_copy(term)\n"
        "  elif term.is_nonlocal\n"
        "    @self.nonlocal(term)\n"
        "  elif term.is_continue\n"
        "    @self.phrase(:text 'continue')\n"
        "  elif term.is_break\n"
        "    @self.phrase(:text 'break')\n"
        "  elif term.is_discard\n"
        "    @self.phrase(:text 'discard')\n"
        "  elif term.is_syntax_error\n"
        "    @self.phrase(:text term.property_opt(:OriginalText ''))\n"
        "  elif term.is_value\n"
        "    @self.term_value(term)\n"
        "  else\n"
        "    @self.term_default_format(term)\n"
        "\n"
        "  @self.phrase(:ws term.property_opt(:Syntax_PostWs ''))\n"
        "  @self.phrase(:ws term.property_opt(:Syntax_LineEnding ''))\n"
        "  self\n"
        "\n"
        "def Term.has_implicit_name_binding(term) -> bool\n"
        "  if term.name == \"\"\n"
        "    false\n"
        "  elif term.property_opt(:Syntax_ImplicitName false)\n"
        "    true\n"
        "  elif term.property_opt(:Syntax_RedindOperator false)\n"
        "    true\n"
        "  else\n"
        "    false\n"
        "\n"
        "def SourceRepro.name_binding_source(self, Term term) -> SourceRepro\n"
        "  if term.name == \"\" or term.has_implicit_name_binding\n"
        "    return self\n"
        "\n"
        "  if term.has_property(:Syntax_NameBinding)\n"
        "    syntax = term.property(:Syntax_NameBinding)\n"
        "    for element in syntax\n"
        "      if type(element) == int\n"
        "        @self.phrase(:name_binding term.output(element).name)\n"
        "      else\n"
        "        @self.phrase(:text element)\n"
        "  else\n"
        "    @self.phrase(:name term.name).phrase(:text \" = \")\n"
        "\n"
        "  self\n"
        "\n"
        "\n"
        "def SourceRepro.term_input_pre(self, Term term, int index) -> SourceRepro\n"
        "  defaultPre = cond(index == 0, \"\", \" \")\n"
        "  @self.phrase(:ws term.input_property_opt(index :Syntax_PreWs defaultPre))\n"
        "\n"
        "def Term.input_visible(term, int index) -> bool\n"
        "  if term.input(index).is_null\n"
        "    return false\n"
        "  if term.input_property_opt(index :Hidden false)\n"
        "    return false\n"
        "  true\n"
        "\n"
        "def SourceRepro.term_expr(self, Term term) -> SourceRepro\n"
        "  if term.name == ''\n"
        "    @self.term(term)\n"
        "  else\n"
        "    @self.phrase(:name_ref term)\n"
        "  self\n"
        "\n"
        "def SourceRepro.term_input_inner(self, Term term, int index) -> SourceRepro\n"
        "  if not term.input_visible(index)\n"
        "    return self\n"
        "\n"
        "  inputTerm = term.input(index)\n"
        "\n"
        "  if inputTerm.name == ''\n"
        "    @self.term(inputTerm)\n"
        "  else\n"
        "    if term.input_property_opt(index :Syntax_IdentifierRebind false)\n"
        "      @self.phrase(:text '@')\n"
        "    @self.phrase(:name_ref inputTerm)\n"
        "  self\n"
        "\n"
        "def SourceRepro.term_input_post(self, Term term, int index) -> SourceRepro\n"
        "  defaultPost = cond(index+1 == term.num_inputs, \"\", \",\")\n"
        "  @self.phrase(:ws term.input_property_opt(index :Syntax_PostWs defaultPost))\n"
        "\n"
        "def SourceRepro.term_input(self, Term term, int index) -> SourceRepro\n"
        "  if not term.input_visible(index)\n"
        "    return self\n"
        "\n"
        "  @self.term_input_pre(term index)\n"
        "  @self.term_input_inner(term index)\n"
        "  @self.term_input_post(term index)\n"
        "\n"
        "def SourceRepro.term_inputs_new_style(self, Term term) -> SourceRepro\n"
        "  for element in term.property_opt(:Syntax_InputFormat [])\n"
        "    if is_list(element)\n"
        "      tag = element[0]\n"
        "\n"
        "      switch tag\n"
        "        case :ident\n"
        "          index = element[1]\n"
        "          @self.phrase(:name_ref inputTerm)\n"
        "        case :expr\n"
        "          index = element[1]\n"
        "          @self.term(term.input(index))\n"
        "    else\n"
        "      @self.phrase(:text element)\n"
        "  self\n"
        "\n"
        "def SourceRepro.term_default_format(self, Term term) -> SourceRepro\n"
        "\n"
        "  declarationStyle = term.property_opt(:Syntax_DeclarationStyle, 'function-call')\n"
        "  functionName = term.property_opt(:Syntax_FunctionName, term.function.name)\n"
        "\n"
        "  -- Check for an infix operator with implicit rebinding (like +=)\n"
        "  if declarationStyle == 'infix' and term.property_opt(:Syntax_RebindingInfix false)\n"
        "    @self.phrase(:name_binding term.name)\n"
        "    @self.phrase(:ws ' ')\n"
        "    @self.phrase(:operator functionName)\n"
        "    @self.term_input(term 1)\n"
        "    return self\n"
        "\n"
        "  @self.name_binding_source(term)\n"
        "\n"
        "  -- Optional parens\n"
        "  for i in 0..term.property_opt(:Syntax_Parens 0)\n"
        "    @self.phrase(:text '(')\n"
        "\n"
        "  if term.is_for_loop\n"
        "    @self.for_loop(term)\n"
        "  elif term.is_anon_function_decl\n"
        "    @self.anon_function_decl(term)\n"
        "  elif declarationStyle == 'function-call'\n"
        "    if functionName == ''\n"
        "      @self.term(term.function)\n"
        "    else\n"
        "      @self.phrase(:function_name functionName)\n"
        "\n"
        "    parens = not term.property_opt(:Syntax_NoParens false)\n"
        "\n"
        "    if parens\n"
        "      @self.phrase(:text '(')\n"
        "\n"
        "    for i in 0..term.num_inputs\n"
        "      @self.term_input(term i)\n"
        "\n"
        "    if parens\n"
        "      @self.phrase(:text ')')\n"
        "\n"
        "  elif declarationStyle == 'method-call'\n"
        "    @self.term_input_pre(term 0)\n"
        "    @self.term_input_inner(term 0)\n"
        "\n"
        "    @self.phrase(:ws term.property_opt(:Syntax_PreDotWs ''))\n"
        "    @self.phrase(:text '.')\n"
        "    @self.phrase(:function_name functionName)\n"
        "    if not term.property_opt(:Syntax_NoParens false)\n"
        "      @self.phrase(:text '(')\n"
        "\n"
        "    for inputIndex in 1..term.num_inputs\n"
        "      @self.term_input(term inputIndex)\n"
        "\n"
        "    if not term.property_opt(:Syntax_NoParens false)\n"
        "      @self.phrase(:text ')')\n"
        "\n"
        "  elif declarationStyle == 'dot-access'\n"
        "    @self.term_input(term 0)\n"
        "    @self.phrase(:text '.')\n"
        "    @self.term_input(term 1)\n"
        "  elif declarationStyle == 'dot-concat'\n"
        "    @self.term_input(term 0)\n"
        "    @self.phrase(:text '.')\n"
        "    @self.phrase(:functionName functionName)\n"
        "  elif declarationStyle == 'infix'\n"
        "    @self.term_input(term 0)\n"
        "    @self.phrase(:functionName functionName)\n"
        "    @self.term_input(term 1)\n"
        "  elif declarationStyle == 'prefix'\n"
        "    @self.phrase(:functionName functionName)\n"
        "    @self.phrase(:ws term.property_opt(:Syntax_PostFunctionWs ''))\n"
        "    @self.term_input(term 0)\n"
        "  elif declarationStyle == 'arrow-concat'\n"
        "    @self.term_input(term 0)\n"
        "    @self.phrase(:text '->')\n"
        "    @self.phrase(:ws term.property_opt(:Syntax_PostOperatorWs ''))\n"
        "    @self.phrase(:functionName functionName)\n"
        "  elif declarationStyle == 'bar-apply'\n"
        "    @self.term_input(term 0)\n"
        "    @self.phrase(:text '|')\n"
        "    @self.phrase(:ws term.property_opt(:Syntax_PostOperatorWs ''))\n"
        "    @self.phrase(:functionName functionName)\n"
        "  elif declarationStyle == 'method-right-arrow'\n"
        "    @self.term_input(term 1)\n"
        "    @self.phrase(:text '->')\n"
        "    @self.phrase(:ws term.property_opt(:Syntax_PostOperatorWs ''))\n"
        "    @self.term_input_pre(term 0)\n"
        "    @self.term_input_inner(term 0)\n"
        "    @self.phrase(:text '.')\n"
        "    @self.phrase(:functionName functionName)\n"
        "  elif declarationStyle == 'bracket-list'\n"
        "    @self.phrase(:text '[')\n"
        "    for index in 0..(term.num_inputs)\n"
        "      @self.term_input(term index)\n"
        "    @self.phrase(:text ']')\n"
        "  elif declarationStyle == 'braces-map'\n"
        "    @self.phrase(:text '{')\n"
        "    @self.term_inputs_new_style(term)\n"
        "    @self.phrase(:text '}')\n"
        "\n"
        "  else\n"
        "    error('unrecognized declaration style: ' declarationStyle)\n"
        "\n"
        "  -- Optional parens\n"
        "  for i in 0..term.property_opt(:Syntax_Parens 0)\n"
        "    @self.phrase(:text ')')\n"
        "\n"
        "  self\n"
        "\n"
        "def Term.should_print_source_line(term) -> bool\n"
        "  term.is_statement\n"
        "\n"
        "def SourceRepro.block_pre(self, Term term) -> SourceRepro\n"
        "  @self.phrase(:ws term.property_opt(:Syntax_PostHeadingWs ''))\n"
        "  if term.property_opt(:Syntax_BlockStyle '') == 'braces'\n"
        "    @self.phrase(:text '{')\n"
        "  self\n"
        "\n"
        "def SourceRepro.block_contents(@self, Block block)\n"
        "  @self.phrase(:block_start block)\n"
        "  @self.block(block)\n"
        "  @self.phrase(:block_end block)\n"
        "\n"
        "\n"
        "def SourceRepro.block_post(self, Term term) -> SourceRepro\n"
        "  if term.property_opt(:Syntax_BlockStyle '') == 'braces'\n"
        "    @self.phrase(:text '}')\n"
        "  self\n"
        "\n"
        "def SourceRepro.block(self, Block block) -> SourceRepro\n"
        "  newlineNeeded = false\n"
        "  \n"
        "  for term in block.terms\n"
        "    if not term.should_print_source_line\n"
        "      continue\n"
        "\n"
        "    if newlineNeeded\n"
        "      @self.phrase(:ws '\\n')\n"
        "      newlineNeeded = false\n"
        "\n"
        "    @self.phrase(:ws term.property_opt(:Syntax_PreWs ''))\n"
        "    @self.term(term)\n"
        "\n"
        "    if term.has_property(:Syntax_LineEnding) or term.has_property(:Syntax_PostHeadingWs)\n"
        "      -- no newline needed\n"
        "    else\n"
        "      newlineNeeded = true\n"
        "\n"
        "  self\n"
        "\n"
        "def phrases_to_string(List phrases) -> String\n"
        "  strs = for phrase in phrases\n"
        "    phrase.text\n"
        "  strs.join('')\n"
        "\n"
        "def term_phrases(Term term) -> List\n"
        "  SourceRepro.make.term(term).phrases\n"
        "\n"
        "def block_phrases(Block block) -> List\n"
        "  SourceRepro.make.block(block).phrases\n"
        "\n"
        "def block_to_string(Block block)\n"
        "  block | block_phrases | phrases_to_string\n"
        ;

    if (strncmp(filename, "$builtins/stack_dump.ca", 23) == 0) return
        "\n"
        "struct StackDump {\n"
        "  IndentWriter out\n"
        "}\n"
        "\n"
        "def StackDump.write(self, String str) -> StackDump\n"
        "  @self.out.write(str)\n"
        "def StackDump.to_string(self) -> String\n"
        "  self.out.toString\n"
        "\n"
        "def StackDump.stack(self, Stack stack) -> StackDump\n"
        "  @self.out.write('[Stack #' stack.id ', frames = ', stack.frames_count)\n"
        "\n"
        "def stack_to_string(Stack stack) -> String\n"
        "  StackDump.make.stack(stack).to_string\n"
        ;

    if (strncmp(filename, "$builtins/static_checking.ca", 28) == 0) return
        "\n"
        "struct Check {\n"
        "  List errors\n"
        "}\n"
        "\n"
        "def Check.term(@self, Term term)\n"
        "  if term.function.is_null\n"
        "    @self.errors.append([term :null_function])\n"
        "\n"
        "  if term.function == unknown_function.block\n"
        "    @self.errors.append([term :unknown_function])\n"
        "\n"
        "  if term.function == unknown_identifier.block\n"
        "    @self.errors.append([term :unknown_identifier])\n"
        "\n"
        "  if term.function == syntax_error.block\n"
        "    msg = term.input(0).value\n"
        "    @self.errors.append([term msg])\n"
        "\n"
        "def Check.block(@self, Block block)\n"
        "  for term in block.terms\n"
        "    @self.term(term)\n"
        "  self\n"
        "\n"
        "def check_block(Block block) -> List\n"
        "  result = Check.make.block(block)\n"
        "  result.errors\n"
        "\n"
        "def check_block_and_report(Block block)\n"
        "  errors = check_block(block)\n"
        "  if errors.length == 0\n"
        "    print(\"No errors found\")\n"
        "  else\n"
        "    print(errors.length \" error(s) found:\")\n"
        "    for error in errors\n"
        "      print('  ' format_error(error))\n"
        "\n"
        "def format_error(error) -> String\n"
        "  term = error[0]\n"
        "  msg = error[1]\n"
        "\n"
        "  result = ''\n"
        "  str(@result term.location_string ' ')\n"
        "\n"
        "  switch msg\n"
        "    case :null_function\n"
        "      str(@result 'NULL function reference')\n"
        "    case :unknown_function\n"
        "      str(@result 'Unknown function: ' term.property_opt(:Syntax_FunctionName ''))\n"
        "    case :unknown_identifier\n"
        "      str(@result 'Unknown identifier: ' term.name)\n"
        "    else\n"
        "      str(@result msg)\n"
        "\n"
        "  result\n"
        ;

    if (strncmp(filename, "$builtins/stdlib.ca", 19) == 0) return
        "\n"
        "def unknown_function_prelude(any ins :multiple)\n"
        "\n"
        "-- Misc builtins\n"
        "def declare_field()\n"
        "def return(any outs :multiple :optional)\n"
        "def discard(any outs :multiple :optional)\n"
        "def dynamic_method(any inputs :multiple)\n"
        "def break(any outs :multiple :optional)\n"
        "def continue(any outs :multiple :optional)\n"
        "def make(Type t) -> any\n"
        "def extra_output(any _) -> any\n"
        "def func_call_implicit(any inputs :multiple)\n"
        "def get_field(any obj, String key) -> any\n"
        "def method_lookup(location, any obj, Symbol name) -> any -- Func or null\n"
        "def get_index(List list, int index) -> any\n"
        "def selector(any elements :multiple) -> Selector\n"
        "def get_with_selector(any object, Selector selector) -> any\n"
        "def set_with_selector(any object, Selector selector, any newValue) -> any\n"
        "def section()\n"
        "def loop_condition_bool(bool condition)\n"
        "def loop_iterator()\n"
        "def while()\n"
        "def for(List list) -> List\n"
        "def if() -> any\n"
        "def case(bool b :optional)\n"
        "def switch(any input :optional) -> any\n"
        "def _upvalue(term :ref) -> any\n"
        "def load_script(String filename) -> Block\n"
        "\n"
        "-- List values\n"
        "def make_list(any vals :multiple) -> List\n"
        "def blank_list(int count) -> List\n"
        "\n"
        "-- Logical\n"
        "def and(bool a, bool b) -> bool\n"
        "  -- Return whether a and b are both true\n"
        "def or(bool a, bool b) -> bool\n"
        "  -- Return whether a or b are both true\n"
        "def not(bool b) -> bool\n"
        "\n"
        "-- Map values\n"
        "def map(any vals :multiple) -> Map\n"
        "\n"
        "-- Math\n"
        "def add_i(int a, int b) -> int\n"
        "def add_f(number a, number b) -> number\n"
        "def max_f(number a,number b) -> number\n"
        "  -- Maximum of two numbers\n"
        "def max_i(int a,int b) -> int\n"
        "  -- Maximum of two integers\n"
        "def min_f(number a,number b) -> number\n"
        "  -- Minimum of two numbers\n"
        "def min_i(int a,int b) -> int\n"
        "  -- Minimum of two integers\n"
        "def remainder_i(int a,int b) -> int\n"
        "def remainder_f(number a,number b) -> number\n"
        "def mult_i(int a,int b) -> int\n"
        "def mult_f(number a,number b) -> number\n"
        "def mod_i(int a,int b) -> int\n"
        "def mod_f(number a,number b) -> number\n"
        "def neg_i(int i) -> int\n"
        "def neg_f(number n) -> number\n"
        "def sub_i(int a,int b) -> int\n"
        "def sub_f(number a,number b) -> number\n"
        "def round(number n) -> int\n"
        "  -- Return the integer that is closest to n\n"
        "def floor(number n) -> int\n"
        "  -- Return the closest integer that is less than n\n"
        "def ceil(number n) -> int\n"
        "  -- Return the closest integer that is greater than n\n"
        "def average(vals :multiple) -> number\n"
        "  -- Returns the average of all inputs\n"
        "def pow(number i, number x) -> number\n"
        "  -- Returns i to the power of x\n"
        "def sqr(number n) -> number\n"
        "  -- Square function\n"
        "def cube(number n) -> number\n"
        "  -- Cube function\n"
        "def sqrt(number n) -> number\n"
        "  -- Square root\n"
        "def log(number n) -> number\n"
        "  -- Natural log function\n"
        "\n"
        "-- Trig\n"
        "def sin(number degrees) -> number\n"
        "  -- Trigonometric sin() function\n"
        "def cos(number degrees) -> number\n"
        "  -- Trigonometric cos() function\n"
        "def tan(number degrees) -> number\n"
        "  -- Trigonometric tan() function\n"
        "def arcsin(number n) -> number\n"
        "  -- Trigonometric arcsin() function\n"
        "def arccos(number n) -> number\n"
        "  -- Trigonometric arccos() function\n"
        "def arctan(number n) -> number\n"
        "  -- Trigonometric arctan() function\n"
        "\n"
        "def reflect_caller(int height) -> Term\n"
        "\n"
        "-- Type checking\n"
        "def is_compound(n) -> bool\n"
        "def is_list(n) -> bool\n"
        "def is_map(n) -> bool\n"
        "def is_int(n) -> bool\n"
        "def is_number(n) -> bool\n"
        "def is_bool(n) -> bool\n"
        "def is_string(n) -> bool\n"
        "def is_null(n) -> bool\n"
        "def is_function(n) -> bool\n"
        "def is_type(n) -> bool\n"
        "\n"
        "def is_scalar(n) -> bool\n"
        "  is_int(n) or is_number(n)\n"
        "\n"
        "-- Overloaded math funcs\n"
        "def add(any left, any right) -> any\n"
        "  if is_int(left) and is_int(right)\n"
        "    add_i(left, right)\n"
        "  elif is_int(left) or is_number(left)\n"
        "    add_f(left, right)\n"
        "  else\n"
        "    left.add(right)\n"
        "\n"
        "def sub(any left, any right) -> any\n"
        "  if is_int(left) and is_int(right)\n"
        "    sub_i(left, right)\n"
        "  elif is_int(left) or is_number(left)\n"
        "    sub_f(left, right)\n"
        "  else\n"
        "    left.sub(right)\n"
        "\n"
        "def mult(any left, any right) -> any\n"
        "  if is_int(left) and is_int(right)\n"
        "    mult_i(left, right)\n"
        "  elif is_int(left) or is_number(left)\n"
        "    mult_f(left, right)\n"
        "  else\n"
        "    left.mult(right)\n"
        "\n"
        "def div(any left, any right) -> any\n"
        "  if is_int(left) or is_number(left)\n"
        "    div_f(left, right)\n"
        "  else\n"
        "    left.div(right)\n"
        "\n"
        "def less_than(any a, any b) -> bool\n"
        "  if is_int(a) and is_int(b)\n"
        "    less_than_i(a b)\n"
        "  else\n"
        "    less_than_f(a b)\n"
        "\n"
        "def less_than_eq(any a, any b) -> bool\n"
        "  if is_int(a) and is_int(b)\n"
        "    less_than_eq_i(a b)\n"
        "  else\n"
        "    less_than_eq_f(a b)\n"
        "\n"
        "def greater_than(any a, any b) -> bool\n"
        "  if is_int(a) and is_int(b)\n"
        "    greater_than_i(a b)\n"
        "  else\n"
        "    greater_than_f(a b)\n"
        "\n"
        "def greater_than_eq(any a, any b) -> bool\n"
        "  if is_int(a) and is_int(b)\n"
        "    greater_than_eq_i(a b)\n"
        "  else\n"
        "    greater_than_eq_f(a b)\n"
        "\n"
        "def max(any a, any b) -> any\n"
        "  if is_int(a) and is_int(b)\n"
        "    max_i(a b)\n"
        "  else\n"
        "    max_f(a b)\n"
        "\n"
        "def min(any a, any b) -> any\n"
        "  if is_int(a) and is_int(b)\n"
        "    min_i(a b)\n"
        "  else\n"
        "    min_f(a b)\n"
        "\n"
        "def remainder(any a, any b) -> any\n"
        "  if is_int(a) and is_int(b)\n"
        "    remainder_i(a b)\n"
        "  else\n"
        "    remainder_f(a b)\n"
        "\n"
        "def mod(any a, any b) -> any\n"
        "  if is_int(a) and is_int(b)\n"
        "    mod_i(a b)\n"
        "  else\n"
        "    mod_f(a b)\n"
        "\n"
        "def neg(any a) -> any\n"
        "  if is_int(a)\n"
        "    neg_i(a)\n"
        "  else\n"
        "    neg_f(a)\n"
        "\n"
        "def number.add(left, right) -> number\n"
        "  add(left, right)\n"
        "def number.sub(left, right) -> number\n"
        "  sub(left, right)\n"
        "def number.mult(left, right) -> number\n"
        "  mult(left, right)\n"
        "def number.div(left, right) -> number\n"
        "  div(left, right)\n"
        "\n"
        "def rand() -> number\n"
        "\n"
        "def copy(any val) -> any\n"
        "\n"
        "def cast(any val, Type t) -> any\n"
        "  -- Cast the value to the given type. Returns null if cast fails.\n"
        "\n"
        "def cond(bool condition, any pos, any neg) -> any\n"
        "  -- If 'condition' is true, returns 'pos'. Otherwise returns 'neg'.\n"
        "\n"
        "def str(any vals :multiple) -> String\n"
        "  -- Convert inputs to a string and concatenate the result\n"
        "\n"
        "def copy(any val) -> any\n"
        "\n"
        "def convert(any value, Type t) -> any\n"
        "  -- Convert the value to the given type, if possible.\n"
        "\n"
        "def compute_patch(existing, new) -> any\n"
        "  -- Compute a patch, which when applied to 'existing' will equal 'new'\n"
        "\n"
        "def div_f(number a,number b) -> number\n"
        "def div_i(number a,number b) -> int\n"
        "\n"
        "def apply_patch(existing, patch) -> any\n"
        "  -- Apply a patch\n"
        "\n"
        "def assert(bool condition)\n"
        "  -- Raises an error if 'condition' is false.\n"
        "\n"
        "def equals(any a,any b) -> bool\n"
        "\n"
        "def from_string(String s) -> any\n"
        "  -- Parse a string representation to a value\n"
        "\n"
        "def error(any msg :multiple)\n"
        "def error_up(int height, any msg :multiple)\n"
        "\n"
        "-- Comparison\n"
        "def less_than_i(int a,int b) -> bool\n"
        "def less_than_f(number a,number b) -> bool\n"
        "def less_than_eq_i(int a,int b) -> bool\n"
        "def less_than_eq_f(number a,number b) -> bool\n"
        "def greater_than_i(int a,int b) -> bool\n"
        "def greater_than_f(number a,number b) -> bool\n"
        "def greater_than_eq_i(int a,int b) -> bool\n"
        "def greater_than_eq_f(number a,number b) -> bool\n"
        "\n"
        "def length(List list) -> int\n"
        "  -- Return the number of items in the given list\n"
        "\n"
        "\n"
        "def set_field(any obj, String key, any val) -> any\n"
        "def set_index(any list, int index, any val) -> List\n"
        "\n"
        "def static_error(any msg)\n"
        "\n"
        "def not_equals(any a,any b) -> bool\n"
        "\n"
        "def print(any items :multiple)\n"
        "  -- Prints a line of text output to the console.\n"
        "\n"
        "def trace(any items :multiple)\n"
        "  -- Like print()\n"
        "\n"
        "def get(Map val, List path) -> any\n"
        "def set(Map val, List path, any newValue) -> any\n"
        "def delete(Map val, List path) -> Map\n"
        "\n"
        "def to_string_repr(any val) -> String\n"
        "  -- Encode a Circa value as a string representation.\n"
        "\n"
        "def typeof(any val) -> Type\n"
        "  -- Returns the runtime type of a value.\n"
        "\n"
        "def env(any name) -> any\n"
        "  -- Fetch an env variable\n"
        "\n"
        "def has_effects()\n"
        "  -- Annotation, declare that a function has effects. Used in native-patched\n"
        "  -- functions. Not fully supported yet.\n"
        "\n"
        "def native_patch(String filename)\n"
        "  -- Declare that this block should be patched by a native module.\n"
        "\n"
        "def write_text_file(String filename, String contents)\n"
        "  -- Write contents to the given filename, overwriting any existing file.\n"
        "  -- TODO: delete, replace with library\n"
        "\n"
        "def path_dirname(path)\n"
        "def path_join(paths :multiple)\n"
        "\n"
        "def syntax_error()\n"
        "  caller = reflect_caller(1)\n"
        "  error_up(1, str(\"Syntax error: \" caller.property(:Message)))\n"
        "\n"
        "def unknown_identifier()\n"
        "  caller = reflect_caller(1)\n"
        "  error_up(1, str(\"Unknown identifier: \" caller.name))\n"
        "\n"
        "def unknown_function(i :multiple)\n"
        "  caller = reflect_caller(1)\n"
        "  error_up(1, str(\"Unknown function: \" caller.property(:Syntax_FunctionName)))\n"
        "\n"
        "def rpath(String path) -> String\n"
        "  callerBlock = reflect_caller(1).parent\n"
        "  dir = callerBlock.source_filename\n"
        "  path_dirname(@dir)\n"
        "  path_join(dir path)\n"
        "\n"
        "def static_type(i) -> Type\n"
        "  caller = reflect_caller(1)\n"
        "  input = caller.input(0)\n"
        "  input.get_type\n"
        "\n"
        "def term_ref(term :ref) -> Term\n"
        "  caller = reflect_caller(1)\n"
        "  caller.input(0)\n"
        "\n"
        "-- Builtin sequences\n"
        "\n"
        "-- to_seq is used inside loops, so don't write any loops before this declaration.\n"
        "def to_seq(val) -> any\n"
        "  if is_list(val)\n"
        "    val.to_seq\n"
        "  else\n"
        "    val\n"
        "\n"
        "struct ListSeq {\n"
        "  List list\n"
        "  int index\n"
        "}\n"
        "\n"
        "def ListSeq.key(self) self.index\n"
        "def ListSeq.done(self) self.index >= self.list.length\n"
        "def ListSeq.next(self) self.list.get(self.index)\n"
        "def ListSeq.advance(@self) self.index += 1\n"
        "\n"
        "def List.to_seq(self)\n"
        "  ListSeq.make(self 0)\n"
        "\n"
        "struct ConcatSeq {\n"
        "  any left\n"
        "  any right\n"
        "}\n"
        "\n"
        "def ConcatSeq.done(self) self.left.done and self.right.done\n"
        "def ConcatSeq.next(self) self.left.next\n"
        "def ConcatSeq.key(self) self.left.key\n"
        "def ConcatSeq.settle(self) cond(self.left.done, self.right, self)\n"
        "\n"
        "def ConcatSeq.advance(@self)\n"
        "  @self.left.advance\n"
        "  @self.settle\n"
        "\n"
        "def concat_seq(left, right)\n"
        "  ConcatSeq.make(to_seq(left) to_seq(right)).settle\n"
        "\n"
        "struct FilterSeq {\n"
        "  any seq\n"
        "  Func func\n"
        "}\n"
        "\n"
        "def FilterSeq.done(self) self.seq.done\n"
        "def FilterSeq.next(self) self.seq.next\n"
        "def FilterSeq.key(self) self.seq.key\n"
        "\n"
        "def FilterSeq.settle(@self)\n"
        "  while true\n"
        "    if self.done\n"
        "      return self\n"
        "\n"
        "    if self.func.call(self.seq.next)\n"
        "      return self\n"
        "\n"
        "    @self.advance\n"
        "\n"
        "def FilterSeq.advance(self)\n"
        "  @self.seq.advance\n"
        "  self.settle\n"
        "\n"
        "def filter(s, func) -> FilterSeq\n"
        "  FilterSeq.make(to_seq(s), func).settle\n"
        "\n"
        "struct UntilSeq {\n"
        "  any seq\n"
        "  Func doneFunc\n"
        "}\n"
        "\n"
        "def UntilSeq.done(self) self.doneFunc.call(self.seq.next)\n"
        "def UntilSeq.next(self) self.seq.next\n"
        "def UntilSeq.advance(@self) @self.seq.advance\n"
        "def UntilSeq.key(self) self.seq.key\n"
        "\n"
        "def take_until(s, Func done)\n"
        "  UntilSeq.make(to_seq(s) done)\n"
        "\n"
        "struct Range {\n"
        "  int from\n"
        "  int to\n"
        "  int by\n"
        "}\n"
        "\n"
        "def Range.done(self) -> bool\n"
        "  self.from >= self.to\n"
        "\n"
        "def Range.next(self)\n"
        "  self.from\n"
        "\n"
        "def Range.key(self) -> int\n"
        "  self.from\n"
        " \n"
        "def Range.advance(@self) -> Range\n"
        "  self.from += self.by\n"
        "\n"
        "def range(from, to)\n"
        "  Range.make(from to 1)\n"
        "\n"
        "def range_by(from, to, by)\n"
        "  Range.make(from to by)\n"
        "\n"
        "def fold(it, func, accum)\n"
        "  for i in it\n"
        "    accum = func.call(accum i)\n"
        "  accum\n"
        "\n"
        "def flatten(it) -> List\n"
        "  -- Language defect: Should be able to refer to the function List.append directly.\n"
        "  def append(List list, item) -> List\n"
        "    list.append(item)\n"
        "    \n"
        "  fold(it append [])\n"
        "\n"
        "def visit(it, func)\n"
        "  for i in it\n"
        "    func(i)\n"
        "\n"
        "def unique_id() -> int\n"
        "def source_id() -> any\n"
        "\n"
        "-- Channels\n"
        "def channel_send(Symbol name, any val)\n"
        "\n"
        "def global_script_version() -> int\n"
        "\n"
        "-- Func\n"
        "struct Func {\n"
        "  Block block\n"
        "  List bindings\n"
        "}\n"
        "\n"
        "def Func.call(self, any inputs :multiple) -> any\n"
        "  -- Call the func using the given inputs.\n"
        "\n"
        "  -- This function is replaced by special bytecode, however in some situations\n"
        "  -- (like dynamic methods), we might find ourselves actually calling this\n"
        "  -- function. So we have another closure call here, and this one will definitely\n"
        "  -- be compiled with the correct bytecode.\n"
        "  self.apply(inputs)\n"
        "\n"
        "def Func.apply(self, List inputs) -> any\n"
        "  -- Like .call, but the inputs are given as one list instead of separate args.\n"
        "\n"
        "  -- See note in Func.call:\n"
        "  self.apply(inputs)\n"
        "\n"
        "def call(Func func, inputs :multiple) -> any\n"
        "  func.apply(inputs)\n"
        "\n"
        "def method_call(location, obj, Symbol name, List args)\n"
        "  func = method_lookup(location obj name)\n"
        "  if func == null\n"
        "    error_up(1, 'Method not found: ' name)\n"
        "  func.call(args)\n"
        "\n"
        "def closure_block() -> Func\n"
        "  -- Internally used function for declaring a closure.\n"
        "\n"
        "-- Secret internally-used funcs\n"
        "\n"
        "\n"
        "def _declared_state(existing, Type type, initializer) -> any\n"
        "  -- Fetch a declared state variable. The 'state' keyword uses this.\n"
        "  \n"
        "  if existing != null\n"
        "    -- Try to cast to the desired type\n"
        "    existing = cast(existing, type)\n"
        "\n"
        "    if existing != null\n"
        "      return existing\n"
        "\n"
        "  -- Cast failed. Try to use the initializer.\n"
        "  if initializer != null\n"
        "    return initializer.call()\n"
        "\n"
        "  -- No initializer. Use the type's default value.\n"
        "  return make(type)\n"
        "\n"
        "def vm_demand_eval_find_existing(Term t) -> List\n"
        "def vm_demand_eval_store(Term t, any val)\n"
        "\n"
        "def vm_demand_eval(Term t) -> any\n"
        "  if t.is_value or t.is_func_decl\n"
        "    return t.value\n"
        "\n"
        "  existing = vm_demand_eval_find_existing(t)\n"
        "  if existing != []\n"
        "    return existing.first\n"
        "\n"
        "  inputs = for Term input in t.inputs\n"
        "    vm_demand_eval(input)\n"
        "\n"
        "  result = t.function.to_func.apply(inputs)\n"
        "  vm_demand_eval_store(t result)\n"
        "  result\n"
        "\n"
        "-- Misc builtin funcs --\n"
        "\n"
        "def abs(number n) -> number\n"
        "  -- Absolute value\n"
        "\n"
        "def any_true(list) -> bool\n"
        "  for i in list\n"
        "    if not(i)\n"
        "      return false\n"
        "  true\n"
        "\n"
        "def get_with_symbol(any lhs, Symbol symbol) -> any\n"
        "\n"
        "def first_symbol(any val) -> Symbol\n"
        "  if typeof(val) == Symbol\n"
        "    val\n"
        "  elif typeof(val) == List\n"
        "    if length(val) > 0\n"
        "      first_symbol(val[0])\n"
        "\n"
        "def rand_range(number min, number max) -> number\n"
        "  min + rand() * (max - min)\n"
        "\n"
        "def rand_i(int range) -> int\n"
        "  floor(rand() * range)\n"
        "\n"
        "def increment(int i) -> int\n"
        "  i + 1\n"
        "\n"
        "def decrement(int i) -> int\n"
        "  i - 1\n"
        "\n"
        "-- Builtin types\n"
        "struct FileSignature { String filename, int time_modified }\n"
        "struct Callable;\n"
        "struct Color { number r, number g, number b, number a }\n"
        "struct Module { String name, Block relativeTo }\n"
        "struct Vec2 { number x, number y }\n"
        "struct Vec2i { int x, int y }\n"
        "struct Vec3 { number x, number y, number z }\n"
        "struct Vec4 { number x, number y, number z, number w }\n"
        "struct Rect { number x1, number y1, number x2, number y2 }\n"
        "struct Rect_i { int x1, int y1, int x2, int y2 }\n"
        "\n"
        "def Module._get(self, name)\n"
        "def Module.block(self) -> Block\n"
        "def Module.resolve(self) -> Block\n"
        "  self.block\n"
        "def Module.to_func(self) -> Func\n"
        "  self.block.to_func\n"
        "def Module.to_vm(self) -> VM\n"
        "  self.block.to_vm\n"
        "def Module._load(self) -> Block\n"
        "def Module.is_local(self) -> bool\n"
        "  not self.relativeTo.is_null\n"
        "\n"
        "def require(String name) -> Module\n"
        "  m = Module.make(name, Block.make)\n"
        "  m._load\n"
        "  require_check(m)\n"
        "  m\n"
        "\n"
        "def require_local(String name) -> Module\n"
        "  relativeTo = reflect_caller(1).parent\n"
        "  m = Module.make(name, relativeTo)\n"
        "  m._load\n"
        "  require_check(m)\n"
        "  m\n"
        "\n"
        "def require_check(Module module)\n"
        "  block = module.resolve\n"
        "  if block.is_null\n"
        "    error_up(1, \"Couldn't find \", cond(module.is_local, \"local \", \"\") \"module: \" module.name)\n"
        "\n"
        "  if block.has_static_error\n"
        "    msg = [str(\"Module '\" module.name \"' has static errors: \")]\n"
        "    for error in block.get_static_errors_formatted\n"
        "      @msg.append(str('  ' error))\n"
        "\n"
        "    print(msg.join('\\n'))\n"
        "\n"
        "def package(String moduleName)\n"
        "  -- Declare that the current module is a reusable library with the given name.\n"
        "  -- (Note: Currently this function does nothing)\n"
        "\n"
        "-- Test helpers\n"
        "def test_oracle() -> any\n"
        "  -- For internal testing. This function will output values that are manually\n"
        "  -- inserted with the C++ function oracle_send().\n"
        "\n"
        "def test_spy(any val)\n"
        "  -- For internal testing. This function will save inputs to a global list which\n"
        "  -- can be easily examined from C++ with test_spy_get_results().\n"
        "\n"
        "-- File module\n"
        "def file_exists(String filename) -> bool\n"
        "def file_version(String filename) -> int\n"
        "def file_read_text(String filename) -> String\n"
        "def file_changed(String filename) -> bool\n"
        "  ver = file_version(filename)\n"
        "  changed([filename ver])\n"
        "\n"
        "-- Sys module\n"
        "def sys_arg(int index) -> String\n"
        "def sys_module_search_paths() -> List\n"
        "\n"
        "def make_blob(int size) -> Blob\n"
        "def Blob.size(self) -> int\n"
        "def Blob.slice(self, int offset, int len) -> Blob\n"
        "def Blob.set_u8(self, int offset, int value)\n"
        "def Blob.set_u16(self, int offset, int value)\n"
        "def Blob.set_u32(self, int offset, int value)\n"
        "def Blob.set_i8(self, int offset, int value)\n"
        "def Blob.set_i16(self, int offset, int value)\n"
        "def Blob.set_i32(self, int offset, int value)\n"
        "def Blob.u8(self, int offset) -> int\n"
        "def Blob.u16(self, int offset) -> int\n"
        "def Blob.u32(self, int offset) -> int\n"
        "def Blob.i8(self, int offset) -> int\n"
        "def Blob.i16(self, int offset) -> int\n"
        "def Blob.i32(self, int offset) -> int\n"
        "\n"
        "def Blob.to_hex_string(self, offset :optional, len :optional) -> String\n"
        "  if offset == null\n"
        "    offset = 0\n"
        "\n"
        "  if len == null\n"
        "    len = self.size\n"
        "\n"
        "  if len + offset > self.size\n"
        "    len = self.size - offset\n"
        "\n"
        "  def to_hex_digit(int i)\n"
        "    if i >= 0 and i < 10\n"
        "      String.make.from_char_code('0'.char_code + i)\n"
        "    else\n"
        "      String.make.from_char_code('a'.char_code + i - 10)\n"
        "\n"
        "  result = \"\"\n"
        "  for i in range(offset, offset+len)\n"
        "    byte = self.u8(i)\n"
        "    @result.append(to_hex_digit(byte // 16))\n"
        "    @result.append(to_hex_digit(byte % 16))\n"
        "  result\n"
        "\n"
        "def Block.dump(self)\n"
        "  -- Dump this block's raw contents to stdout.\n"
        "def Block.find_term(self, String name) -> Term\n"
        "  -- Find a term inside this Block with the given name.\n"
        "def Block.functions(self) -> List\n"
        "  -- Return a list of functions that occur inside this block.\n"
        "def Block.get_term(self, int index) -> Term\n"
        "  -- Fetch a term by index.\n"
        "def Block.get_static_errors(self) -> List\n"
        "  -- Return a raw list of static errors inside this block.\n"
        "def Block.get_static_errors_formatted(self) -> List\n"
        "  -- Return a formatted list of static errors inside this block.\n"
        "def Block.has_static_error(self) -> bool\n"
        "  -- Return whether this block has any static errors.\n"
        "def Block.id(self) -> int\n"
        "def Block.input(self, int index) -> Term\n"
        "  -- Fetch an input placeholder term by index.\n"
        "def Block.is_major(self) -> bool\n"
        "def Block.is_null(self) -> bool\n"
        "  -- Return whether this is a null Block reference.\n"
        "def Block.inputs(self) -> List\n"
        "  -- Return a list of input placeholder terms.\n"
        "def Block.link(self, Block lib)\n"
        "  -- Iterate through this block, looking for terms that have missing references.\n"
        "  -- For each missing reference, if a term with the expected name is found in 'lib',\n"
        "  -- then modify the term to use the named term in 'lib'.\n"
        "def Block.list_configs(self) -> List\n"
        "  -- Return a list of Terms that look like configs (named literal values).\n"
        "def Block.nearest_major(self) -> Block\n"
        "  if self.is_major\n"
        "    self\n"
        "  else\n"
        "    self.parent.nearest_major\n"
        "def Block.output(self, int index) -> Term\n"
        "  -- Return an output term by index.\n"
        "def Block.outputs(self) -> List\n"
        "  -- List of output placeholder terms.\n"
        "def Block.output_placeholder(self, int index) -> Term\n"
        "  -- Return an output placeholder term by index.\n"
        "def Block.owner(self) -> Term\n"
        "  -- Return the Term that owns this Block (may be null).\n"
        "def Block.parent(self) -> Block\n"
        "  -- Return the Block that owns this Block (may be null).\n"
        "def Block.primary_output(self) -> Term\n"
        "  -- Return the primary output.\n"
        "  self.output(0)\n"
        "def Block.property(self, Symbol key) -> any\n"
        "def Block.properties(self) -> Map\n"
        "def Block.source_filename(self) -> String\n"
        "def Block.statements(self) -> List\n"
        "  -- Return a list of Terms that are statements.\n"
        "def Block.terms(self) -> List\n"
        "  -- Return a list of this block's terms.\n"
        "def Block.term_named(self, String name) -> Term\n"
        "def Block.walk_terms(self) -> List\n"
        "  -- Return a list of this block's terms, and all nested terms.\n"
        "\n"
        "def Block.to_func(self) -> Func\n"
        "  Func.make(self)\n"
        "\n"
        "def Block.to_vm(self) -> VM\n"
        "  self.to_func.to_vm\n"
        "\n"
        "def Block.to_vm(self) -> VM\n"
        "  self.to_func.to_vm\n"
        "\n"
        "def Block.name(self) -> String\n"
        "    self.owner.name\n"
        "\n"
        "def Block.is_method(self) -> bool\n"
        "  self.owner.property(\"syntax:methodDecl\") == true\n"
        "\n"
        "def Block.get_top_comments(self) -> List\n"
        "  out = []\n"
        "  for Term t in self.terms\n"
        "    if t.is_input_placeholder\n"
        "      continue\n"
        "    elif t.is_comment\n"
        "      s = t.property('comment')\n"
        "      if s == \"\"\n"
        "        break\n"
        "\n"
        "      out.append(t.property('comment'))\n"
        "    else\n"
        "      break\n"
        "\n"
        "  out\n"
        "\n"
        "def Block.call(self, any inputs :multiple) -> any\n"
        "  -- Invoke this Block with the given inputs.\n"
        "  self.to_func.apply(inputs)\n"
        "\n"
        "def Block.get_loop_index(self) -> Term\n"
        "  error(\"todo\")\n"
        "\n"
        "def Block.get_iterator(self) -> Term\n"
        "  error(\"todo\")\n"
        "\n"
        "def Block.if_block_cases(self) -> List\n"
        "  self.terms.filter((term) -> term.function.name == 'case')\n"
        "\n"
        "def Block.case_find_condition(self) -> Term\n"
        "  -- FIXME\n"
        "  return null\n"
        "\n"
        "def Block.find_while_condition(self) -> Term\n"
        "  for term in self.terms\n"
        "    if term.function == loop_condition_bool.block\n"
        "      return term\n"
        "  return null\n"
        "\n"
        "def capture_stack() -> VM\n"
        "  -- Returns a frozen copy of the currently executing stack.\n"
        "\n"
        "def VM.apply(self, List inputs) -> any\n"
        "def VM.block(self) -> Block\n"
        "  -- Returns the (topmost) block.\n"
        "def VM.call(self, any inputs :multiple) -> any\n"
        "def VM.consume_channel(self, key) -> List\n"
        "def VM.run(self)\n"
        "  self.call\n"
        "def VM.copy(self) -> VM\n"
        "def VM.dump(self)\n"
        "  -- Dumps a string representation to stdout.\n"
        "def VM.dump_with_bytecode(self)\n"
        "def VM.dump_compiled(self)\n"
        "\n"
        "def VM.get_raw_slots(self) -> List\n"
        "def VM.get_raw_ops(self) -> Blob\n"
        "def VM.get_raw_mops(self) -> Blob\n"
        "def VM.get_func_raw_ops(self, Func func) -> Blob\n"
        "def VM.get_bytecode_const(self, index) -> any\n"
        "def VM.precompile(self, Block b)\n"
        "def bytecode_mop_size() -> int\n"
        "\n"
        "def VM.rethrow(self)\n"
        "  -- If the stack has an error, raise it in this context.\n"
        "  if self.has_error\n"
        "    error(self.error_message)\n"
        "def VM.id(self) -> int\n"
        "def VM.init(self, Func func)\n"
        "def VM.has_incoming_state(self) -> bool\n"
        "\n"
        "def VM.env(self, name) -> any\n"
        "def VM.env_map(self) -> Map\n"
        "def VM.set_env(self, any name, any val)\n"
        "def VM.set_env_map(self, Map map)\n"
        "\n"
        "def VM.init_env(self)\n"
        "  self.set_env_map(Map.make)\n"
        "\n"
        "def VM.modify_env(self, Func func)\n"
        "  new = func.call(self.env_map)\n"
        "  self.set_env_map(new)\n"
        "\n"
        "def VM.append_hack(self, any hack)\n"
        "  self.modify_env((env) -> env.list_append(:hacks hack))\n"
        "\n"
        "def VM.forward_env(self, names :multiple)\n"
        "  for name in names\n"
        "    self.set_env(name env(name))\n"
        "\n"
        "def VM.init_channel(self, any name)\n"
        "  self.set_env(name, [])\n"
        "\n"
        "def VM.read_channel(self, any name)\n"
        "  out = self.env_map.get(name)\n"
        "  self.set_env(name, [])\n"
        "  return out\n"
        "\n"
        "def VM.get_watch_result(self, key) -> any\n"
        "def VM.stack_push(self, Block b, List inputs)\n"
        "  -- Push a new frame, using the given block and input list.\n"
        "def VM.stack_push2(self, Func func)\n"
        "  self.stack_push(func.block, [])\n"
        "def VM.stack_pop(self)\n"
        "  -- Pop the topmost frame.\n"
        "def VM.set_state_input(self, any)\n"
        "\n"
        "def VM.get_state(self) -> any\n"
        "def VM.set_state(self, any)\n"
        "\n"
        "def VM.migrate(self, Block from, Block to)\n"
        "def VM.migrate_to(self, Func func)\n"
        "  -- Use 'func' as the new root, and migrate data and state.\n"
        "def VM.reset(self)\n"
        "def VM.reset_state(self)\n"
        "def VM.restart(self)\n"
        "\n"
        "def VM.frame_list(self) -> List\n"
        "def VM.slot(self, index) -> any\n"
        "\n"
        "def VM.active_value(self, Term term) -> any\n"
        "  self.top.active_value(term)\n"
        "\n"
        "def VM.set_active_value(self, Term term, any val)\n"
        "  self.top.set_active_value(term, val)\n"
        "\n"
        "def VM.output(self, int index) -> any\n"
        "  -- Fetch the value in the nth output register.\n"
        "\n"
        "def VM.errored(self) -> bool\n"
        "  -- Returns true if the interpreter has stopped due to error.\n"
        "\n"
        "def VM.has_error(self) -> bool\n"
        "  self.errored\n"
        "\n"
        "def VM.error_message(self) -> String\n"
        "  -- If there is a recorded error, returns a human-readable description string.\n"
        "\n"
        "def VM.toString(self) -> String\n"
        "\n"
        "def VM.perf_stats(self) -> Map\n"
        "\n"
        "def make_vm(Func func) -> VM\n"
        "  -- Create a new VM\n"
        "\n"
        "def Func.to_vm(self) -> VM\n"
        "  make_vm(self)\n"
        "\n"
        "def repeat(any val, int count) -> List\n"
        "\n"
        "def int.to_hex_string(val) -> String\n"
        "\n"
        "def List.append(self, any item) -> List\n"
        "  -- Append an item to the end of this list.\n"
        "\n"
        "def List.by_pairs(self) -> List\n"
        "  out = []\n"
        "  for i in range(0, self.length // 2)\n"
        "    @out.append(1)\n"
        "\n"
        "  if true\n"
        "    @out.append(2)\n"
        "\n"
        "  []\n"
        "\n"
        "def List.clear(self) -> List\n"
        "  -- Return an empty list.\n"
        "  []\n"
        "\n"
        "def List.concat(self, List rightSide) -> List\n"
        "  -- Concatenate two lists.\n"
        "\n"
        "def List.contains(self, any val) -> bool\n"
        "  for i in self\n"
        "    if i == val\n"
        "      return true\n"
        "  return false\n"
        "\n"
        "def List.resize(self, int length) -> List\n"
        "  -- Resize the list to have the given length. If the length is increased, then\n"
        "  -- null values are appended on the right; if the length is decreased then\n"
        "  -- existing values on the right are dropped.\n"
        "\n"
        "def List.count(self) -> int\n"
        "  -- Return the number of elements in this list.\n"
        "\n"
        "def List.insert(self, int index, any val) -> List\n"
        "  -- Insert an element at the given index. If necessary, existing elements will\n"
        "  -- be shifted to the right to make room.\n"
        "  --\n"
        "  -- Example:\n"
        "  --   a = [1 2 3]\n"
        "  --   a.insert(1, 'X')\n"
        "  --   -- a now equals [1 'X' 2 3]\n"
        "\n"
        "def List.prepend(self, any val) -> List\n"
        "  self.insert(0, val)\n"
        "    \n"
        "def List.length(self) -> int\n"
        "  -- Return the number of elements in this list.\n"
        "\n"
        "def List.join(self, String joiner) -> String\n"
        "  -- Return a string constructed by converting every element to a string, and\n"
        "  -- concatenating those strings, each separated by 'joiner'.\n"
        "  --\n"
        "  -- Example:\n"
        "  --  [1 2 3].join(', ')\n"
        "  -- \n"
        "  -- Outputs: '1, 2, 3'\n"
        "\n"
        "def List.split(self, boundaryValue) -> List\n"
        "  out = [[]]\n"
        "  for item in self\n"
        "    if item == boundaryValue\n"
        "      @out.append([])\n"
        "    else\n"
        "      @out.modify(out.length - 1, (el) -> el.append(item))\n"
        "  out\n"
        "\n"
        "def List.slice(self, int start, int fin) -> List\n"
        "  -- Return a list constructed from the elements starting from index 'start', and\n"
        "  -- ending immediately before index 'fin'.\n"
        "  --\n"
        "  -- If either 'start' or 'fin' is negative, it's interpreted as an offset from the\n"
        "  -- end of the list.\n"
        "  --\n"
        "  -- Examples:\n"
        "  --  [1 2 3 4].slice(1 3)\n"
        "  --  Outputs: [2 3]\n"
        "  -- \n"
        "  --  [1 2 3 4].slice(0 -2)\n"
        "  --  Outputs: [1 2 3 4]\n"
        "\n"
        "def List.get(self, int index) -> any\n"
        "  -- Get an element by index.\n"
        "\n"
        "def List.get_opt(self, int index, any fallback) -> any\n"
        "  -- Get an element by index if it exists, otherwise return 'fallback'.\n"
        "  if index < 0 or index >= self.length\n"
        "    fallback\n"
        "  else\n"
        "    self.get(index)\n"
        "\n"
        "def List.set(self, int index, any val) -> List\n"
        "  -- Set an element by index.\n"
        "\n"
        "def List.remove(self, int index) -> List\n"
        "  -- Remove an element at the given index, shrinking the list by 1.\n"
        "\n"
        "def List.modify(self, int index, Func func)\n"
        "  self.set(index, func.call(self.get(index)))\n"
        "\n"
        "def List.add(self, any value) -> List\n"
        "  if is_compound(value)\n"
        "    for i,el in self { el + value[i] }\n"
        "  else\n"
        "    for el in self { el + value }\n"
        "\n"
        "def List.sub(self, any value) -> List\n"
        "  if is_compound(value)\n"
        "    for i,el in self { el - value[i] }\n"
        "  else\n"
        "    for el in self { el - value }\n"
        "\n"
        "def List.mult(self, any value) -> List\n"
        "  if is_compound(value)\n"
        "    for i,el in self { el * value[i] }\n"
        "  else\n"
        "    for el in self { el * value }\n"
        "\n"
        "def List.div(self, any value) -> List\n"
        "  if is_compound(value)\n"
        "    for i,el in self { el / value[i] }\n"
        "  else\n"
        "    for el in self { el / value }\n"
        "\n"
        "def List.cycle(self, int index) -> any\n"
        "  -- Get an element by index. If the index is out of bounds, then modulo the\n"
        "  -- index to one that exists.\n"
        "  self.get(mod(index, self.length))\n"
        "\n"
        "def List.empty(self) -> bool\n"
        "  -- Returns whether the list is empty.\n"
        "  self.length == 0\n"
        "\n"
        "def List.first(self) -> any\n"
        "  -- Returns the first element\n"
        "  self.get(0)\n"
        "\n"
        "def List.last(self) -> any\n"
        "  -- Returns the last element\n"
        "  self.get(self.length - 1)\n"
        "\n"
        "def List.push(self, val) -> List\n"
        "  self.append(val)\n"
        "\n"
        "def List.pop(self) -> List\n"
        "  self.slice(0, -1)\n"
        "\n"
        "def List.filter(self, Func func) -> List\n"
        "  result = []\n"
        "  for i in self\n"
        "    if func.call(i)\n"
        "      @result.append(i)\n"
        "  result\n"
        "\n"
        "def List.flatten(self) -> List\n"
        "  -- Take a list of lists, and concat them all into one list.\n"
        "  out = []\n"
        "  for el in self\n"
        "    @out.concat(el)\n"
        "  out\n"
        "\n"
        "def List.each(self, Func func) -> List\n"
        "  for i in self\n"
        "    func.call(i)\n"
        "\n"
        "def List.apply(self, int index, Func func) -> List\n"
        "  self.set(index, func.call(self[index]))\n"
        "  \n"
        "{-\n"
        "interface Iterator\n"
        "  def current() -> any\n"
        "  def done() -> bool\n"
        "  def advance() -> Iterator\n"
        "-}\n"
        "\n"
        "\n"
        "def Map.contains(self, any key) -> bool\n"
        "  -- Returns true if the map contains the given key.\n"
        "\n"
        "def Map.remove(self, any key) -> Map\n"
        "  -- Removes the given key from the map.\n"
        "\n"
        "def Map.get(self, any key) -> any\n"
        "  -- Gets the key associated with this value.\n"
        "\n"
        "def Map.get_opt(self, any key, any default) -> any\n"
        "  if self.contains(key)\n"
        "    self.get(key)\n"
        "  else\n"
        "    default\n"
        "    \n"
        "def Map.set(self, any key, any value) -> Map\n"
        "  -- Sets the value associated with this key.\n"
        "\n"
        "def Map.empty(self) -> bool\n"
        "  -- Whether the map has no values\n"
        "\n"
        "def Map.apply(self, any key, Func func) -> Map\n"
        "  self.set(key, func.call(self.get(key)))\n"
        "\n"
        "def Map.modify(self, any key, Func func) -> Map\n"
        "  self.set(key, func.call(self.get(key)))\n"
        "\n"
        "def Map.list_append(self, any key, any value) -> Map\n"
        "  if self.contains(key)\n"
        "    self.modify(key, (l) -> l.append(value))\n"
        "  else\n"
        "    self.set(key, [value])\n"
        "\n"
        "def Map.bucketize(self, List list, Func getKey) -> Map\n"
        "  for el in list\n"
        "    @self.list_append(getKey.call(el), el)\n"
        "\n"
        "  -- language defect, shouldn't be required:\n"
        "  self\n"
        "\n"
        "def Map.keys(self) -> List\n"
        "\n"
        "struct Set {\n"
        "  Map m\n"
        "}\n"
        "\n"
        "def Set.add(self, element) -> Set\n"
        "  @self.m.set(element, true)\n"
        "\n"
        "def Set.contains(self, element) -> bool\n"
        "  self.m.contains(element)\n"
        "\n"
        "def Set.remove(self, element) -> Set\n"
        "  @self.m.remove(element)\n"
        "\n"
        "def Set.elements(self) -> List\n"
        "  self.m.keys\n"
        "\n"
        "def List.to_set(self) -> Set\n"
        "  set = make(Set)\n"
        "  for item in self\n"
        "    @set.add(item)\n"
        "  set\n"
        "\n"
        "def String.append(self, String right) -> String\n"
        "  -- Append a string to the right side.\n"
        "  str(self right)\n"
        "\n"
        "def String.prepend(self, String left) -> String\n"
        "  str(left self)\n"
        "    \n"
        "def String.char_at(self, int index) -> String\n"
        "  -- Get character at a given index. UTF unsafe.\n"
        "\n"
        "def String.index_of(self, String substr) -> any\n"
        "  for i in 0..self.length\n"
        "    if self.substr(i, substr.length) == substr\n"
        "      return i\n"
        "  return null\n"
        "\n"
        "def String.ends_with(self, String suffix) -> bool\n"
        "  -- Return true if this string ends with the given substring.\n"
        "\n"
        "def String.char_code(self) -> int\n"
        "def String.from_char_code(self, int code) -> String\n"
        "\n"
        "def String.length(self) -> int\n"
        "  -- Returns the string length.\n"
        "\n"
        "def String.slice(self, int start, int fin) -> String\n"
        "\n"
        "def String.starts_with(self, String prefix) -> bool\n"
        "  -- Returns true if the string starts with the given prefix.\n"
        "\n"
        "def String.split(self, String sep) -> List\n"
        "\n"
        "def String.substr(self, int start, int length) -> String\n"
        "\n"
        "def String.to_camel_case(self) -> String\n"
        "  -- Deprecated function\n"
        "\n"
        "def String.to_lower(self) -> String\n"
        "\n"
        "def String.to_upper(self) -> String\n"
        "\n"
        "def String.to_number(self) -> number\n"
        "def String.to_int(self) -> int\n"
        "\n"
        "def String.characters(self) -> List\n"
        "    out = for i in 0..(self.length)\n"
        "        self.char_at(i)\n"
        "    return out\n"
        "\n"
        "-- Type\n"
        "def Type.declaringTerm(self) -> Term\n"
        "        \n"
        "def Type.make(self, any values :multiple) -> any\n"
        "def Type.name(self) -> String\n"
        "def Type.property(self, String name) -> any\n"
        "def Type.includes(self, value) -> bool\n"
        "  result = cast(value self)\n"
        "  result != null\n"
        "\n"
        "def Type.cast(self, any value) -> any\n"
        "  result = cast(value, self)\n"
        "  if result == null\n"
        "    error(str(\"Couldn't cast value \" value \" to type \" self.name))\n"
        "  result\n"
        "\n"
        "def Term.assign(self, any val)\n"
        "def Term.asint(self) -> int\n"
        "def Term.asfloat(self) -> number\n"
        "def Term.index(self) -> int\n"
        "def Term.contents(self) -> Block\n"
        "    -- Fetch the nested Block contents of this Term. The format and the meaning\n"
        "    -- of these contents is dictated by the term's function.\n"
        "def Term.is_input(self) -> bool\n"
        "def Term.is_null(self) -> bool\n"
        "    -- Returns whether this is a null Term reference.\n"
        "def Term.is_output(self) -> bool\n"
        "def Term.name(self) -> String\n"
        "    -- Return this term's local name. May be blank.\n"
        "def Term.parent(self) -> Block\n"
        "def Term.to_string(self) -> String\n"
        "def Term.unique_name(self) -> any\n"
        "def Term.function(self) -> Block\n"
        "    -- Fetch this term's function.\n"
        "def Term.get_type(self) -> Type\n"
        "    -- Fetch the declared type of this term.\n"
        "def Term.id(self) -> int\n"
        "def Term.value(self) -> any\n"
        "    -- For a value term, this fetches the actual value.\n"
        "def Term.set_value(self, any val)\n"
        "    -- For a value term, permanently change the value.\n"
        "def Term.input(self, int index) -> Term\n"
        "    -- Fetch an input term by index.\n"
        "def Term.inputs(self) -> List\n"
        "    -- Return a list of input terms.\n"
        "def Term.num_inputs(self) -> int\n"
        "    -- Return the number of inputs.\n"
        "def Term.source_location(self) -> Rect_i\n"
        "    -- Return a Rect_i that describes where this term occurs in its source file.\n"
        "def Term.location_string(self) -> String\n"
        "def Term.global_id(self) -> int\n"
        "    -- Fetch this term's global identifier.\n"
        "\n"
        "def Term.properties(self) -> Map\n"
        "\n"
        "def Term.has_property(self, Symbol key) -> bool\n"
        "def Term.property(self, Symbol key) -> any\n"
        "    -- Fetch a term property.\n"
        "def Term.property_opt(self, Symbol key, default) -> any\n"
        "    -- Fetch an optional term property.\n"
        "\n"
        "def Term.input_property(self, int index, Symbol key) -> any\n"
        "def Term.input_property_opt(self, int index, Symbol key, any default) -> any\n"
        "def Term.has_input_property(self, int index, Symbol key) -> bool\n"
        "\n"
        "def Term.is_value(self) -> bool\n"
        "def Term.is_function(self) -> bool\n"
        "    self.get_type == Func\n"
        "def Term.is_func_decl(self) -> bool\n"
        "    self.function == function_decl.block\n"
        "def Term.has_name(term) -> bool\n"
        "  term.name != ''\n"
        "def Term.is_hidden(term) -> bool\n"
        "  term.property_opt(:Hidden, false)\n"
        "def Term.is_statement(term) -> bool\n"
        "  term.property_opt(:Statement, false)\n"
        "def Term.is_type(self) -> bool\n"
        "    self.is_value and is_type(self.value)\n"
        "def Term.is_input_placeholder(self) -> bool\n"
        "    self.function == input_placeholder.block\n"
        "def Term.is_comment(self) -> bool\n"
        "    self.function == comment.block\n"
        "def Term.trace_dependents(self, Block untilBlock) -> List\n"
        "def Term.output(self, int index) -> Term\n"
        "  if index == 0\n"
        "    self\n"
        "  else\n"
        "    self.extra_output(index - 1)\n"
        "def Term.extra_output(self, int index)\n"
        "  self.parent.get_term(self.index + index + 1)\n"
        "\n"
        "def vec2(number x, number y)\n"
        "  Vec2.make(x y)\n"
        "\n"
        "def Vec2.add(self, rhs) -> Vec2\n"
        "  rvec = cast(rhs, Vec2)\n"
        "  if rvec != null\n"
        "    [self.x + rvec.x, self.y + rvec.y]\n"
        "  else\n"
        "    [self.x + rhs, self.y + rhs]\n"
        "\n"
        "def Vec2.sub(self, rhs) -> Vec2\n"
        "  rvec = cast(rhs, Vec2)\n"
        "  if rvec != null\n"
        "    [self.x - rvec.x, self.y - rvec.y]\n"
        "  else\n"
        "    [self.x - rhs, self.y - rhs]\n"
        "\n"
        "def Vec2.mult(self, rhs) -> Vec2\n"
        "  rvec = cast(rhs, Vec2)\n"
        "  if rvec != null\n"
        "    [self.x * rvec.x, self.y * rvec.y]\n"
        "  else\n"
        "    [self.x * rhs, self.y * rhs]\n"
        "\n"
        "def Vec2.div(self, rhs) -> Vec2\n"
        "  rvec = cast(rhs, Vec2)\n"
        "  if rvec != null\n"
        "    [self.x / rvec.x, self.y / rvec.y]\n"
        "  else\n"
        "    [self.x / rhs, self.y / rhs]\n"
        "    \n"
        "def Vec2.distance(self, Vec2 b) -> number\n"
        "  -- Returns the distance between self and b.\n"
        "  sqrt(sqr(self.x - b.x) + sqr(self.y - b.y))\n"
        "\n"
        "def Vec2.distance_sqr(self, Vec2 b) -> number\n"
        "  sqr(self.x - b.x) + sqr(self.y - b.y)\n"
        "\n"
        "def Vec2.magnitude(self) -> number\n"
        "  -- Return the magnitude of this point, aka the distance to the origin.\n"
        "  sqrt(sqr(self.x) + sqr(self.y))\n"
        "\n"
        "def Vec2.magnitude_sqr(self) -> number\n"
        "  sqr(self.x) + sqr(self.y)\n"
        "\n"
        "def Vec2.norm(self) -> Vec2\n"
        "  -- Returns the point normalized to be along the unit circle.\n"
        "  m = self.magnitude\n"
        "  [self.x / m, self.y / m]\n"
        "\n"
        "def Vec2.perpendicular(self) -> Vec2\n"
        "  -- Returns a perpendicular vector, rotated clockwise.\n"
        "  [self.y -self.x]\n"
        "\n"
        "def Vec2.translate(self, Vec2 b) -> Vec2\n"
        "  [self.x + b.x, self.y + b.y]\n"
        "\n"
        "def Vec2.to_rect_center(self, Vec2 size) -> Rect\n"
        "  -- Returns a Rect with this point as the center, and the given size.\n"
        "  size_half = (size * 0.5) -> Vec2.cast\n"
        "  [self.x - size_half.x,\n"
        "      self.y - size_half.y, self.x + size_half.x, self.y + size_half.y]\n"
        "\n"
        "def Vec2.to_rect_topleft(self, Vec2 size) -> Rect\n"
        "  -- Returns a Rect with this point as the top-left, and the given size.\n"
        "  [self.x, self.y, self.x + size.x, self.y + size.y]\n"
        "\n"
        "def Vec2.delta(self) -> Vec2\n"
        "  -- Stateful function, returns the point difference since the last step.\n"
        "  state Vec2 prev = self\n"
        "  result = [self.x - prev.x, self.y - prev.y]\n"
        "  prev = self\n"
        "  result\n"
        "\n"
        "def Vec2.rotate(self, number rotation) -> Vec2\n"
        "  -- Return the point rotated around [0 0] by the given angle.\n"
        "  [self.x*cos(rotation) - self.y*sin(rotation), self.x*sin(rotation)+self.y*cos(rotation)]\n"
        "\n"
        "def vec3(number x, number y, number z)\n"
        "  Vec3.make(x y z)\n"
        "def Vec3.add(self, Vec3 b) -> Vec3\n"
        "  [self.x + b.x, self.y + b.y, self.z + b.z]\n"
        "def Vec3.sub(self, Vec3 b) -> Vec3\n"
        "  [self.x - b.x, self.y - b.y, self.z - b.z]\n"
        "def Vec3.mult(self, number s) -> Vec3\n"
        "  [self.x * s, self.y * s, self.z * s]\n"
        "def Vec3.div(self, number s) -> Vec3\n"
        "  [self.x / s, self.y / s, self.z / s]\n"
        "\n"
        "def vec4(number x, number y, number z, number w)\n"
        "  Vec4.make(x y z w)\n"
        "\n"
        "def Rect.add(self, Rect b) -> Rect\n"
        "  [self.x1 + b.x1, self.y1 + b.y1, self.x2 + b.x2, self.y2 + b.y2]\n"
        "def Rect.sub(self, Rect b) -> Rect\n"
        "  [self.x1 - b.x1, self.y1 - b.y1, self.x2 - b.x2, self.y2 - b.y2]\n"
        "def Rect.mult(self, number s) -> Rect\n"
        "  [self.x1 * s, self.y1 * s, self.x2 * s, self.y2 * s]\n"
        "def Rect.div(self, number s) -> Rect\n"
        "  [self.x1 / s, self.y1 / s, self.x2 / s, self.y2 / s]\n"
        "\n"
        "def Rect.width(self) -> number\n"
        "  self.x2 - self.x1\n"
        "def Rect.height(self) -> number\n"
        "  self.y2 - self.y1\n"
        "def Rect.size(self) -> Vec2\n"
        "  [self.width self.height]\n"
        "def Rect.left(self) -> number\n"
        "  self.x1\n"
        "def Rect.top(self) -> number\n"
        "  self.y1\n"
        "def Rect.right(self) -> number\n"
        "  self.x2\n"
        "def Rect.bottom(self) -> number\n"
        "  self.y2\n"
        "def Rect.top_left(self) -> Vec2\n"
        "  -- Returns the top-left coordinates as a Vec2.\n"
        "  [self.x1 self.y1]\n"
        "def Rect.top_right(self) -> Vec2\n"
        "  -- Returns the top-rigth coordinates as a Vec2.\n"
        "  [self.x2 self.y1]\n"
        "def Rect.bottom_left(self) -> Vec2\n"
        "  -- Returns the bottom-left coordinates as a Vec2.\n"
        "  [self.x1 self.y2]\n"
        "def Rect.bottom_center(self) -> Vec2\n"
        "  [(self.x1+self.x2)/2, self.y2]\n"
        "def Rect.bottom_right(self) -> Vec2\n"
        "  -- Returns the bottom-right coordinates as a Vec2.\n"
        "  [self.x2 self.y2]\n"
        "def Rect.center(self) -> Vec2\n"
        "  -- Returns the rectangle's center as a Vec2\n"
        "  [(self.x1 + self.x2) / 2, (self.y1 + self.y2) / 2]\n"
        "def Rect.points_cw(self) -> List\n"
        "  [self.top_left self.top_right self.bottom_right self.bottom_left]\n"
        "def Rect.points_ccw(self) -> List\n"
        "  [self.top_left self.bottom_left self.bottom_right self.top_right]\n"
        "\n"
        "def Rect.intersects(self, Rect b) -> bool\n"
        "  -- Return whether the two rectangles intersect.\n"
        "  intersects_on_x = (self.x2 > b.x1) and (b.x2 > self.x1)\n"
        "  intersects_on_y = (self.y2 > b.y1) and (b.y2 > self.y1)\n"
        "  intersects_on_x and intersects_on_y\n"
        "\n"
        "def Rect.translate(self, Vec2 p) -> Rect\n"
        "  [self.x1 + p.x, self.y1 + p.y, self.x2 + p.x, self.y2 + p.y]\n"
        "\n"
        "def Rect.contains(self, Vec2 p) -> bool\n"
        "  p.x >= self.x1 and p.y >= self.y1 and p.x < self.x2 and p.y < self.y2\n"
        "\n"
        "def Rect.grow(self, Vec2 size) -> Rect\n"
        "  [self.x1 - size.x, self.y1 - size.y, self.x2 + size.x, self.y2 + size.y]\n"
        "\n"
        "def Rect.grow_s(self, number size) -> Rect\n"
        "  [self.x1 - size, self.y1 - size, self.x2 + size, self.y2 + size]\n"
        "\n"
        "def Rect.subtractFrom(self, Symbol side, number dimension) -> List\n"
        "  if side == :top\n"
        "    min(@dimension, self.height)\n"
        "    out = self.set_y2(dimension)\n"
        "    self.y1 += dimension\n"
        "    return [self, out]\n"
        "  if side == :left\n"
        "    min(@dimension, self.width)\n"
        "    out = self.set_x2(self.x1 + dimension)\n"
        "    self.x1 += dimension\n"
        "    return [self, out]\n"
        "  if side == :right\n"
        "    min(@dimension, self.width)\n"
        "    out = self.set_x1(self.x2 - dimension)\n"
        "    self.x2 -= dimension\n"
        "    return [self, out]\n"
        "  if side == :bottom\n"
        "    min(@dimension, self.height)\n"
        "    out = self.set_y1(self.y2 - dimension)\n"
        "    self.y2 -= dimension\n"
        "    return [self, out]\n"
        "  error(str('Unrecognized side: ' side))\n"
        "\n"
        "def sum(numbersSeq)\n"
        "  result = 0\n"
        "  for i in numbersSeq\n"
        "    result += i\n"
        "  result\n"
        "    \n"
        "def zip(List left, List right) -> List\n"
        "  for i,l in left\n"
        "    [l, right.get_opt(i, null)]\n"
        "\n"
        "-- Stateful functions\n"
        "\n"
        "def cached(Func refresh) -> any\n"
        "  -- Cache a function's result, the function will only be (re)evaluated as needed.\n"
        "\n"
        "  state Func prev_refresh\n"
        "  state prev_version = global_script_version()\n"
        "  state out\n"
        "  if prev_refresh != refresh or prev_version != global_script_version()\n"
        "    prev_refresh = refresh\n"
        "    prev_version = global_script_version()\n"
        "    out = refresh.call()\n"
        "  out\n"
        "\n"
        "def changed(any val) -> bool\n"
        "  -- Stateful function; returns true if the value has changed since the\n"
        "  -- previous step.\n"
        "  state any prev = null\n"
        "  result = prev != val\n"
        "  prev = val\n"
        "  result\n"
        "\n"
        "def delta(number val) -> number\n"
        "  -- Stateful function, return the difference between this value and the value from\n"
        "  -- the previous call.\n"
        "  state number prev = val\n"
        "  result = val - prev\n"
        "  prev = val\n"
        "  result\n"
        "\n"
        "def toggle(bool tog) -> bool\n"
        "  -- Stateful function, returns a boolean status. Every frame the function is called\n"
        "  -- with (true), the result flips. Starts out false.\n"
        "\n"
        "  state bool s = false\n"
        "  if tog\n"
        "    s = not(s)\n"
        "  s\n"
        "\n"
        "def approach(number target, number maximum_change) -> number\n"
        "  -- Stateful function, returns a result which approaches 'target'. Each time the\n"
        "  -- function is called, the result will change at most by 'maximum_change'.\n"
        "  state current = target\n"
        "  if target > current\n"
        "    current += min(maximum_change, target - current)\n"
        "  elif target < current\n"
        "    current -= min(maximum_change, current - target)\n"
        "  current\n"
        "\n"
        "def once() -> bool\n"
        "  -- Stateful function, returns true the first time it's called, and false thereafter.\n"
        "  state bool s = true\n"
        "  result = s\n"
        "  s = false\n"
        "  result\n"
        "\n"
        "def cycle(int max) -> int\n"
        "  -- Stateful function, cycles though the integers from 0 to (max - 1). When the\n"
        "  -- maximum is reached, the function will start again at 0.\n"
        "\n"
        "  state int counter = 0\n"
        "  if counter >= max\n"
        "    counter = 0\n"
        "  result = counter\n"
        "  counter += 1\n"
        "  result\n"
        "\n"
        "def cycle_elements(List list) -> any\n"
        "  -- Stateful function, cycles through each item of 'list' one at a time.\n"
        "  list[cycle(length(list))]\n"
        "\n"
        "def random_element(List list) -> any\n"
        "  -- Return a random element from the given list, with equal probability per element.\n"
        "  list[rand_i(length(list))]\n"
        "\n"
        "def seed() -> number\n"
        "  -- Stateful function, returns a random number 0..1 which doesn't change after\n"
        "  -- initialization.\n"
        "  state number s = rand()\n"
        "  s\n"
        "\n"
        "-- Math utility functions\n"
        "def polar(number angle) -> Vec2\n"
        "  -- Return a point on the unit circle with the given angle.\n"
        "  [cos(angle) sin(angle)]\n"
        "\n"
        "def random_norm_vector() -> Vec2\n"
        "  -- Return a random normalized vector.\n"
        "  angle = rand() * 360\n"
        "  [cos(angle) sin(angle)]\n"
        "\n"
        "def rect(number x1, number y1, number x2, number y2) -> Rect\n"
        "  [x1 y1 x2 y2]\n"
        "\n"
        "def bezier3(number t, List points) -> Vec2\n"
        "  -- Quadratic bezier curve, with 3 control points. t must be in the range of [0, 1].\n"
        "  p0 = points[0] -> Vec2.cast\n"
        "  p1 = points[1] -> Vec2.cast\n"
        "  p2 = points[2] -> Vec2.cast\n"
        "  (p0 * sqr(1 - t) + p1 * (2 * t * (1 - t)) + p2 * sqr(t))\n"
        "\n"
        "def bezier4(number t, List points) -> Vec2\n"
        "  -- Cubic bezier curve, with 4 control points. t must be in the range of [0, 1].\n"
        "  p0 = points[0] -> Vec2.cast\n"
        "  p1 = points[1] -> Vec2.cast\n"
        "  p2 = points[2] -> Vec2.cast\n"
        "  p3 = points[3] -> Vec2.cast\n"
        "  (p0 * cube(1 - t) + p1 * (3 * t * sqr(1 - t)) + p2 * sqr(t) * (3 * (1 - t)) + p3 * cube(t))\n"
        "\n"
        "def smooth_in_out(number t, number smooth_in, number smooth_out) -> number\n"
        "  bezier4(t, [[0 0] [smooth_in, 0] [1 - smooth_out, 1] [1 1]]).y\n"
        "\n"
        "def clamp(number x, number minVal, number maxVal) -> number\n"
        "  -- Return a clamped value. If x is less than 'minVal' then return 'minVal', if it's\n"
        "  -- greater than 'maxVal' then return 'maxVal', otherwise return the original 'x'.\n"
        "  min(max(x, minVal), maxVal)\n"
        "\n"
        "def smoothstep(number x, number edge0, number edge1) -> number\n"
        "  -- Smooth interpolation func, see en.wikipedia.org/wiki/Smoothstep\n"
        "  x = clamp((x - edge0)/(edge1-edge0), 0, 1)\n"
        "  x*x*(3 - 2*x)\n"
        "\n"
        "def smootherstep(number x, number edge0, number edge1) -> number\n"
        "  -- Alternative to smoothstep by Ken Perlin, see en.wikipedia.org/wiki/Smoothstep\n"
        "  x = clamp((x - edge0)/(edge1-edge0), 0, 1)\n"
        "  x*x*x*(x*(x*6 - 15) + 10)\n"
        "\n"
        "def random_color() -> Color\n"
        "  -- Return a color with random RGB components.\n"
        "  [rand() rand() rand() 1.0]\n"
        "\n"
        "def hsv_to_rgb(List hsv) -> Color\n"
        "  -- Convert HSV components to an RGB Color\n"
        "\n"
        "  h = hsv[0] -> number.cast\n"
        "  s = hsv[1] -> number.cast\n"
        "  v = hsv[2] -> number.cast\n"
        "\n"
        "  if s == 0\n"
        "      -- grey\n"
        "      return [v v v 1]\n"
        "\n"
        "  h *= 6\n"
        "  i = floor(h)\n"
        "  f = h - i\n"
        "  p = v * (1 - s)\n"
        "  q = v * (1 - s * f)\n"
        "  t = v * (1 - s * (1 - f))\n"
        "\n"
        "  if i == 0\n"
        "    [v t p 1]\n"
        "  elif i == 1\n"
        "    [q v p 1]\n"
        "  elif i == 2\n"
        "    [p v t 1]\n"
        "  elif i == 3\n"
        "    [p q v 1]\n"
        "  elif i == 4\n"
        "    [t p v 1]\n"
        "  elif i == 5\n"
        "    [v p q 1]\n"
        "  else\n"
        "    [0 0 0 0]\n"
        "\n"
        "def hsl_color(number h, number s, number l) -> Color\n"
        "  if s == 0\n"
        "    [1 1 1 1]\n"
        "  else\n"
        "    def hue_to_rgb(number p, number q, number t)\n"
        "      mod(@t 1)\n"
        "      if t < 1/6\n"
        "        p + (q - p) * 6 * t\n"
        "      elif t < 1/2\n"
        "        q\n"
        "      elif t < 2/3\n"
        "        p + (q - p) * (2/3 - t) * 6\n"
        "      else\n"
        "        p\n"
        "\n"
        "    q = if l < 0.5\n"
        "      l * (1 + s)\n"
        "    else\n"
        "      l + s - l * s\n"
        "\n"
        "    p = 2 * l - q\n"
        "    r = hue_to_rgb(p, q, h + 1/3)\n"
        "    g = hue_to_rgb(p, q, h)\n"
        "    b = hue_to_rgb(p, q, h - 1/3)\n"
        "    [r g b 1]\n"
        "\n"
        "def Color.add(self, any value) -> Color\n"
        "  for i in self { i + value }\n"
        "def Color.sub(self, any value) -> Color\n"
        "  for i in self { i - value }\n"
        "def Color.mult(self, any value) -> Color\n"
        "  for i in self { i * value }\n"
        "def Color.div(self, any value) -> Color\n"
        "  for i in self { i / value }\n"
        "\n"
        "def Color.blend(self, Color rhs, number ratio) -> Color\n"
        "  -- Return a color that is blended between self and rhs. If ratio is 0.0 we'll\n"
        "  -- return 'self', if it's 1.0 we'll return 'rhs'.\n"
        "\n"
        "  max(@ratio, 0.0)\n"
        "  min(@ratio, 1.0)\n"
        "\n"
        "  if ratio == 0.0\n"
        "    self\n"
        "  elif ratio == 1.0\n"
        "    rhs\n"
        "  else\n"
        "    self + (rhs - self) * ratio\n"
        "\n"
        "def Color.lighten(self, number factor) -> Color\n"
        "  -- Linearly lighten each component of the color.\n"
        "  [ min(self.r + factor, 1.0)\n"
        "    min(self.g + factor, 1.0)\n"
        "    min(self.b + factor, 1.0)\n"
        "    self.a]\n"
        "        \n"
        "def Color.darken(self, number factor) -> Color\n"
        "  -- Linearly darken each component of the color.\n"
        "  [ max(self.r - factor, 0.0)\n"
        "    max(self.g - factor, 0.0)\n"
        "    max(self.b - factor, 0.0)\n"
        "    self.a]\n"
        "\n"
        "def weighted_rand(List choices :multiple) -> any\n"
        "  total = 0\n"
        "  for choice in choices\n"
        "    weight = choice[0]\n"
        "    total += weight\n"
        "\n"
        "  r = rand() * total\n"
        "  for choice in choices\n"
        "    r -= choice[0]\n"
        "    if r < 0\n"
        "      return choice[1]\n"
        "\n"
        "  return null\n"
        "\n"
        "def rand_gaussian()\n"
        "  -- Box-Muller transform\n"
        "\n"
        "  rand1 = -2 * log(rand())\n"
        "  rand2 = (rand()) * 360\n"
        "  sqrt(rand1) * cos(rand2)\n"
        "\n"
        "def number.map(x, Vec2 fromRange, Vec2 toRange)\n"
        "  ratio = (x - fromRange[0]) / (fromRange[1] - fromRange[0])\n"
        "  (toRange[0] + ratio * (toRange[1] - toRange[0]))\n"
        "\n"
        "def int.map(x, Vec2 fromRange, Vec2 toRange)\n"
        "  ratio = (x - fromRange[0]) / (fromRange[1] - fromRange[0])\n"
        "  (toRange[0] + ratio * (toRange[1] - toRange[0]))\n"
        "\n"
        "def noise(number x)\n"
        "  -- Perlin noise\n"
        "\n"
        "-- Codechange objects\n"
        "def codechange_set_value(Term target, any newValue) -> List\n"
        "  [:set_value target newValue]\n"
        "\n"
        "def debug_break()\n"
        ;

    if (strncmp(filename, "$builtins/match/main.ca", 23) == 0) return
        "\n"
        "def match_list(list, pattern) -> bool\n"
        "  if not is_list(list)\n"
        "    return false\n"
        "\n"
        "  if list.length != pattern.length\n"
        "    return false\n"
        "\n"
        "  for index, item in list\n"
        "    patternItem = pattern[index]\n"
        "    switch\n"
        "      case is_type(patternItem)\n"
        "        if not patternItem.includes(item)\n"
        "          return false\n"
        "      else\n"
        "        if item != patternItem\n"
        "          return false\n"
        "\n"
        "  return true\n"
        ;

    if (strncmp(filename, "$builtins/stack_trace/main.ca", 29) == 0) return
        "\n"
        "require indent_writer\n"
        "\n"
        "def Block.name(self) -> String\n"
        "  if self.owner.is_null\n"
        "    \"\"\n"
        "  else\n"
        "    self.owner.name\n"
        "\n"
        "def Term.parent_major(self) -> Block\n"
        "  self.parent.nearest_major\n"
        "\n"
        "def Term.location_str(self) -> String\n"
        "  if self.is_null\n"
        "    return \"\"\n"
        "\n"
        "  loc = self.source_location\n"
        "  s = str(self.parent.source_filename ':' loc.y1)\n"
        "\n"
        "  blockName = self.parent_major.name\n"
        "  if blockName != \"\"\n"
        "    @s.append(str(' inside ' blockName '()'))\n"
        "  s\n"
        "\n"
        "def trace_to_string(VM vm) -> String\n"
        "  writer = indent_writer.new\n"
        "\n"
        "  for frame in vm.frame_list.filter((f) -> not f.current_term.is_null)\n"
        "\n"
        "    term = frame.current_term\n"
        "\n"
        "    @writer.write('[' term.location_str '] ')\n"
        "\n"
        "    @writer.writeln\n"
        "    @writer.indent\n"
        "\n"
        "  if vm.has_error\n"
        "    @writer.write('Error: ' vm.slot(0))\n"
        "\n"
        "  writer.toString\n"
        "\n"
        "def dump(VM vm)\n"
        "  trace_to_string(vm) | print\n"
        ;


    return NULL;
}

} // namespace circa

