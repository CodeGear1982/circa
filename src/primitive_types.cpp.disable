// Copyright 2008 Paul Hodge

#include "common_headers.h"
#include "cpp_interface.h"
#include "essentials.h"
#include "primitive_types.h"

namespace circa {

void empty_function(Term*) { }
void empty_duplicate_function(Term*,Term*) { }

int& as_int(Term* t)
{
    if (t->type != INT_TYPE)
        throw errors::TypeError(t, INT_TYPE);

    return *((int*) t->value);
}

float& as_float(Term* t)
{
    if (t->type != FLOAT_TYPE)
        throw errors::TypeError(t, FLOAT_TYPE);

    return *((float*) t->value);
}

bool& as_bool(Term* t)
{
    if (t->type != BOOL_TYPE)
        throw errors::TypeError(t, BOOL_TYPE);

    return *((bool*) t->value);
}

string& as_string(Term* t)
{
    if (t->type != STRING_TYPE)
        throw errors::TypeError(t, STRING_TYPE);

    if (t->value == NULL)
        throw errors::InternalError("NULL pointer in as_string");

    return *((string*) t->value);
}

std::string int__toString(Term* term)
{
    std::stringstream strm;
    strm << as_int(term);
    return strm.str();
}

std::string float__toString(Term* term)
{
    std::stringstream strm;
    strm << as_float(term);
    return strm.str();
}

std::string string__toString(Term* term)
{
    return as_string(term);
}

void bool_alloc(Term* caller)
{
    caller->value = new bool;
}

void bool_dealloc(Term* caller)
{
    delete (bool*) caller->value;
}

void bool_duplicate(Term* source, Term* dest)
{
    bool_alloc(dest);
    as_bool(dest) = as_bool(source);
}

std::string bool__toString(Term* term)
{
    if (as_bool(term))
        return "true";
    else
        return "false";
}

void reference_alloc(Term* caller)
{
    caller->value = NULL;
}
void reference_dealloc(Term* caller)
{
    caller->value = NULL;
}
void reference_duplicate(Term* source, Term* dest)
{
    dest->value = source->value;
}

} // namespace circa
