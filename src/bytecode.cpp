// Copyright (c) 2007-2010 Paul Hodge. All rights reserved.

#include "builtins.h"
#include "bytecode.h"
#include "debug.h"
#include "term.h"

namespace circa {
namespace bytecode {

size_t get_operation_size(Operation* op)
{
    switch (op->opid) {
        case OP_STACK_SIZE: return sizeof(StackSizeOperation);
        case OP_CALL: {
            CallOperation *callOp = (CallOperation*) op;
            return sizeof(CallOperation) + sizeof(CallOperation::Input)*callOp->numInputs;
        }
        case OP_RETURN: return sizeof(ReturnOperation);
    }
    ca_assert(false);
    return 0;
}

bool should_term_output_go_on_stack(Term* term)
{
    if (term->type == VOID_TYPE)
        return false;

    // Other stuff to check here?
    
    return true;
}

bool should_term_generate_call(Term* term)
{
    if (term->function == COMMENT_FUNC)
        return false;

    return true;
}

size_t write_stack_size_op(char* opdata, int stacksize)
{
    StackSizeOperation* op = (StackSizeOperation*) opdata;
    op->opid = OP_STACK_SIZE;
    op->numElements = stacksize;
    return sizeof(StackSizeOperation);
}

size_t write_call_op(Term* term, char* data)
{
    size_t size = sizeof(CallOperation) + sizeof(CallOperation::Input)*term->numInputs();

    if (data != NULL) {
        CallOperation* op = (CallOperation*) data;
        op->opid = OP_CALL;
        op->caller = term;
        op->function = term->function;
        op->numInputs = term->numInputs();

        for (int i=0; i < term->numInputs(); i++) {
            Term* input = term->input(i);
            ca_assert(input->stackIndex != -1);
            op->inputs[i].stackIndex = input->stackIndex;
        }
    }
    return size;
}

size_t write_return_op(Term* term, char* data)
{
    size_t size = sizeof(ReturnOperation);
    if (data != NULL) {
        ReturnOperation* op = (ReturnOperation*) data;
        op->opid = OP_RETURN;
        op->caller = term;
    }
    return size;
}


size_t write_op(Term* term, char* data)
{
    if (term->function == RETURN_FUNC)
        return write_return_op(term, data);

    return write_call_op(term, data);
}

void update_bytecode(Branch& branch, BytecodeData* bytecode)
{
    // First pass: Figure out the size of generated bytecode, update stack
    // indexes of terms, and count the # of elements on the stack.
    size_t size = 0;
    int stackElements = 0;
    for (int i=0; i < branch.length(); i++) {
        Term* term = branch[i];
        term->stackIndex = -1;

        if (!should_term_generate_call(term))
            continue;

        size += write_op(term, NULL);

        if (should_term_output_go_on_stack(term))
            term->stackIndex = stackElements++;
    }

    // Add space for a STACK_SIZE op
    size += sizeof(StackSizeOperation);

    // Check to reallocate opdata
    if (size > bytecode->capacity) {
        free(bytecode->opdata);
        bytecode->opdata = new char[size];
        bytecode->capacity = size;
    }

    bytecode->size = size;
    ca_assert(bytecode->size <= bytecode->capacity);

    // Start writing operations
    
    // First add a STACK_SIZE op
    char* writePtr = bytecode->opdata;
    writePtr += write_stack_size_op(writePtr, stackElements);

    // Write remaining ops
    for (int i=0; i < branch.length(); i++) {
        Term* term = branch[i];
        if (!should_term_generate_call(term))
            continue;

        writePtr += write_op(term, writePtr);
        ca_assert(size_t(writePtr - bytecode->opdata) <= bytecode->size);
    }
}

void update_bytecode(Branch& branch)
{
    return update_bytecode(branch, &branch._bytecode);
}

void print_bytecode(std::ostream& out, BytecodeData* data)
{
    for (Iterator it(data); !it.finished(); ++it) {
        print_operation(out, *it);
        out << std::endl;
    }
}

void print_bytecode(std::ostream& out, Branch& branch)
{
    return print_bytecode(out, &branch._bytecode);
}

void print_operation(std::ostream& out, Operation* op)
{
    switch (op->opid) {
        case OP_STACK_SIZE:
            out << "stack_size " << ((StackSizeOperation*) op)->numElements;
            break;
        case OP_CALL: {
            CallOperation *callOp = (CallOperation*) op;
            out << "call " << callOp->function->name;
            out << "(";
            for (int i=0; i < callOp->numInputs; i++) {
                if (i != 0) out << " ";
                out << callOp->inputs[i].stackIndex;
            }
            out << ")";
            int outputIndex = callOp->caller->stackIndex;
            if (outputIndex != -1)
                out << " -> " << outputIndex;
            break;
        }
        case OP_RETURN:
            break;
        default: ca_assert(false);
    }
}


bool Iterator::finished()
{
    return pos == NULL;
}
Operation* Iterator::current()
{
    return pos;
}
void Iterator::advance()
{
    pos = (Operation*) (((char*) pos) + get_operation_size(pos));
    if (size_t(((char*)pos) - data->opdata) >= data->size)
        pos = NULL;
}

} // namespace bytecode
} // namespace circa
