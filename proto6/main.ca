-- Copyright 2008 Andrew Fischer

-- std functions

state mouse_x = 0.0
state mouse_y = 0.0
state time = 0.0

HALF_PI = PI / 2.0

background(0xeeeeeeff)

type Point { float x, float y }

-- p2c: polar to cartesian
def p2c(float angle, float radius, Point center) : Point
  return [cos(angle) * radius + center.x, sin(angle) * radius + center.y]
end

def point_add(Point a, Point b) :Point
  return [a.x + b.x, a.y + b.y]
end

-- our code

SCREEN_WIDTH = 480
SCREEN_HEIGHT = 600

type TreeSegment {
  Point baseLoc
  float direction
  float depth
  float width
}

def tree_segment(TreeSegment segment)
  state jitter = rand()*.1
  segment_height = 40.0
  direction = segment.direction + jitter
  a = p2c(direction - HALF_PI, segment.width, segment.baseLoc)
  b = p2c(direction + HALF_PI, segment.width, segment.baseLoc)
  c = p2c(direction, segment_height, a)
  d = p2c(direction, segment_height, b)
  next_center = p2c(direction, segment_height, segment.baseLoc)
  shape([a b d c] 0x440101ff)

  if segment.depth < 3.0
      tree_segment([next_center segment.direction - 0.4 segment.depth+1 segment.width - .4])
      tree_segment([next_center segment.direction + 0.4 segment.depth+1 segment.width - .41])
  end
end

starting_width = 3.0

tree_segment([[200 300] 0-HALF_PI 0 starting_width])
