-- Copyright 2009 Paul Hodge

-- std functions

-- these values are passed to us from main.cpp
state mouse_x = 0.0
state mouse_y = 0.0
state time = 0.0
state elapsed = 0.0

background(0xeeeeeeff)

type Point { float x, float y }

-- p2c: polar to cartesian
def p2c(float angle, float radius, Point center) : Point
  return [cos(angle) * radius + center.x, sin(angle) * radius + center.y]
end

def point_add(Point a, Point b) :Point
  return [a.x + b.x, a.y + b.y]
end

-- our code

def interp(float progress, float e) :float
  return min(progress / e, 1.0)
end

SCREEN_WIDTH = 480
SCREEN_HEIGHT = 600


def tree_segment(Point base, float direction, float width, float depth)
  state jitter = (rand() - .5) *.3
  state max_length = 20 + 30 * rand()
  state age = 1.0
  age += elapsed
  seg_length = 20.0 * log(age)
  min(@seg_length, max_length)
  --direction = direction + jitter
  bottom_width = width * interp(age, 8)

  has_branches = (seg_length > .4*max_length) && depth < 4.0

  top_width = width * interp(age, 11)
  if_expr(has_branches, @top_width, 0.0)

  l = p2c(direction - HALF_PI, bottom_width, base)
  r = p2c(direction + HALF_PI, bottom_width, base)
  next_center = p2c(direction, seg_length, base)
  l2 = p2c(direction - HALF_PI, top_width, next_center)
  r2 = p2c(direction + HALF_PI, top_width, next_center)
  shape([l r r2 l2] 0x440101ff)

  if has_branches
    state l_jitter = rand() * .2
    state r_jitter = rand() * .2
    l_branch = tree_segment(next_center, direction - l_jitter - .3, width - .4, depth+1)
    r_branch = tree_segment(next_center, direction + r_jitter + .3, width - .4, depth+1)
  end
end

starting_width = 3.0

root = tree_segment([200 300], 0-HALF_PI, starting_width, 0)
