
-- Global context, will probably make this implicit in the future.
env = input() -> ScriptContext
time = env.time
mouse = env.mouse
bounds = env.bounds
time = env.time
time_delta = delta(time)

env.background(#000)

base_grow_rate = 40.0
max_segment_length = 10.0 -- 10 to 30
max_segment_radius = 1.0
max_segment_angle = 1.0 -- .5 - 1
wiggle_factor = 0.07 -- 0 - 1
generation_limit = 15
distance_between_branches = 20.0
distance_between_branches_var = 30.0

def seed() -> number
    state r = rand()
    return r

type Segment {
  int generation
  number distance_from_base
  number distance_till_branch
  number base_radius
  number end_radius
  Point base_loc
  number base_angle
  number growth_rate
}


def Segment.step(seg)
    state wiggle_value = rand() - .5
    state thickness_ratio = 1.0
    age = env.elapsed

    print('step: ' seg)
    print(age)

    -- whether this is the tip
    reached_last_gen = seg.generation >= generation_limit

    -- length
    target_length = max_segment_length
    if target_length > seg.distance_till_branch
        target_length = seg.distance_till_branch
        reached_branch = true
    else
        reached_branch = false
    
    length = base_grow_rate * seg.growth_rate * age
    if length > target_length
        length = target_length
        growth_finished = true
    else
        growth_finished = false


    stretched_length = 3 * log(age)
    max(@stretched_length 0)
    min(@stretched_length 10.0)
    length += stretched_length

    end_loc = seg.base_loc + polar(seg.base_angle) * length

    -- thickness
    thickness = 10.0 * 1 / (seg.generation + 1)
    tip_thickness = 10.0 * 1 / (seg.generation + 2)

    cond(reached_last_gen, 0.0, @tip_thickness)

    base_l = seg.base_loc + polar(seg.base_angle - 90) * (thickness/2)
    base_r = seg.base_loc + polar(seg.base_angle + 90) * (thickness/2)

    tip_l = end_loc + [-1 0] * (tip_thickness/2)
    tip_r = end_loc + [1 0] * (tip_thickness/2)

    env.draw_poly([base_l tip_l tip_r base_r] #0f0)

    -- Don't grow past generation
    if seg.generation >= generation_limit
        return

    -- Don't grow until we've reached a certain time
    if not growth_finished
        return

    e = elapsed()
    s = 0.7

    -- Check to split
    if reached_branch

        -- Branch
        for dir in [-1 1]
            branch_angle = s * 40.0 * dir
            child = create(Segment)
            child.base_loc = end_loc
            child.base_angle = seg.base_angle + branch_angle
            child.generation = seg.generation + 1
            child.distance_till_branch = distance_between_branches + seed() * 20.0
            child.growth_rate = seg.growth_rate * .9

            child.step
            assert(true)

    -- Grow a child segment
    else
        target_angle_delt = (seed() - 0.5) * 10.0
        target_angle_delt = 5.0
        angle_delt = min(e / 10, target_angle_delt)
        
        child = create(Segment)
        child.base_loc = end_loc
        child.base_angle = seg.base_angle + angle_delt
        child.generation = seg.generation + 1
        child.distance_till_branch = seg.distance_till_branch - target_length
        child.growth_rate = seg.growth_rate * .9

        child.step

        assert(true)


root = create(Segment)
root.base_loc = [300 400]
root.distance_till_branch = distance_between_branches
root.growth_rate = 1.0
root.step()

