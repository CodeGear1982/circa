
-- Global context, will probably make this implicit in the future.
env = input() -> ScriptContext
time = env.time
mouse = env.mouse
bounds = env.bounds
time = env.time
time_delta = delta(time)

env.background(#000)

base_grow_rate = 40.0
max_segment_length = 30.0 -- 10 to 30
max_segment_radius = 1.0
max_segment_angle = 1.0 -- .5 - 1
wiggle_factor = 0.07 -- 0 - 1
generation_limit = 8
distance_between_branches = 30.0
distance_between_branches_var = 30.0

type Segment {
  int generation
  number distance_from_base
  number distance_till_branch
  number base_radius
  number end_radius
  Point base_loc
  number base_angle
  number growth_rate
}

def seed() -> number
    state r = rand()
    return r

def random_sign() -> number
    return seed() > 0.5

def Segment.step(seg)
    state wiggle_value = rand() - .5
    state thickness_ratio = 1.0
    age = env.elapsed

    -- length
    target_length = max_segment_length
    if target_length > seg.distance_till_branch
        target_length = seg.distance_till_branch
        reached_branch = true
    else
        reached_branch = false
    
    length = base_grow_rate * seg.growth_rate * age
    if length > target_length
        length = target_length
        growth_finished = true
    else
        growth_finished = false

    stretched_length = 3 * log(age)
    max(@stretched_length 0)
    min(@stretched_length 10.0)
    length += stretched_length

    end_loc = seg.base_loc + polar(seg.base_angle) * length

    -- thickness
    thickness = 10.0 * 1 / (seg.generation + 1)
    tip_thickness = 10.0 * 1 / (seg.generation + 2)

    base_l = seg.base_loc + polar(seg.base_angle - 90) * (thickness/2)
    base_r = seg.base_loc + polar(seg.base_angle + 90) * (thickness/2)

    tip_l = end_loc + [-1 0] * (tip_thickness/2)
    tip_r = end_loc + [1 0] * (tip_thickness/2)

    env.draw_poly([base_l tip_l tip_r base_r] #0f0)

    -- angle of curvature
    target_angle = 5.0
    angle = target_angle * (1 - (1 / (age + 1)))

    stretched_angle = log(age)
    angle += stretched_angle

    distance_till_branch = seg.distance_till_branch - target_length

    -- Don't grow past generation
    if seg.generation >= generation_limit
        return

    -- Don't grow until we've reached a certain time
    if not growth_finished
        return

    -- Check to split
    if reached_branch

        -- Branch
        for dir in [-1 1]
            branch_angle = seed() * 40.0 * dir
            child = create(Segment)
            child.base_loc = end_loc
            child.base_angle = seg.base_angle + branch_angle
            child.generation = seg.generation + 1
            child.distance_till_branch = distance_between_branches + seed() * 20.0
            child.growth_rate = seg.growth_rate * .9

            child.step

    -- Grow a child segment
    else
        target_angle_delt = (seed() - 0.5) * 10.0
        angle_delt = min(age target_angle_delt)
        
        child = create(Segment)
        child.base_loc = end_loc
        child.base_angle = seg.base_angle + angle_delt
        child.generation = seg.generation + 1
        child.distance_till_branch = distance_till_branch
        child.growth_rate = seg.growth_rate * .9 - seed() * .1

        child.step


root = create(Segment)
root.base_loc = [300 400]
root.distance_till_branch = distance_between_branches
root.growth_rate = 1.0
root.step()

