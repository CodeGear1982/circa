
Overview
--------

In the Circa ecosystem, many hosted functions are patched with native implementations.
The current process is a explicit, destructive process: you start with a Function object
(or a Branch full of functions) then manually modify their data to point to your
implementation.

The biggest flaw is this process isn't repeatable. If a piece of code is reloaded,
the new function objects will not have the same function overrides.

The proposed solution is a global (on the World) directory of function overrides (which might
also be called 'patches'). At any time after the World is created, the native code may
create an association between a global name and a native patch function.

This declaration should be free of ordering concerns: if the hosted function has already
been created, then the native patch should be applied immediately. If it's created later, then
then any existing native patch should be applied. Now, reloading a piece of native-patched
code is much easier.

Namespaces & Modules
--------------------

This solution relies on a sane solution to namespacing & moduling. Every function that would
be native-patched should be findable with a global name (hopefully namespaced). This is okay,
since the general plan is that every term ever should be reachable by some global name.

An area of concern: if we want to load a piece of code outside of the module system ("include"
style), then the global name might be unpredictable, or we might not be able to use the
global name that the native code wants.
  - Maybe as part of the "include" call, the code could specify a name prefix to use for
    finding native functions.

Implementation Notes
--------------------

We're going to rely on the World object more in this new code, it's not currently
used for everything that it should be now, but it's what we'll use moving forward.

We'll also add a global 'g_world' object as a temporary thing to make it easier to
transition to replacing globals with World.

API
---

  add_native_patch(world, name, function_pointer)
    Add a native patch with the given name
  find_native_patch(world, name)
    Find a native patch function, may return NULL
  load_native_patch_dll(World* world, const char* filename);
    Load a DLL file, invoke the magic function that activates all of its native patches.
