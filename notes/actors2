
Design for the Actor & Message pool

ActorPool
  Contains a list of Inboxes
  Each Inbox maps to an Actor
  Each Actor either has an evaluation Block or a native handler

Actor
  Has a primary Inbox
  Has an evaluation Block, or just a native handler
    Future: Could just have a native Block, since all blocks can be native patched

Message
  Contains a Value

There are special Inboxes:
  Load new actor from script file

CallSync
  Allows 

Inboxes can be passed by value
  Each script has access to its owning actor & inbox

---

Feature-oriented design

With an actors system, I should be able to:

  1) Create an isolated ActorSpace
    Each Actor belongs to one ActorSpace
  2) Load a script as an actor
    How is the name determined, by the caller or the script?
    In most worlds, the name is determined by the caller.
    But we could let the script make a suggestion?
  3) Manually send a message to an actor
    This just appends the value to the inbox
    Lookup Actor via name or ref
  4) Allow scripts to send messages as well
    Must be able to access ActorSpace from within stack
    Stack needs a stack of current Actor
  5) Run all pending messages
    Each Actor has their own copy of state
    Avoid message loops- if A and B message each other, only handle one pass per iteration.
  6) An actor's script can programmatically access their 'inbox', and pass it as a value.
    Related to #4, access Actor and ActorSpace from stack
  7) An actor can synchronously call another actor
  8) Manually extract messages sent to a certain address

ActorSpace
  Current bucket switch
  List of actors

Actor
  Link to ActorSpace
  Block
  Stack

ActorRef (circa value)

Message
  Name
  Params
  ActorRef sender

Stack

(Before starting, Improv will inject incoming messages, such as input events or time)

actor_start_iteration
  Flips current bucket
(At this point, improv may sneak in and handle some actors itself)
  actor_has_incoming
  actor_consume_incoming

  Some builtin channels are:
    script loading service

actor_run_current_iteration
  For each actor
    If the current bucket is empty, move on

    Extract current bucket & leave it as an empty list

    Inject state and message list
    Stack.context has a link to ActorRef

    Push and run Actor.block

    Extract output value for caller

    When an actor func is triggered:
      send()
        Lookup ActorSpace from stack.context
        Find actor
        Insert message into non-current switch
      self()
        Lookup ActorSpace from stack.context
        Find actor
      spawn()
        Lookup ActorSpace from stack.context
        Spawn actor, loading branch as necessary
      sync_call()
        Lookup ActorSpace from stack.context
        Find actor
        If the actor's stack is currently in use, then error out
        Otherwise, immediately trigger handler and extract output value
        
Improv will 
