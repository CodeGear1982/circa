Some thoughts on using state machines as a core element of Circa.

State machines have many appealing properties that make them a good
fit for Circa. They are flexible and powerful. They can be introspected.
One can draw many conclusions about the behavior of a SM without ever
running it. They can be modifed. They can be visualized.

Questions..

How does the user specify behavior? (probably with feedback)

How is the structure stored?

How is the FSM executed?

--

Data structure notes:

Things that users need:
 - Refer to states by name
 - Check if we are in a certain state
 - Ask what state we are in

Normal execution:
 - Every state has an 'iterate' method
 - Call 'iterate'
 - 'iterate' might change our state
 - Then we call 'iterate' again on the new state

 Traditional state machine has 'edges'. Edges can be:
 - Pieces of input, such as an RE
 - Conditions
   - Problem: multiple conditions might be true, then what do we do?

So there are different styles of state machines. Maybe we need to support multiple kinds.

Condition-based scheme could be translated into an input-based scheme.
Input-based scheme could be turned into conditions.
But which should we use?

## Implementation ideas ##

StateMachine term
  contains:
    A list of Node terms
    'Head' (the current state, a pointer to a node)
    A function that evaluates which node should come next
    Functions that may return side effects for any transition


The process of creating a state machine for a regular expression:

1) Text format, a*bcd+
2) After normalization, states are a,b,c,d1,d2

next(a,input) := if(input == 'a')
                   a
                 elif(input == 'b')
                   b
                 else
                   fail
next(b,input) := if (input == 'c')
                   c
                 else
                   fail

