Okay. This gets confusing.

There are many ways we can replicate & reference data. Here we go.

* Copy by value

Possible syntax:
x := y
function(x) := y

* Copies value
* Occurs every time the code is executed
* Does not preserve source information
* LHS does not receive updates when RHS changes

* Override result of a function for certain inputs
* Or, copy by reference
* Currently called 'attribute' functions

Possible syntax:
x <= y
function(x) ::= y
let function(x) = y
function(x) = y

* Creates a "reference term" or "ghost term"
* Both terms use the same data
* LHS does receive updates when RHS changes

Should it be possible to override the output for *any* function? I'm leaning towards no.
This would cause potentially confusing outcomes. And it breaks a certain understanding
about the atomicity of certain functions. Besides, it would be possible to take any function,
and wrap it with the ability to override certain 

* Implementation is tricky..
   - Do we need to receive updates when the function used on LHS changes? Probably yes
   - Do we need to remember where the referencing came from? Maybe

We are going to have this problem for any kind of container type.

'Attribute' functions are pretty much hashtables

Reference term has:
  Function = the hash or 'attribute' function
  Input = the hash key
  Some internal pointer to the hash-result Term (also, we are on this term's user list)

Need to handle:
  when hash-result term changes value
  when hash-result term is refactored

If the attribute function is constant (and perhaps if its attributes are also marked
as write-once), then we can just use the source token at resolution time.

A lot of signs are pointing to the need for a "reference term".

Another reason: if we want to have any hope of saving the location where the binding
was created, then we need a reference term.
