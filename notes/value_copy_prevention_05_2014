
Currently our approach to value immutability is to copy values constantly inside the
interpreter. This means that every operation which modifies a value will cause a deep copy.

To optimize this and prevent unnecessary copies, we need to 'move' existing values
(instead of copy) when it's safe to do so.

Goals:
  Track the visibility of every term
  Move existing values when their visibility is over

--

Code

  New function
    bool term_is_visible_beyond(Term* term, Term* location)

  New input-instruction bytecode: move input (instead of copy)

  When constructing input-instruction bytecode, use the move input when term isn't visible_beyond

  In function outputs, *always* move
  When starting a for-loop iteration, *always* move

--

More thoughts

When running a native function, we currently create a new stack frame, then fire the C call.
The call uses C api to retrive inputs. This is all fine.

There's different ways that inputs can be used:

  1) read-only / unused

     Example: String.length

     Strategy: Move is OK but unnecessary. We can rely on a shallow copy. Additionally we
     could do a reverse-move after the function is done, to reduce refcounting.

  2) consume+modify, function wants to take the existing value, make a small modification,
     and then use that as an output.

     Example: List.append, String.concat, Map.set, etc.

     Note: This one is a primary area of concern. This will cause deep copy if there
     are any leftover references to the old value. So our goal is to eliminate leftover
     references.

     Strategy: Move is highly desired.

     Future strategy: Rearrange operations so that the consume+modify is the last use of
     the value.

  3) passthrough, function wants to use a straight copy of the value as its output,
     or use the value as a nested element of its output.

     Strategy: Move is good. Passthrough style does not cause problems on its own (since
     it uses shallow copy), but with a move we can minimize extra references, thus
     preventing problems with consume+modify.

Some functions can conditionally use one or the other, such as cond() which will conditionally
treat an input as either read-only or passthrough.

--

In general, we'll get good results if we move() as much as possible. Assume minimum visibility.

--

Conclusion

  All functions may consume inputs
  So, all pushed inputs are available for consumption
