Stacks
------

Currently, values are associated with the code itself, which works okay in some situations.

    program:
        [ code,value;
          code,value;
          code,value;
          ....
        ]

For function declarations, this situation gets funny because the values inside the function
are reused on every function call. It usually doesn't make sense to access a temporary
inside a function after it's been called, because it will just have a leftover value.

    program:
        [ function_def:
            [ code,value;
              code,value;
              code,value;
            ]
          function_call;
          function_call;
          function_call;
        ]

Also, recursion is impossible.

It makes sense to be able to separate the code from its value. Then the function_def would include
some terms that refer to a stack position, and it would be impossible to call a subroutine without
a stack.

    program:
        [ function_def:
            [ code,value;
              code,stack_ref;
              code,stack_ref;
            ]
          function_call(stack);
          function_call(stack);
          function_call(stack);
        ]

Stacks and memory management
----------------------------

A stack might end up with an allocated value, and we need to clean that up when the stack
is closed. To make this easier, a stack could just be a Branch that uses existing allocation
rules.

Implementation
--------------

def evaluate_subroutine(Branch function_def, Branch stack):
    for code in function_def:
        output_value = code->output_value
        if is_stack_reference(output_value):
            output_value = get_stack_value(stack, output_value)
        evaluate_term(code, output_value)
    .. cleanup?
    .. steal output?

