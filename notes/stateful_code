
OVERVIEW

We have a notion that control flow can have associated state. This is the primary
way that a user will specify that something can be persisted.

A quick example. If I write a function like this:

def myfunc()
    state i : int
end

Then this means that I want to save an integer for *every* call to this function.
If I call this function three times:

myfunc()
myfunc()
myfunc()

Then we will allocate three different integers, one for each function.

FEATURES

This section lists some cool things you can do with this feature.

ONE-TIME FUNCTION CALLS

One is that you can have a function be called once as soon as a branch is first reached,
and then have successive calls to that branch reuse the same result. This is really
useful for random numbers. We can write the following code:

def my_simple_fractal(float x, float y, int depth)
    state dx = rand() * 10
    state dy = rand() * 10
    line(x,y,x + dx, y + dx)
    if (depth < 4)
        my_simple_fractal(x + dx, y + dy, depth+1)
        my_simple_fractal(x + dx, y + dy, depth+1)
        my_simple_fractal(x + dx, y + dy, depth+1)
    end
end

And this will make us draw a random tree. If we didn't use the 'state' keyword, then
this tree would be really jittery, because the rand() call would be reevaluated every
frame. But since we have the state keyword, the rand() function is only evaluated
once for each function call, and the tree stays still.

UTILITY FUNCTIONS

Stateful code can also open the doors to define some useful utility functions.

def times_called() : int
    state count = 0
    count += 1
    return count
end

IMPLEMENTATION THOUGHTS

In a way, stateful terms is a substitute for object-oriented programming. Each stateful
call can be considered an object. Given a piece of code, we can generate a definition for
our stateful object (by concatenating the types of each stateful term). And each 'object'
has an implicit "execute()" function, which performs some action and then updates the object's
data.

DESIRED FEATURES

Can we access a function's state in a different way? Like, can we write this:

function stateful_func()
  state i = 1
end

call = stateful_func()
print(call.i) -- reach into stateful_func and access its state

Can we have a way to explicitly reset state? -- This one is something that I constantly wish
I could do when writing code.
