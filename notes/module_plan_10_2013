
Libraries are causing a problem.

The outline of a library:
  A block that contains types & functions
  Any other block can 'require' the module, and those types & functions become
    name-visible and can be used.

The problem is if there are any expressions at the top level of a module. As in:

  four = 2 + 2

  def get_four()
    return four

What should happen, is that the 'four' expression should be evaluated, and 'get_four'
should save a binding to this nonlocal value. The call to get_four would then have
this binding.

Currently:
  A required script is not evaluated (at least, not the top level)
  Functions are referenced directly. They aren't Func values, so no bindings are available.
  Overall, the current state is not very dataflowy. We should be able to put expressions
  anywhere, and have them propogate changes.

Some concerns:
  When should the module top-level be evaulated? Best case: as late as possible. We don't
    want to run into problems such as native bindings not yet added. Also, must use user's
    stack, and must use hacks.

The plan:
  Every 'require' statement will evaluate the module top-level.
    This will be a great candidate for memoization.
  The output of 'require' will be a bundle of types & closures.
    Will need a new bytecode: PopAsModule. 1st rev: just save whole frame.
  When using a func or type from a module, use the value in the require result. (on stack)
    How to implement?
      New style of nonlocal() term. This term needs both 1) the location of the require term
      and 2) a name/term_ref inside that module.
    Will still depend on compile-time module loading for now.
      Maybe, create the nonlocal without a term_ref pointing inside the module. At runtime.
      resolve that term_ref and then save it.
        Problem: this won't work after migration. The nonlocal needs to be name-based.
        Let's talk about compilation units.
        We should not have term references to other compilation units.

Future
  Can we eliminate compile-time module loading?
    Need to support calls to unresolved functions. Unresolved type references. And unresolved
    methods of course.
  Should we do that as part of this change?
    Probably not, but let's at least plan for it.
