
Closures are close to having issues ironed out, but not totally there.

Problems
  App doesn't do proper escape analysis. It does check to see if a function outputs a
  closure (in which case it captures the necessary bindings). But, it doesn't do a deep
  search. You can return a closure inside a list and the bindings will *not* be captured.

  To simplify closure capturing, we'll just capture everything visible at the time of
  the function declaration.
    Optimization: Don't do this if the function is never used as a value.

  Another one is that it captures too much. If you do closure_save_all_bindings, then
  it goes all the way into 'builtins' references and saves those. It does not need to save
  'builtins' references.

The plan
  - Never capture closure bindings outside of the compilation unit (this includes builtins)
  - Never create nonlocal() references outside of the compilation unit. (this will probably
    automaticlaly fix the above issue).
  - Add term_is_used_as_value()
  - Add bc_ClosureCapture
  - Conditionally generate ClosureCapture instructions, if the function is used as a value.
  - Remove Func.freeze as its not necessary.

Remaining issues
  If you save a closure as state, then you might *not* want to capture outer references.
  Perhaps add a Func.uncapture function, which would remove bindings that are still
  available on the scope?
    Problem: If we do this, then we would just need to recapture bindings if the function
    escapes, and we already (above) decided to not bother with this.
      Maybe the best approach for now is to say, "don't save closures in state, and if you
        do, they might capture more values than you want".
      Or, we could selectively reset the fields of a state-saved closure binding, on script change?
      Could happen during migration? (since we need to migrate those term pointers anyway)

Other TODO
  Verify that migration works on a hashtable's keys (as in closure bindings, which uses TermRef keys)
