
Problem:

We should be using copy() for all identifiers, when the target of that identifier is not in
the current scope.

Reason: to support using identifiers in literal branches.

Problem: mentioning a type by identifier is problematic. We don't want to copy the entire type
object.

Need a way to pass an argument by reference instead of by value.

How to do this?

1) Function signature can specify 'ref' for arguments
2) Certain types can be turned into ref types

I think #2 might make the most sense for our world. We don't like references/aliasing.

------------------------------------------------------------------------------------

Point = Type(float,float)
state Point p

------------------------------------------------------------------------------------

The Reference Problem

1) Need to be able to share the same object across different parts of the code
2) Need to preserve object identity for comparison purposes

Aliasing solves #1 but is not a good solution for #2

I would like it if we could get rid of aliasing altogether

Possible solution: wrap types into a managed pointer

For every type T:

  Create a Reference type:
    
     class Reference<T> {
       int refCount;
       T* data;
     }
