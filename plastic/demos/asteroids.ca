
desired_window_size = [500 300]

background(#000)

type Ship {
    Point loc,
    Point momentum,
    number facing
}

type Bullet {
    number lifespan,
    Point loc,
    Point direction
}

-- Return a point that is wrapped around the playable area
def wrap_around(Point p) : Point
    return [mod(p.x, window.width) mod(p.y, window.height)]
end

state Ship ship = [[window.width/2 window.height/2] [0 0] 0]
state List bullets = []
accelration_per_s = 5.0
rotation_speed = 0.9
ship_drag = 0.991
speed_limit = 1.8
bullet_speed = 200.0
bullet_width = 2.0

def random_location() : Point
    return [rand() * window.width, rand() * window.height]
end

def random_norm_vector() : Point
    angle = rand()
    return [cos(angle) sin(angle)]
end

def rotate_point(Point point, number rotation) : Point
    return [point.x*cos(rotation) - point.y*sin(rotation),
        point.x*sin(rotation)+point.y*cos(rotation)]
end


-- Draw a background full of stars
num_stars = 700
for i in range(num_stars)
    state Point loc = random_location()
    state Color color = [rand(.2 .6) .3 rand(.5 1) 1] 
    gl.points([loc] color)
end

ship_size = 1.2
ship_front = 10.0
ship_back = 5.5
ship_wing_size = 11.4
ship_wing_rot = .40
namespace draw_ship
    def ship_point(number rot, number dist) : Point
        return polar(rot + ship.facing, dist*ship_size, ship.loc)
    end

    gl.line_loop([ship_point(0 ship_front)
                  ship_point(ship_wing_rot ship_wing_size)
                  ship_point(.5 ship_back)
                  ship_point(-ship_wing_rot ship_wing_size)] #fff)
end

-- Keyboard controls for rotation
if key_down(LEFT)
    rotation = -1
elif key_down(RIGHT)
    rotation = 1
else
    rotation = 0
end
ship.facing = ship.facing + rotation * rotation_speed * time_delta

-- Keyboard controls for acceleration
if key_down(UP)
    thrust = 1
elif key_down(DOWN)
    thrust = -1
else
    thrust = 0
end

ship.momentum = ship.momentum + [cos(ship.facing) sin(ship.facing)] * thrust * accelration_per_s * time_delta

-- Add drag
ship.momentum = ship.momentum * ship_drag

-- Enforce a speed limit on ship.momentum
speed = magnitude(ship.momentum)
if speed > speed_limit
    ship.momentum = ship.momentum * (speed_limit / speed)
end

-- Move ship
ship.loc = ship.loc + ship.momentum
ship.loc = wrap_around(ship.loc)

-- Press space to shoot a bullet
if key_pressed(SPACE)
    bullets.append([0, ship.loc [cos(ship.facing) sin(ship.facing)]] : Bullet)
end

-- Move bullets
def move_bullet(Bullet bullet) : Bullet
    loc = bullet.loc + bullet.direction * bullet_speed * time_delta
    loc = wrap_around(loc)
    return [bullet.lifespan+time_delta, loc, bullet.direction]
end

bullets = map(move_bullet, bullets)

-- Remove old bullets
bullet_max_lifespan = 1.8
def filter_bullet(Bullet bullet) : bool
    return bullet.lifespan < bullet_max_lifespan
end

-- This syntax is crazy, it should just be filter(filter_bullet, bullets)
bullets = filter(bullets, map(filter_bullet, bullets))

-- Draw bullets
for bullet in bullets
    bullet = bullet : Bullet
    points = [bullet.loc + [-bullet_width, -bullet_width],
                  bullet.loc + [bullet_width, -bullet_width],
                  bullet.loc + [bullet_width, bullet_width],
                  bullet.loc + [-bullet_width, bullet_width]]
    gl.line_loop(points #fff)
end

type Asteroid {
  List edges
  Point location
  Point vel
  number rotation
  number rotation_vel
  number size
}

asteroid_collision_radius = 20.0
asteroid_starting_size = 30.0
asteroid_num_edges = 10

def generate_asteroid(number size) : Asteroid
    def get_edge(int index) : Point
        angle = index / asteroid_num_edges
        return polar(angle, rand() * size + size/3, [0 0])
    end

    rotation = rand() * .2 - .1
    return [map(get_edge, range(10)), random_location(), random_norm_vector()*10, 0, rotation size]
end

def generate_child_asteroid(Asteroid parent) : Asteroid
    size = parent.size / 2
    def get_edge(int index) : Point
        angle = index / asteroid_num_edges
        return polar(angle, rand() * size + size/3, [0 0])
    end
    rotation = rand() * .2 - .1
    return [map(get_edge, range(10)), parent.location, random_norm_vector()*10, 0, rotation size]
end

-- move asteroids
def move_asteroid(Asteroid asteroid) : Asteroid
    asteroid.location = asteroid.location + asteroid.vel * time_delta
    asteroid.rotation = asteroid.rotation + asteroid.rotation_vel * time_delta
    asteroid.location = wrap_around(asteroid.location)
    return asteroid
end

state List asteroids = []
state bool initialized = false
if not(initialized)
    for i in range(3)
        asteroids.append(generate_asteroid(asteroid_starting_size))
    end
    initialized = true
end

asteroids = map(move_asteroid, asteroids)

-- draw asteroids
for asteroid in asteroids
    asteroid = asteroid : Asteroid

    def pos_edge(Point p) : Point
        p = rotate_point(p, asteroid.rotation)
        p = p + asteroid.location
        return p
    end
    edges = map(pos_edge, asteroid.edges)

    gl.line_loop(edges, #fff)
    --gl.circle(asteroid.location, asteroid_collision_radius, #f00)
end

-- check for collisions of asteroids and bullets
spawned_asteroids = []

def point_distance(Point a, Point b) : number
    return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y))
end

def check_asteroid_collision(Asteroid asteroid) : bool
    collides = false
    for bullet in bullets
        bullet = bullet : Bullet
        if point_distance(asteroid.location, bullet.loc) < asteroid_collision_radius
            collides = true
            spawned_asteroids.append(generate_child_asteroid(asteroid))
            spawned_asteroids.append(generate_child_asteroid(asteroid))
        end
    end
    return not(collides)
end

killed = map(check_asteroid_collision, asteroids)
asteroids = filter(asteroids, killed)

for spawn in spawned_asteroids
    asteroids.append(spawn)
end
spawned_asteroids = []
