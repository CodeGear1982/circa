type Point_i { int x, int y }

WINDOW_WIDTH = 510
WINDOW_HEIGHT = 420

tile_size = 30

-- rotations
NW = 0
NE = 1
SE = 2
SW = 3

def rotations_opposite(int x, int y) : bool
  if x == NW
    return y == SE
  elif x == NE
    return y == SW
  elif x == SE
    return y == NW
  else
    return y == NE
  end
end

num_tiles_x = WINDOW_WIDTH // tile_size
num_tiles_y = WINDOW_HEIGHT // tile_size
num_tiles = num_tiles_x * num_tiles_y

-- draw the checkerboard in the background
for x in range(num_tiles_x)
  for y in range(num_tiles_y)
    box_tl = [x:int * tile_size, y:int * tile_size] : Point
    box_br = box_tl + [tile_size, tile_size]
    box_tr = [box_br.x box_tl.y]
    box_bl = [box_tl.x box_br.y]
    color = if_expr((x:int+y:int) % 2 == 1, #eee, #fff)
    gl.triangles([box_tl box_tr box_bl box_tr box_br box_bl] color)
  end
end

-- Helper function
def rotate_points_around(List points, Point center, float rot) : List
    def rotate_point(Point point) : Point
        point = point - center
        point = [point.x*cos(rot) - point.y*sin(rot), point.x*sin(rot)+point.y*cos(rot)]
        point = point + center
        return point
    end
    return map(rotate_point, points)
end

type Piece { int x, int y, int rot }
type BoardPiece { int rot, bool filled, bool square_filled }

def draw_free_piece(Point location, float rot)
    shape = [[0 0] [1 0] [0 1]]
    rotate_points_around(@shape, [.5 .5] rot)
    mult(@shape, tile_size)
    def add_location(Point p) : Point
      return p + location
    end
    map(add_location, @shape)
    gl.triangles(shape, #404)
end

def draw_piece(Piece piece)
  draw_free_piece([piece.x * tile_size, piece.y * tile_size] piece.rot/4.0)
end

def board_index_to_loc(int index) : Point_i
  return [index // num_tiles_y, index % num_tiles_y]
end

def board_loc_to_index(Point_i point) : int
  return point.x * num_tiles_y + point.y
end

def initialize_board_piece(int index) : BoardPiece
  loc = board_index_to_loc(index)
  if loc.y < 12
    return [0 false false]
  else
    return [rand_i()%4 true rand_i()%10 > 8]
  end
end

piece_types = [
    [[0 1 SE]]
    [[0 1 SE] [1 1 NW]]
    [[0 1 SE] [1 1 NW] [0 1 NW]]
]
    --[[0 1 SE] [1 1 SW]]
    --[[0 0 2] [0 1 2] [0 1 0]]

def get_random_piece_type() : List
  i = rand_i() % length(piece_types)
  return piece_types[i]
end

state falling_group = get_random_piece_type()
state falling_piece_rot = 0
state falling_group_x = 4
state falling_group_y = 0
fall_speed = 80.0
state float tile_fall_distance = tile_size

state board = map(initialize_board_piece, range(num_tiles))

-- Keypresses for rotation
if key_pressed(DOWN)
  falling_piece_rot = (falling_piece_rot - 1) % 4
  if falling_piece_rot < 0; falling_piece_rot += 4; end
end
if key_pressed(UP)
  falling_piece_rot = (falling_piece_rot + 1) % 4
end
if key_pressed(LEFT); falling_group_x -= 1 end
if key_pressed(RIGHT); falling_group_x += 1 end

def rotate_around_i(Point_i point, Point_i center, int rotation) : Point_i
  rotation = rotation % 4
  
  result = [0 0]
  point = point - center

  if rotation == 0
    result = [point.x point.y]
  end
  if rotation == 1
    result = [-point.y point.x]
  end
  if rotation == 2
    result = [-point.x, -point.y]
  end
  if rotation == 3
    result = [point.y, -point.x]
  end
  
  return result + center
end

def rotate_falling_group(List group, int rot) : List
    def rotate_piece(Piece piece) : Piece
        pos = rotate_around_i([piece.x piece.y] [1 1] rot)
        return [pos.x pos.y (piece.rot + rot)%4]
    end
    return map(rotate_piece, group)
end

-- Update fall animation
tile_fall_distance -= fall_speed * time_delta

def position_falling_group(List group, int pos_x, int pos_y) : List
  group = rotate_falling_group(group, falling_piece_rot)
  def position_piece(Piece piece) : Piece
      pos = [piece.x + pos_x, piece.y + pos_y] : Point_i
      return [pos.x pos.y piece.rot]
  end
  out = map(position_piece, group)
  return out
end

def falling_group_collides(List group) : bool
  def piece_collides(Piece piece) : bool
    board_piece = board[board_loc_to_index([piece.x piece.y])] : BoardPiece
    if board_piece.square_filled
      return true
    else
      if board_piece.filled
        ro = rotations_opposite(piece.rot board_piece.rot)
        return not(ro)
      else
        return false
      end
    end
  end

  return any_true(map(piece_collides, group))
end

-- Move falling group down a notch
if tile_fall_distance < 0
  tile_fall_distance = tile_size

  -- Check if the falling group has landed
  next_falling_group_position = position_falling_group(falling_group,
        falling_group_x, falling_group_y + 1)

  if falling_group_collides(next_falling_group_position)
    positioned_falling_group = position_falling_group(falling_group,
      falling_group_x, falling_group_y)

    -- Make this piece permanent
    for piece in positioned_falling_group
      piece = piece:Piece
      existing_board_piece = board[board_loc_to_index([piece.x piece.y])] : BoardPiece
      board[board_loc_to_index([piece.x piece.y])] = [piece.rot true existing_board_piece.filled]
    end

    -- Reset falling group
    falling_group = get_random_piece_type()
    falling_group_x = 5
    falling_group_y = 0
  end

  falling_group_y = falling_group_y + 1
end

-- Draw the current position of the falling group
positioned_falling_group = position_falling_group(falling_group,
  falling_group_x, falling_group_y)

for piece in positioned_falling_group
    piece = piece:Piece
    draw_free_piece([piece.x * tile_size, piece.y * tile_size - tile_fall_distance] piece.rot/4.0)
end

-- Draw board
for index in range(num_tiles)
  piece = board[index] : BoardPiece
  loc = board_index_to_loc(index)
  if piece.filled
    draw_piece([loc.x loc.y piece.rot])
  end
  if piece.square_filled
    draw_piece([loc.x loc.y piece.rot + 2])
  end
end
