-- Wrap up mouse position into a point (values are passed in from input.cpp)
state Point mouse

def mouse_in(Rect b) -> bool
  "Return whether the mouse is currently inside the given rect."
  return (b.x1 < mouse.x) and (b.x2 > mouse.x) and (b.y1 < mouse.y) and (b.y2 > mouse.y)
end

-- Information about the current window (passed in from main.cpp)
type Window {
   int width
   int height
}

window = Window()

window_size = [window.width window.height]->Point

def random_location() -> Point
    "Return a random point that is inside the boundaries of the window."
    return [rand() * window.width, rand() * window.height]
end


-- ide - functions for controlling IDE behavior
namespace ide
    def quit(): "Tell the IDE to shutdown"
    def reset_state(): "Reset state for the current script"
    def reload_runtime(): "Reload the builtin runtime"
    def paused() -> bool : "Returns whether the current script is paused"
    def get_time() -> number {}
end

time = ide:get_time()
time_delta = delta(time)
render_duration = 0.0
td = time_delta -- shorthand

int TouchEvent_down = 1
int TouchEvent_moved = 2
int TouchEvent_up = 3
int TouchEvent_doubleTap = 4

type TouchEvent {
    int id
    int time
    int eventType
    Point loc
    int numTouches
    Point size
    number angle
    number minoraxis
    number majoraxis
    number pressure
    Point speed
    Point accel
}

state List incoming_touch_events = []

-- Input
type Keypress {
    string character
    int code
    int modifier
}

def key_down(int key) -> bool {}
def key_pressed_code(int key) -> bool {}
def key_pressed_char(string key) -> bool {}
key_pressed = overloaded_function(key_pressed_code key_pressed_char)
def mouse_pressed() -> bool {}
def mouse_over(Rect region) -> bool {}
def recent_key_presses() -> List {}
def mouse_clicked_anywhere () -> bool {}
def mouse_clicked_region (Rect region) -> bool {}
mouse_clicked = overloaded_function(mouse_clicked_anywhere mouse_clicked_region)
def mouse_wheel_up_anywhere () -> bool {}
def mouse_wheel_up_region (Rect region) -> bool {}
mouse_wheel_up = overloaded_function(mouse_wheel_up_anywhere mouse_wheel_up_region)
def mouse_wheel_down_anywhere () -> bool {}
def mouse_wheel_down_region (Rect region) -> bool {}
mouse_wheel_down = overloaded_function(mouse_wheel_down_anywhere mouse_wheel_down_region)

-- These values are assigned in input.cpp
namespace key
    up = 0
    down = 0
    left = 0
    right = 0
    space = 0
    delete = 0
    enter = 0
    escape = 0
end

-- GL functions
def background(Color)
    "Fill the screen with the given color."
end

namespace gl begin
    def triangles(List, Color):
        "Render a list of points as triangles."
    def line_strip(List, Color):
        "Render a list of points as a line strip."
    def line_loop(List, Color):
        "Render a list of points as a line loop."
    def lines(List, Color):
        "Render a list of points as a line list."
    def points(List, Color):
        "Render a list of points."
    def circle(Point loc, number radius, Color):
        "Render a circle."
    def pie(Point loc, number radius, number angle_start, number angle_fin, Color):
        "Render a pie slice."
    def load_program(string vertFile, string fragFile) -> int {}
    def _use_program(int prog_id) {}
    def use_program(string vertexFilename, string fragFilename)
        "Load and enable a GLSL shader."
        state int prog_id = 0
        if file_changed(vertexFilename) or file_changed(fragFilename)
            prog_id = load_program(vertexFilename, fragFilename)
        end
        _use_program(prog_id)
    end
    def clear_program() {}
    def set_uniform(string name, any value) {}
end

def load_font(string filename, int size) {}
def draw_string(string str, Point loc, Color color) {}

-- Drawing utils
include('vector_drawing.ca')

-- Time-based stateful functions
def alternate_over_time(number period) -> bool
    "Stateful function, alternates between true and false according to the given period."
    state number time_started = time
    return round((time - time_started) / period) % 2 == 0
end

def linear_fadein(number total_time) -> number
    <<<
    Stateful function, starts out at 0 and increases linearly. After 'total_time'
    has passed, it will return 1.0 and stay there.
    >>>
    state number time_started = time
    elapsed = (time - time_started) / total_time
    return min(elapsed, 1.0)
end

def elapsed() -> number
    "Stateful function, returns the number of seconds that has passed since this function was first called"
    state number time_started = time
    return time - time_started
end

def draggable_rect(Point initial_location, Point size) -> Point
    state Point location = initial_location
    rect = [location.x, location.y, location.x+size.x, location.y+size.y]
    state currently_dragging = false
    state Point mouse_offset = [0 0]
    if currently_dragging
        location = mouse + mouse_offset
        if not(mouse_pressed())
            currently_dragging = false
        end
    elif mouse_clicked(rect)
        currently_dragging = true
        mouse_offset = location - mouse
    end
    return location
end

namespace fps_counter
    state int framesElapsed = 0
    state number timeStarted = time
    state number lastRecoredFps = 0

    framesPerSample = 30
    earlySampleTime = .5

    framesElapsed += 1
    timeElapsed = time - timeStarted

    if (framesElapsed > framesPerSample) or (timeElapsed > earlySampleTime)
        lastRecoredFps = framesElapsed / timeElapsed
        framesElapsed = 0
        timeStarted = time
    end
end

fps = fps_counter:lastRecoredFps


-- Load the user's script
state string user_script_filename = path("../demos/demo_browser.ca")

-- Function to specify a different script
load_user_script_request = inbox()
def load_user_script(string filename):
    trace('load_user_script:', filename)
    send(load_user_script_request, filename)
for filename in load_user_script_request:
    user_script_filename = filename

--trace("Running script: " user_script_filename)

users_branch = include(user_script_filename)
