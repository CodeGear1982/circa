
-- These values are passed in from main.cpp
time = 0.0
time_delta = 0.0
td = time_delta -- shorthand

-- Wrap up mouse position into a point (values are passed in from input.cpp)
state Point mouse

def mouse_in(Rect b) -> bool
  "Return whether the mouse is currently inside the given rect."
  return (b.x1 < mouse.x) and (b.x2 > mouse.x) and (b.y1 < mouse.y) and (b.y2 > mouse.y)
end

-- Information about the current window (passed in from main.cpp)
type Window {
   int width
   int height
}

window = Window()

window_size = [window.width window.height]->Point

-- ide - functions for controlling IDE behavior
namespace ide
    def quit(): "Tell the IDE to shutdown"
    def reset_state(): "Reset state for the current script"
    def reload(): "Reload the current script immediately"
    def reload_runtime(): "Reload the builtin runtime"
end

-- Input
type Keypress {
  string character
  int code
}

def key_down(int key) -> bool {}
def key_pressed_code(int key) -> bool {}
def key_pressed_char(string key) -> bool {}
key_pressed = [ref(key_pressed_code) ref(key_pressed_char)] -> OverloadedFunction
def mouse_pressed() -> bool {}
def mouse_over(Rect region) -> bool {}
def recent_key_presses() -> List {}
def mouse_clicked_anywhere () -> bool {}
def mouse_clicked_region (Rect region) -> bool {}
mouse_clicked = [ref(mouse_clicked_anywhere) ref(mouse_clicked_region)] -> OverloadedFunction
def mouse_wheel_up_anywhere () -> bool {}
def mouse_wheel_up_region (Rect region) -> bool {}
mouse_wheel_up = [ref(mouse_wheel_up_anywhere) ref(mouse_wheel_up_region)] -> OverloadedFunction
def mouse_wheel_down_anywhere () -> bool {}
def mouse_wheel_down_region (Rect region) -> bool {}
mouse_wheel_down = [ref(mouse_wheel_down_anywhere) ref(mouse_wheel_down_region)] -> OverloadedFunction

-- These are assigned in input.cpp
UP = 0
DOWN = 0
LEFT = 0
RIGHT = 0
SPACE = 0
DELETE = 0
KEY_B = 0

-- Text rendering functions
namespace text begin
    type RenderedText { int texid, int width, int height, Color color, string text }
    def load_font(state TTF_Font, string filename, int size) -> TTF_Font:
        "Load the given font"
    def render_text(state RenderedText, TTF_Font font, string text, Color color) -> RenderedText:
        "Render text and return a sprite that can be drawn with draw_rendered_text. This is useful if you want to know the width or height of the rendered text before drawing it."
    def draw_rendered_text(RenderedText, Point loc):
        "Draw a sprite created with render_text."
end

def draw_text(TTF_Font font, string str, Color color, Point location):
    "Render and draw a string."
    sprite = text:render_text(font, str, color)
    text:draw_rendered_text(sprite, location)

def draw_text_centered(TTF_Font font, string str, Color color, Point location):
    sprite = text:render_text(font, str, color)
    text:draw_rendered_text(sprite, [location.x - sprite.width/2 location.y])

-- GL functions
def background(Color):
    "Fill the screen with the given color."

namespace gl begin
    def triangles(List, Color):
        "Render a list of points as triangles."
    def line_strip(List, Color):
        "Render a list of points as a line strip."
    def line_loop(List, Color):
        "Render a list of points as a line loop."
    def points(List, Color):
        "Render a list of points."
    def circle(Point loc, number radius, Color):
        "Render a circle."
    def pie(Point loc, number radius, number angle_start, number angle_fin, Color):
        "Render a pie slice."
    def load_program(string vertFile, string fragFile) -> int {}
    def _use_program(int prog_id) {}
    def use_program(string vertexFilename, string fragFilename)
        "Load and enable a GLSL shader."
        state int prog_id = 0
        if file_changed(vertexFilename) or file_changed(fragFilename)
            prog_id = load_program(vertexFilename, fragFilename)
        end
        _use_program(prog_id)
    end
    def clear_program() {}
    def set_uniform(string name, any value) {}
end

namespace image begin
    type Image {
        string filename
        int texid
        int width
        int height
    }

    def _load(string filename) -> Image {}

    def load(string filename) -> Image:
        state Image existing
        if file_changed(filename)
            existing = _load(filename)
        end
        return existing
    def draw(Image image, Point destination) {}
    def draw_clip_p(Image image, Rect clip, Point destination) {}
    def draw_clip_resized(Image image, Rect clip, Rect destination) {}

    draw_clip = [ref(draw_clip_p) ref(draw_clip_resized)] -> OverloadedFunction
end

def load_texture(state int, string) -> int {}

def draw_image(state int texid, string filename, number x, number y, number width, number height):
    "Draw an image."

def load_mesh(string filename) -> int:
    "(experimental) Load a 3d mesh from an .obj file."
def draw_mesh(int mesh_id, int tex_id, Point translation, Point scale, Point rotation):
    "(experimental) Draw a 3d mesh to the screen."

-- Math utility functions

-- polar: polar to cartesian
def polar(number angle) -> Point:
    return [cos(angle) sin(angle)]

-- magnitude of a 2d vector
def magnitude(Point point) -> number:
    "Returns the magnitude, or the distance from [0,0] to this point."
    return sqrt(sqr(point.x) + sqr(point.y))

def point_distance(Point a, Point b) -> number:
    "Returns the distance between a and b."
    return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y))

def rotate_point(Point p, number rotation) -> Point:
    "Rotate p around [0,0] by the given angle. Angles are specified in the range 0..1."
    return [p.x*cos(rotation) - p.y*sin(rotation),
        p.x*sin(rotation)+p.y*cos(rotation)]

def random_location() -> Point:
    "Return a random point that is inside the boundaries of the window."
    return [rand() * window.width, rand() * window.height]

def random_norm_vector() -> Point:
    "Return a random normalized vector"
    angle = rand()
    return [cos(angle) sin(angle)]

def norm(Point v) -> Point:
    "Returns v normalized to be along the unit circle."
    m = magnitude(v)
    return [v.x / m, v.y / m]

def perpendicular(Point v) -> Point:
    "Returns a vector that is perpendicular to v, rotated clockwise."
    return [v.y -v.x]

def expand_rect(Point center, number width, number height) -> Rect:
    "Return a rectangle with the given center, width, and height."
    return [center.x - width/2, center.y - height/2, center.x + width / 2, center.y + height/2]

def to_rect(Point topLeft, Point size) -> Rect
    return [topLeft.x, topLeft.y, topLeft.x + size.x, topLeft.y + size.y]
end

def rect(Point topleft, Point bottomright) -> Rect
    return [topleft.x topleft.y bottomright.x bottomright.y]
end

def rect_intersects_rect(Rect rect_a, Rect rect_b) -> bool:
    "Return whether the two rectangles intersect."
    intersects_on_x = (rect_a.x2 > rect_b.x1) and (rect_b.x2 > rect_a.x1)
    intersects_on_y = (rect_a.y2 > rect_b.y1) and (rect_b.y2 > rect_a.y1)
    return intersects_on_x and intersects_on_y

def random_color() -> Color:
    return [rand() rand() rand() 1.0]

-- Drawing utils
include('vector_drawing.ca')

-- Stateful functions

def approach(number target, number step) -> number:
    "Stateful function, returns a result which approaches 'target'. Each frame, this function will change at most by 'step'"
    state current = target
    if target > current
        current += min(step, target - current)
    elif target < current
        current -= min(step, current - target)
    end
    return current

def alternate_over_time(number period) -> bool:
    "Stateful function, alternates between true and false according to the given period."
    state number time_started = time
    return round((time - time_started) / period) % 2 == 0

def linear_fadein(number total_time) -> number:
    <<<
    Stateful function, starts out at 0 and increases linearly. After 'total_time'
    has passed, it will return 1.0 and stay there.
    >>>
    state number time_started = time
    elapsed = (time - time_started) / total_time
    return min(elapsed, 1.0)

def elapsed() -> number:
    "Stateful function, returns the number of seconds that has passed since this function was first called"
    state number time_started = time
    return time - time_started

def draggable_rect(Point initial_location, Point size) -> Point:
    state Point location = initial_location
    rect = [location.x, location.y, location.x+size.x, location.y+size.y]
    state currently_dragging = false
    state Point mouse_offset = [0 0]
    if currently_dragging
        location = mouse + mouse_offset
        if not(mouse_pressed())
            currently_dragging = false
        end
    elif mouse_clicked(rect)
        currently_dragging = true
        mouse_offset = location - mouse
    end
    return location

ui_font_medium = text:load_font("../assets/sv_basic_manual/SVBasicManual.ttf", 16)

namespace fps_counter
    state int framesElapsed = 0
    state number timeStarted = time
    state number lastRecoredFps = 0

    framesPerSample = 30
    earlySampleTime = .5

    framesElapsed += 1
    timeElapsed = time - timeStarted

    if (framesElapsed > framesPerSample) or (timeElapsed > earlySampleTime)
        lastRecoredFps = framesElapsed / timeElapsed
        framesElapsed = 0
        timeStarted = time
    end
end

fps = fps_counter:lastRecoredFps


namespace tweak begin
    def button(Ref r, Point loc, string name)
        "Draw a button which displays the value of 'r', allowing the user to tweak that value using mouse input."
        str = concat(name ' = ' r.to_string())

        text_sprite = text:render_text(ui_font_medium, str, #000)
        padding = 3.0
        rect = [loc.x - padding, loc.y - padding,
            loc.x + text_sprite.width + padding,
            loc.y + text_sprite.height + padding]
        color = #ee3399
        if mouse_in(rect) color = #ff44aa end
        fill_rect(rect, color)
        text:draw_rendered_text(text_sprite, [loc.x loc.y])

        -- mouse wheel
        if mouse_wheel_up(rect)
            r.tweak(-1)
        elif mouse_wheel_down(rect)
            r.tweak(1)
        end

        -- click and drag
        state mouse_dragging = false
        state Point mouse_drag_previous_point = [0 0]
        if mouse_clicked(rect)
            mouse_dragging = true
            mouse_drag_previous_point = mouse
        elif not(mouse_pressed())
            mouse_dragging = false
        end

        if mouse_dragging
            delta = (mouse - mouse_drag_previous_point) -> Point
            mouse_drag_previous_point = mouse
            steps = round(delta.y)
            r.tweak(steps)
        end
    end
end

-- Support for postprocess operations using FBOs
namespace postprocess begin
    type Surface {
        int tex_id
        int fbo_id
        int width
        int height
    }

    def make_surface(state Surface _state, int width, int height) -> Surface {}
    def bind_surface(Surface surface) {}
    def draw_surface(Surface source) {}
    def copy_surface(Surface source, Surface dest) {}

    main_surface = [0 0 window.width window.height] -> Surface

    def bind_main_surface(): bind_surface(main_surface)
end

-- Include other runtime scripts
include('ui_widgets.ca')

-- Load the user's script
state string user_script_filename = path("../demos/demo_browser.ca")

-- Function to specify a different script
load_user_script_request = inbox()
def load_user_script(string filename):
    print('load_user_script:', filename)
    send(load_user_script_request, filename)
for filename in load_user_script_request:
    user_script_filename = filename

users_branch = include(user_script_filename)

-- Draw HUD
include('mainmenu.ca')

-- Draw fpses
draw_fps = false
if draw_fps
    text_sprite = text:render_text(ui_font_medium, concat('fps: ' fps), #fff)
    text:draw_rendered_text(text_sprite, [10 280])
end

-- Name selector
if toggle(key_pressed('b'))
  br = branch_ref(users_branch)
  x = 10, y = 10
  for r in br.get_configs_nested()
    tweak:button(r, [x y], br.get_relative_name(r))
    y += 24
  end
end
