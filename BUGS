
Miscellanous (most-recent first)

  The 'def' keyword creates a closure, but it doesn't save bindings.

  The 'Couldn't cast ...' message was for the wrong input (0 instead of 1)

  >#3420 'self' 'self' input_placeholder#21() t:Context = 'Couldn't cast input value <Context 0x7f817ac838a0> to type Context'
     #3421 'p' 'p' input_placeholder#21() t:Point = 5
     #3422 '_output_placeholder' output_placeholder#19(NULL) t:any = null

  Declared a function called 'add', and the + operator started using it?

  load_module should return Func for consistency

  Error trace for dynamic_method: should have the actual method name, when possible.
    
  Having a missing ) or ] or } symbol will *really* mess things up. Ditto for an extra ),},]

  Divide operator on Point didn't work?

  A superfluous @ symbol caused problems:

      type A { int i }
      a = make(A)
      @a.i += 4

  Got unrecognized expression on this string (missing '}'). Worst part is, no error reported.

    clickResolver.call([:add, lineRect, {
            pos = input()
            event = input()

            if event == :right_down
                contextMenu.call(:term_details [line.term pos])
            ])

  Migration failure
    Module Cairo defined type Context
    Another module CodeView used Context as a function argument, like:
      def CodeView.draw(@self, cairo:Context canvas, Rect rect)
    After reloading Cairo, the CodeView module kept a reference to the old type?
   
  Type inferrence fail in extra_output from if-block

  This code had an error with no source location:
    letterSize = [painter.currentFont.width('AAAAAAAAAA') / 10, painter.currentFont.height] -> Point
  (where width & height both returned null)

Deprecated code to delete
  Unique names (replaced with global names and uniqueOrdinal)
  
Source repro
  Each branch should store the base indent level (instead of having this data in Term)

Code reload
  Bug fix, don't reload if the file has just been written and its size is 0. Maybe have a delay.

Interpreter
  Value() terms should just copy their values to the stack. Simplify stack_get_active_value.

Modules
  When compiling a module, the last value is automatically turned into an output (just
    like a function). This should probably be explicit for modules.

Types
  Should remove constructor syntax. Instead each type should get a synthetic method Typename.make
  As in:
    type T { int i }
    T.make(1)
