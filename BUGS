
Miscellanous (most-recent first)

  Builtin function Type.set_xxx was taking precedence over a user-defined set_ function

  In rewriting for-loop, shouldn't need an explicit name binding.

    This does work:

      for i in @L
        i = f()

    This doesn't work but we should make it work:

      for i in @L
        f()


  Some issues when using a for-loop as an expression. Example:
   
    (for s in [1 2 3] { to_string(s) }).join('')

  Assigning an element in a type doesn't cast that element. Example:

    type A {
      Point p
    }

    a = A.make
    a.p = [0 0]
    -- a.p is still a List instead of Point

  Method lookup cache:
    Currently does not cache method-on-module-ref, or hashtable value as method.

  Allow for the trailing part of a dot-expression to be on a new line:

     m = Map.make
       .set(:a 1)

  No source location for the contents of { module.:function }
    Fixed now, but need a complete test for source location.

  load_module should return Func for consistency

  Error trace for dynamic_method: should have the actual method name, when possible.

  A superfluous @ symbol causes problems:

      type A { int i }
      a = make(A)
      @a.i += 4
   
Deprecated code to delete
  Unique names (replaced with global names and uniqueOrdinal)
  
Source repro
  Each branch should store the base indent level (instead of having this data in Term)

Code reload
  Bug fix, don't reload if the file has just been written and its size is 0. Maybe have a delay?

Modules
  When compiling a module, the last value is automatically turned into an output (just
    like a function). This should probably be explicit for modules?
