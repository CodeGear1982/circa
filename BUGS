
Recent
  Explicit state didn't work in a function to left of arrow

    f(state = s) -> print

  Declared a function called 'add', and the + operator started using it?

  load_module should return Func for consistency

  Error trace for dynamic_method: should have the actual method name, when possible.
  
  This caused a crash: (a 'self' arg when not needed)

      def draggable(self, Rect rect) -> Point
        state is_dragging = false
        state Point drag_start_loc
        if context(:userInput).leftMouseDown and rect.contains(mousePos())
            is_dragging = true
            drag_start_loc = self.mousePos
        elif not context(:userInput).leftMouseDown
            is_dragging = false

        if is_dragging
            return mousePos() - drag_start_loc
        else
            return [0 0]
      
    
  Having a missing ) or ] or } symbol will *really* mess things up. Ditto for an extra ),},]

  Divide operator on Point didn't work?

  A superfluous @ symbol caused problems:

      type A { int i }
      a = make(A)
      @a.i += 4

  Changing a state var in a minor exiting block does not work:

      state s = 1
      if true
          s = 2
          return
          -- 's' will stay 1

  Got unrecognized expression on this string (missing '}'). Worst part is, no error reported.

    clickResolver.call([:add, lineRect, {
            pos = input()
            event = input()

            if event == :right_down
                contextMenu.call(:term_details [line.term pos])
            ])

  Migration failure
    Module Cairo defined type Context
    Another module CodeView used Context as a function argument, like:
      def CodeView.draw(@self, cairo:Context canvas, Rect rect)
    After reloading Cairo, the CodeView module kept a reference to the old type?

  Move output casting to a different spot. Currently it happens twice - once when a value
    is copied by output_placeholder (this is the correct spot), and again in finish_frame.
    It shouldn't happen in finish_frame, instead we should do the check after FireNative completes.
   
  Type inferrence fail in extra_output from if-block

  This code had an error with no source location:
    letterSize = [painter.currentFont.width('AAAAAAAAAA') / 10, painter.currentFont.height] -> Point
  (where width & height both returned null)

Deprecated code to delete
  Unique names (replaced with global names and uniqueOrdinal)
  
Source repro
  Each branch should store the base indent level (instead of having this data in Term)

Code reload
  Bug fix, don't reload if the file has just been written and its size is 0. Maybe have a delay.

Code cleanup
  Deprecate API using Term* or Function* to reference functions (prefer Branch*)

Interpreter
  Value() terms should just copy their values to the stack. Simplify stack_get_active_value.

State
  Inlined state doesn't work in a recursive function

Modules
  When compiling a module, the last value is automatically turned into an output (just
    like a function). This should probably be explicit for modules.

Types
  Should remove constructor syntax. Instead each type should get a synthetic method Typename.make
  As in:
    type T { int i }
    T.make(1)

Code modification
  Code modification should go through a more controlled path.
    Add a CodeModification class that stores a modification in progress
    Add a global apply_modification() function that invokes it.
    Alternately, require that modifications must be passed through message-send
      One goal is that modifications should be able to be sent remotely
