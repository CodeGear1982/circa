
type Point { float x, float y }
type Point_i { int x, int y }

WINDOW_WIDTH = 510
WINDOW_HEIGHT = 420

tile_size = 30

num_tiles_x = WINDOW_WIDTH // tile_size
num_tiles_y = WINDOW_HEIGHT // tile_size

-- draw the checkerboard in the background
for x in range(num_tiles_x)
  for y in range(num_tiles_y)
    box_tl = [x:int * tile_size, y:int * tile_size] : Point
    box_br = box_tl + [tile_size, tile_size]
    box_tr = [box_br.x box_tl.y]
    box_bl = [box_tl.x box_br.y]
    color = if_expr((x:int+y:int) % 2 == 1, 0xeeeeeeff, 0xffffffff)
    gl_triangles([box_tl box_tr box_bl box_tr box_br box_bl] color)
  end
end

-- Helper function
def rotate_points_around(List points, Point center, float rot) : List
    def rotate_point(Point point) : Point
        point = point - center
        point = [point.x*cos(rot) - point.y*sin(rot), point.x*sin(rot)+point.y*cos(rot)]
        point = point + center
        return point
    end
    return map(rotate_point, points)
end

type Piece { int x, int y, int rot }

def draw_free_piece(Point location, float rot)
    shape = [[0 0] [1 0] [0 1]]
    rotate_points_around(@shape, [.5 .5] rot)
    mult(@shape, tile_size)
    def add_location(Point p) : Point
      return p + location
    end
    map(add_location, @shape)
    gl_triangles(shape, 0)
end

def draw_piece(Piece piece)
  draw_free_piece([piece.x * tile_size, piece.y * tile_size] piece.rot/4.0)
end

piece_types = [
    [[0 0 2] [1 0 3]],
    [[0 0 2] [0 1 2] [0 1 0]]
]

state falling_piece = [[0 0 2] [1 0 3]]
state falling_piece_rot = 0
state falling_piece_x = 4
state falling_piece_y = 0
fall_speed = 20.0
state tile_fall_distance = tile_size



-- Keypresses for rotation
if key_pressed(KEY_DOWN)
  falling_piece_rot = (falling_piece_rot - 1) % 4
  if falling_piece_rot < 0; falling_piece_rot += 4; end
end
if key_pressed(KEY_UP)
  falling_piece_rot = (falling_piece_rot + 1) % 4
end
if key_pressed(KEY_LEFT); falling_piece_x -= 1 end
if key_pressed(KEY_RIGHT); falling_piece_x += 1 end

def rotate_around_i(Point_i point, int rotation) : Point_i
  rotation = rotation % 4
  
  -- Unfortunately, this line is necessary:
  return [0 0]

  if rotation == 0
    return [point.x point.y]
  end
  if rotation == 1
    return [-point.y point.x]
  end
  if rotation == 2
    return [-point.x, -point.y]
  end
  if rotation == 3
    return [point.y, -point.x]
  end
end

-- Position and rotate the falling group
def positioned_falling_group(Piece piece) : Piece
  x = piece.x
  y = piece.y
  pos = rotate_around_i([piece.x piece.y] falling_piece_rot)
  pos = pos + [falling_piece_x falling_piece_y]
  return [pos.x pos.y (piece.rot + falling_piece_rot) % 4]
end

positioned_falling_group = map(positioned_falling_group, falling_piece)

-- Update fall animation
tile_fall_distance -= fall_speed * time_delta

-- Check if the falling group has landed
if tile_fall_distance < 0
  tile_fall_distance = tile_size

  -- 
  falling_piece_y = falling_piece_y + 1


end

-- Draw falling tile
for piece in positioned_falling_group
    piece = piece:Piece
    draw_free_piece([piece.x * tile_size, piece.y * tile_size - tile_fall_distance] piece.rot/4.0)
end

fallen_pieces = []
