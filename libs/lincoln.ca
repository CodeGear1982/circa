
def defer_draw(any command)
    send('lincoln.draw', command)

namespace mode
    hidden = 0
    list_available_configs = 1
    highlight_config = 2

current_mode = receive_last('lincoln.current_mode', 0)
listed_configs = receive_last('lincoln.config_list', [])
highlighted_config = receive_last('lincoln.highlight_config' null)

-- Public functions

-- Draw the pink rounded rect. This is used for multiple purposes, and it smoothly
-- blends when it changes shape.
namespace activerect
    state rect = Rect()

    state transition_from = null
    state transition_to
    state time_since_target_change = 0.0

    time_since_target_change += td
    time_for_full_transition = 0.5

    reached_target = true

    target_rect = receive_last('lincoln.active.size' null)
    if target_rect != null and target_rect != transition_to
        transition_from = rect
        transition_to = target_rect
        time_since_target_change = 0.0

    if transition_from != null
        r = time_since_target_change / time_for_full_transition
        rect = interp_rect(transition_from transition_to r)
        send('lincoln.should_redraw' true)
        and(@reached_target false)
        if r > 1
            transition_from = null
            rect = transition_to

    Rect(@rect)

    -- Receive changes to opacity
    target_opacity = receive_stateful('lincoln.active.opacity', 0.0) -> number

    opacity = approach(target_opacity .1)

    if opacity != target_opacity
        send('lincoln.should_redraw' true)
        and(@reached_target false)
    else
        -- After we reach the target, redraw once more.
        if once()
            send('lincoln.should_redraw' true)

    def blend_color(Color c) -> Color
        c[3] = c[3] * opacity
        return c

    if changed(reached_target)
        send('lincoln.should_redraw' true)

    def draw(cairo:Context cr)
        p1 = [rect.x1 rect.y1]
        width = rect.x2 - rect.x1
        height = rect.y2 - rect.y1
        cairo:new_sub_path(cr)
        radius = 12.0
        cairo:arc(cr, p1 + [width - radius, radius] radius, -90, 0)
        cairo:arc(cr, p1 + [width - radius, height - radius], radius, 0, 90)
        cairo:arc(cr, p1 + [radius, height - radius], radius, 90, 180)
        cairo:arc(cr, p1 + [radius, radius], radius, 180, 270)
        cairo:close_path(cr)
        cairo:set_source_color(cr blend_color(#d08))
        cairo:fill_preserve(cr)
        cairo:set_source_color(cr blend_color(#00f8))
        cairo:set_line_width(cr 10.0)
        cairo:stroke(cr)

    defer_draw([draw])

def draw_highlighted_config(cairo:Context cr)

    topleft = [100 window.height - 100]

    gutter = 20
    inner_loc = topleft + [gutter gutter]

    name = "<name>"
    value = "<value>"
    if highlighted_config != null
        Ref(@highlighted_config)
        name = highlighted_config.name()
        value = highlighted_config.to_string()
    str = concat(name ' = ' value)

    if changed(str) trace('hi') --send('lincoln.should_redraw' true)

    cairo:select_font_face(cr "Sans")
    cairo:set_font_size(cr 20.0)
    str_extents = cairo:text_extents(cr str)

    str_width = str_extents.size[0]
    width = str_width + gutter*2
    text_height = str_extents.size[1]
    height = text_height + gutter*2

    -- draw text
    cairo:set_source_color(cr activerect:blend_color(#fff))
    cairo:move_to(cr inner_loc+[0 text_height])
    cairo:show_text(cr str)

    send('lincoln.active.size' to_rect(topleft [width height]))

def draw_config_list(cairo:Context cr)
    send('lincoln.active.size' [100 350 300 400])

if current_mode == mode:highlight_config
    defer_draw([draw_highlighted_config])
    send('lincoln.active.opacity' 1.0)
else
    send('lincoln.active.opacity' 0.0)


namespace post_frame
    state surface = null
    window_size = [window.width window.height]
    if surface == null or changed(window_size)
        surface = cairo:create_image_surface(window_size)

    state texture = opengl:new_texture_handle()

    commandList = receive('lincoln.draw')

    redraw = once() or changed(commandList)
    or(@redraw receive_last('lincoln.should_redraw' false))

    if redraw
        cr = cairo:create_context_for_surface(surface)

        -- Clear the buffer
        cairo:save(cr)
        cairo:set_operator(cr cairo:Operator:clear)
        cairo:paint(cr)
        cairo:restore(cr)

        -- run the command list
        for command in commandList
            List(@command)
            func = command[0]
            args = command.slice(1, command.length())

            args.insert(0, cr)

            dynamic_call(func args)

        cairo:upload_surface_to_opengl(surface texture)

    opengl:draw_texture_as_quad(texture to_rect([0 0] window_size))
