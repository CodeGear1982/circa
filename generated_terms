Having feedback functions generate terms causes problems.

The problem is, what if another term depends on a generated term? What happens when the feedback function is reevaluated, and this term ceases to exist?

Should we even allow terms to be based on generator terms? Some thoughts:

Maybe terms should be restricted to layers, and you can only use terms that are at the same layer, or upstream, from you.

Maybe term-creation operations can also be treated in a data-flow based matter. A step-by-step sequence of events:

- The code is in some state
- We want to apply some transformation function
- (1) This produces a new term which has the code in the new state
- There would be optimization: if a term only has one user, then we don't duplicate the data, the term would apply its change right to the original data.
- (2) Then, another transformation occurs which uses a term that was created in (1)
- Then, something affects the inputs of (1), or perhaps we change this term manually. Either way, the output of (1) changes
- The reevaluation engine causes (2) to be reevaluated, and all is well.

Question, how does (2) specify which term it wants to affect? It needs to be in some manner that (1) can change and (2) will still make sense.

Specifying terms:
 - probably done by name & scope

---

We need smart ways to figure out whether terms are constant. There are many different kinds of constancy. They include:

Will this term always have the same output value?
 - This is the highest form of constantcy, since it means that we can collapse it.
Will this term's inputs ever change?
Will this term's function ever change?
Will this term's state ever change?
Will this term always exist?

---

State duplication optimization:

If a term has a large output, we don't want to create a duplicate of this value for every step in the computation. This is a hard problem.

Compilation:

Should we compile to bytecode? (yes). 
